var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var THREE;
(function (THREE) {
    var AnimationAction;
    (function (AnimationAction) {
        var _new = (function () {
            function _new(mixer, clip, localRoot) {
                this._mixer = mixer;
                this._clip = clip;
                this._localRoot = localRoot || null;
                var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
                var interpolantSettings = {
                    endingStart: THREE.ZeroCurvatureEnding,
                    endingEnd: THREE.ZeroCurvatureEnding
                };
                for (var i = 0; i !== nTracks; ++i) {
                    var interpolant = tracks[i].createInterpolant(null);
                    interpolants[i] = interpolant;
                    interpolant.settings = interpolantSettings;
                }
                this._interpolantSettings = interpolantSettings;
                this._interpolants = interpolants;
                this._propertyBindings = new Array(nTracks);
                this._cacheIndex = null;
                this._byClipCacheIndex = null;
                this._timeScaleInterpolant = null;
                this._weightInterpolant = null;
                this.loop = THREE.LoopRepeat;
                this._loopCount = -1;
                this._startTime = null;
                this.time = 0;
                this.timeScale = 1;
                this._effectiveTimeScale = 1;
                this.weight = 1;
                this._effectiveWeight = 1;
                this.repetitions = Infinity;
                this.paused = false;
                this.enabled = true;
                this.clampWhenFinished = false;
                this.zeroSlopeAtStart = true;
                this.zeroSlopeAtEnd = true;
            }
            ;
            _new.prototype.play = function () {
                this._mixer._activateAction(this);
                return this;
            };
            _new.prototype.stop = function () {
                this._mixer._deactivateAction(this);
                return this.reset();
            };
            _new.prototype.reset = function () {
                this.paused = false;
                this.enabled = true;
                this.time = 0;
                this._loopCount = -1;
                this._startTime = null;
                return this.stopFading().stopWarping();
            };
            _new.prototype.isRunning = function () {
                var start = this._startTime;
                return this.enabled && !this.paused && this.timeScale !== 0 &&
                    this._startTime === null && this._mixer._isActiveAction(this);
            };
            _new.prototype.isScheduled = function () {
                return this._mixer._isActiveAction(this);
            };
            _new.prototype.startAt = function (time) {
                this._startTime = time;
                return this;
            };
            _new.prototype.setLoop = function (mode, repetitions) {
                this.loop = mode;
                this.repetitions = repetitions;
                return this;
            };
            _new.prototype.setEffectiveWeight = function (weight) {
                this.weight = weight;
                this._effectiveWeight = this.enabled ? weight : 0;
                return this.stopFading();
            };
            _new.prototype.getEffectiveWeight = function () {
                return this._effectiveWeight;
            };
            _new.prototype.fadeIn = function (duration) {
                return this._scheduleFading(duration, 0, 1);
            };
            _new.prototype.fadeOut = function (duration) {
                return this._scheduleFading(duration, 1, 0);
            };
            _new.prototype.crossFadeFrom = function (fadeOutAction, duration, warp) {
                var mixer = this._mixer;
                fadeOutAction.fadeOut(duration);
                this.fadeIn(duration);
                if (warp) {
                    var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
                    fadeOutAction.warp(1.0, startEndRatio, duration);
                    this.warp(endStartRatio, 1.0, duration);
                }
                return this;
            };
            _new.prototype.crossFadeTo = function (fadeInAction, duration, warp) {
                return fadeInAction.crossFadeFrom(this, duration, warp);
            };
            _new.prototype.stopFading = function () {
                var weightInterpolant = this._weightInterpolant;
                if (weightInterpolant !== null) {
                    this._weightInterpolant = null;
                    this._mixer._takeBackControlInterpolant(weightInterpolant);
                }
                return this;
            };
            _new.prototype.setEffectiveTimeScale = function (timeScale) {
                this.timeScale = timeScale;
                this._effectiveTimeScale = this.paused ? 0 : timeScale;
                return this.stopWarping();
            };
            _new.prototype.getEffectiveTimeScale = function () {
                return this._effectiveTimeScale;
            };
            _new.prototype.setDuration = function (duration) {
                this.timeScale = this._clip.duration / duration;
                return this.stopWarping();
            };
            _new.prototype.syncWith = function (action) {
                this.time = action.time;
                this.timeScale = action.timeScale;
                return this.stopWarping();
            };
            _new.prototype.halt = function (duration) {
                return this.warp(this._effectiveTimeScale, 0, duration);
            };
            _new.prototype.warp = function (startTimeScale, endTimeScale, duration) {
                var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;
                if (interpolant === null) {
                    interpolant = mixer._lendControlInterpolant(),
                        this._timeScaleInterpolant = interpolant;
                }
                var times = interpolant.parameterPositions, values = interpolant.sampleValues;
                times[0] = now;
                times[1] = now + duration;
                values[0] = startTimeScale / timeScale;
                values[1] = endTimeScale / timeScale;
                return this;
            };
            _new.prototype.stopWarping = function () {
                var timeScaleInterpolant = this._timeScaleInterpolant;
                if (timeScaleInterpolant !== null) {
                    this._timeScaleInterpolant = null;
                    this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
                }
                return this;
            };
            _new.prototype.getMixer = function () {
                return this._mixer;
            };
            _new.prototype.getClip = function () {
                return this._clip;
            };
            _new.prototype.getRoot = function () {
                return this._localRoot || this._mixer._root;
            };
            _new.prototype._update = function (time, deltaTime, timeDirection, accuIndex) {
                var startTime = this._startTime;
                if (startTime !== null) {
                    var timeRunning = (time - startTime) * timeDirection;
                    if (timeRunning < 0 || timeDirection === 0) {
                        return;
                    }
                    this._startTime = null;
                    deltaTime = timeDirection * timeRunning;
                }
                deltaTime *= this._updateTimeScale(time);
                var clipTime = this._updateTime(deltaTime);
                var weight = this._updateWeight(time);
                if (weight > 0) {
                    var interpolants = this._interpolants;
                    var propertyMixers = this._propertyBindings;
                    for (var j = 0, m = interpolants.length; j !== m; ++j) {
                        interpolants[j].evaluate(clipTime);
                        propertyMixers[j].accumulate(accuIndex, weight);
                    }
                }
            };
            _new.prototype._updateWeight = function (time) {
                var weight = 0;
                if (this.enabled) {
                    weight = this.weight;
                    var interpolant = this._weightInterpolant;
                    if (interpolant !== null) {
                        var interpolantValue = interpolant.evaluate(time)[0];
                        weight *= interpolantValue;
                        if (time > interpolant.parameterPositions[1]) {
                            this.stopFading();
                            if (interpolantValue === 0) {
                                this.enabled = false;
                            }
                        }
                    }
                }
                this._effectiveWeight = weight;
                return weight;
            };
            _new.prototype._updateTimeScale = function (time) {
                var timeScale = 0;
                if (!this.paused) {
                    timeScale = this.timeScale;
                    var interpolant = this._timeScaleInterpolant;
                    if (interpolant !== null) {
                        var interpolantValue = interpolant.evaluate(time)[0];
                        timeScale *= interpolantValue;
                        if (time > interpolant.parameterPositions[1]) {
                            this.stopWarping();
                            if (timeScale === 0) {
                                this.paused = true;
                            }
                            else {
                                this.timeScale = timeScale;
                            }
                        }
                    }
                }
                this._effectiveTimeScale = timeScale;
                return timeScale;
            };
            _new.prototype._updateTime = function (deltaTime) {
                var time = this.time + deltaTime;
                if (deltaTime === 0)
                    return time;
                var duration = this._clip.duration, loop = this.loop, loopCount = this._loopCount;
                if (loop === THREE.LoopOnce) {
                    if (loopCount === -1) {
                        this.loopCount = 0;
                        this._setEndings(true, true, false);
                    }
                    handle_stop: {
                        if (time >= duration) {
                            time = duration;
                        }
                        else if (time < 0) {
                            time = 0;
                        }
                        else
                            break handle_stop;
                        if (this.clampWhenFinished)
                            this.paused = true;
                        else
                            this.enabled = false;
                        this._mixer.dispatchEvent({
                            type: 'finished', action: this,
                            direction: deltaTime < 0 ? -1 : 1
                        });
                    }
                }
                else {
                    var pingPong = (loop === THREE.LoopPingPong);
                    if (loopCount === -1) {
                        if (deltaTime >= 0) {
                            loopCount = 0;
                            this._setEndings(true, this.repetitions === 0, pingPong);
                        }
                        else {
                            this._setEndings(this.repetitions === 0, true, pingPong);
                        }
                    }
                    if (time >= duration || time < 0) {
                        var loopDelta = THREE.Math.floor(time / duration);
                        time -= duration * loopDelta;
                        loopCount += THREE.Math.abs(loopDelta);
                        var pending = this.repetitions - loopCount;
                        if (pending < 0) {
                            if (this.clampWhenFinished)
                                this.paused = true;
                            else
                                this.enabled = false;
                            time = deltaTime > 0 ? duration : 0;
                            this._mixer.dispatchEvent({
                                type: 'finished', action: this,
                                direction: deltaTime > 0 ? 1 : -1
                            });
                        }
                        else {
                            if (pending === 0) {
                                var atStart = deltaTime < 0;
                                this._setEndings(atStart, !atStart, pingPong);
                            }
                            else {
                                this._setEndings(false, false, pingPong);
                            }
                            this._loopCount = loopCount;
                            this._mixer.dispatchEvent({
                                type: 'loop', action: this, loopDelta: loopDelta
                            });
                        }
                    }
                    if (pingPong && (loopCount & 1) === 1) {
                        this.time = time;
                        return duration - time;
                    }
                }
                this.time = time;
                return time;
            };
            _new.prototype._setEndings = function (atStart, atEnd, pingPong) {
                var settings = this._interpolantSettings;
                if (pingPong) {
                    settings.endingStart = THREE.ZeroSlopeEnding;
                    settings.endingEnd = THREE.ZeroSlopeEnding;
                }
                else {
                    if (atStart) {
                        settings.endingStart = this.zeroSlopeAtStart ?
                            THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;
                    }
                    else {
                        settings.endingStart = THREE.WrapAroundEnding;
                    }
                    if (atEnd) {
                        settings.endingEnd = this.zeroSlopeAtEnd ?
                            THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;
                    }
                    else {
                        settings.endingEnd = THREE.WrapAroundEnding;
                    }
                }
            };
            _new.prototype._scheduleFading = function (duration, weightNow, weightThen) {
                var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant;
                if (interpolant === null) {
                    interpolant = mixer._lendControlInterpolant(),
                        this._weightInterpolant = interpolant;
                }
                var times = interpolant.parameterPositions, values = interpolant.sampleValues;
                times[0] = now;
                values[0] = weightNow;
                times[1] = now + duration;
                values[1] = weightThen;
                return this;
            };
            return _new;
        }());
        AnimationAction._new = _new;
    })(AnimationAction = THREE.AnimationAction || (THREE.AnimationAction = {}));
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var AnimationClip = (function () {
        function AnimationClip(name, duration, tracks) {
            this.name = name;
            this.tracks = tracks;
            this.duration = (duration !== undefined) ? duration : -1;
            this.uuid = THREE.Math.generateUUID();
            if (this.duration < 0) {
                this.resetDuration();
            }
            this.trim();
            this.optimize();
        }
        ;
        AnimationClip.prototype.resetDuration = function () {
            var tracks = this.tracks, duration = 0;
            for (var i = 0, n = tracks.length; i !== n; ++i) {
                var track = this.tracks[i];
                duration = THREE.Math.max(duration, track.times[track.times.length - 1]);
            }
            this.duration = duration;
        };
        AnimationClip.prototype.trim = function () {
            for (var i = 0; i < this.tracks.length; i++) {
                this.tracks[i].trim(0, this.duration);
            }
            return this;
        };
        AnimationClip.prototype.optimize = function () {
            for (var i = 0; i < this.tracks.length; i++) {
                this.tracks[i].optimize();
            }
            return this;
        };
        AnimationClip.parse = function (json) {
            var tracks = [], jsonTracks = json.tracks, frameTime = 1.0 / (json.fps || 1.0);
            for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
                tracks.push(THREE.KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));
            }
            return new AnimationClip(json.name, json.duration, tracks);
        };
        AnimationClip.toJSON = function (clip) {
            var tracks = [], clipTracks = clip.tracks;
            var json = {
                'name': clip.name,
                'duration': clip.duration,
                'tracks': tracks
            };
            for (var i = 0, n = clipTracks.length; i !== n; ++i) {
                tracks.push(THREE.KeyframeTrack.toJSON(clipTracks[i]));
            }
            return json;
        };
        AnimationClip.CreateFromMorphTargetSequence = function (name, morphTargetSequence, fps, noLoop) {
            var numMorphTargets = morphTargetSequence.length;
            var tracks = [];
            for (var i = 0; i < numMorphTargets; i++) {
                var times = [];
                var values = [];
                times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
                values.push(0, 1, 0);
                var order = THREE.AnimationUtils.getKeyframeOrder(times);
                times = THREE.AnimationUtils.sortedArray(times, 1, order);
                values = THREE.AnimationUtils.sortedArray(values, 1, order);
                if (!noLoop && times[0] === 0) {
                    times.push(numMorphTargets);
                    values.push(values[0]);
                }
                tracks.push(new THREE.NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
            }
            return new AnimationClip(name, -1, tracks);
        };
        AnimationClip.findByName = function (objectOrClipArray, name) {
            var clipArray = objectOrClipArray;
            if (!Array.isArray(objectOrClipArray)) {
                var o = objectOrClipArray;
                clipArray = o.geometry && o.geometry.animations || o.animations;
            }
            for (var i = 0; i < clipArray.length; i++) {
                if (clipArray[i].name === name) {
                    return clipArray[i];
                }
            }
            return null;
        };
        AnimationClip.CreateClipsFromMorphTargetSequences = function (morphTargets, fps, noLoop) {
            var animationToMorphTargets = {};
            var pattern = /^([\w-]*?)([\d]+)$/;
            for (var i = 0, il = morphTargets.length; i < il; i++) {
                var morphTarget = morphTargets[i];
                var parts = morphTarget.name.match(pattern);
                if (parts && parts.length > 1) {
                    var name_1 = parts[1];
                    var animationMorphTargets = animationToMorphTargets[name_1];
                    if (!animationMorphTargets) {
                        animationToMorphTargets[name_1] = animationMorphTargets = [];
                    }
                    animationMorphTargets.push(morphTarget);
                }
            }
            var clips = [];
            for (var name_2 in animationToMorphTargets) {
                clips.push(AnimationClip.CreateFromMorphTargetSequence(name_2, animationToMorphTargets[name_2], fps, noLoop));
            }
            return clips;
        };
        AnimationClip.parseAnimation = function (animation, bones, nodeName) {
            if (!animation) {
                console.error("  no animation in JSONLoader data");
                return null;
            }
            var addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
                if (animationKeys.length !== 0) {
                    var times = [];
                    var values = [];
                    THREE.AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
                    if (times.length !== 0) {
                        destTracks.push(new trackType(trackName, times, values));
                    }
                }
            };
            var tracks = [];
            var clipName = animation.name || 'default';
            var duration = animation.length || -1;
            var fps = animation.fps || 30;
            var hierarchyTracks = animation.hierarchy || [];
            for (var h = 0; h < hierarchyTracks.length; h++) {
                var animationKeys = hierarchyTracks[h].keys;
                if (!animationKeys || animationKeys.length === 0)
                    continue;
                if (animationKeys[0].morphTargets) {
                    var morphTargetNames = {};
                    for (var k = 0; k < animationKeys.length; k++) {
                        if (animationKeys[k].morphTargets) {
                            for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                                morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                            }
                        }
                    }
                    for (var morphTargetName in morphTargetNames) {
                        var times = [];
                        var values = [];
                        for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                            var animationKey = animationKeys[k];
                            times.push(animationKey.time);
                            values.push((animationKey.morphTarget === morphTargetName) ? 1 : 0);
                        }
                        tracks.push(new THREE.NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
                    }
                    duration = morphTargetNames.length * (fps || 1.0);
                }
                else {
                    var boneName = '.bones[' + bones[h].name + ']';
                    addNonemptyTrack(THREE.VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
                    addNonemptyTrack(THREE.QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
                    addNonemptyTrack(THREE.VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
                }
            }
            if (tracks.length === 0) {
                return null;
            }
            var clip = new AnimationClip(clipName, duration, tracks);
            return clip;
        };
        return AnimationClip;
    }());
    THREE.AnimationClip = AnimationClip;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var EventDispatcher = (function () {
        function EventDispatcher() {
        }
        EventDispatcher.prototype.addEventListener = function (type, listener, _this) {
            if (this._listeners === undefined) {
                this._listeners = {};
                this._thises = {};
            }
            if (_this == undefined)
                _this = null;
            var listeners = this._listeners;
            var thises = this._thises;
            if (listeners[type] === undefined) {
                listeners[type] = [];
                thises[type] = [];
            }
            var index = listeners[type].indexOf(listener);
            while (index > -1) {
                if (thises[type][index] === _this)
                    break;
                index = listeners[type].indexOf(listener, index + 1);
            }
            if (index === -1) {
                listeners[type].push(listener);
                thises[type].push(_this == undefined ? null : _this);
            }
        };
        EventDispatcher.prototype.hasEventListener = function (type, listener, _this) {
            if (this._listeners === undefined)
                return false;
            if (_this === undefined)
                _this = null;
            var listeners = this._listeners;
            if (listeners[type] !== undefined) {
                var index = listeners[type].indexOf(listener);
                while (index > -1) {
                    if (this._thises[type][index] === _this)
                        return true;
                    index = listeners[type].indexOf(listener, index + 1);
                }
                return false;
            }
            return false;
        };
        EventDispatcher.prototype.removeEventListener = function (type, listener, _this) {
            if (this._listeners === undefined)
                return;
            if (_this === undefined)
                _this = null;
            var listeners = this._listeners;
            var listenerArray = listeners[type];
            var thisArray = this._thises[type];
            if (listenerArray !== undefined) {
                var index = listenerArray.indexOf(listener);
                while (index > -1) {
                    if (thisArray[index] === _this)
                        break;
                    index = listeners[type].indexOf(listener, index + 1);
                }
                if (index !== -1) {
                    listenerArray.splice(index, 1);
                    thisArray.splice(index, 1);
                }
            }
        };
        EventDispatcher.prototype.dispatchEvent = function (event) {
            if (this._listeners === undefined)
                return;
            var listeners = this._listeners;
            var listenerArray = listeners[event.type];
            var thisArray = this._thises[event.type];
            if (listenerArray !== undefined) {
                event.target = this;
                var array = [], i = 0;
                var thisArr = [];
                var length = listenerArray.length;
                for (i = 0; i < length; i++) {
                    array[i] = listenerArray[i];
                    thisArr[i] = thisArray[i] || this;
                }
                for (i = 0; i < length; i++) {
                    var _this = thisArr[i];
                    array[i].call(_this, event);
                }
            }
        };
        return EventDispatcher;
    }());
    THREE.EventDispatcher = EventDispatcher;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var AnimationMixer = (function (_super) {
        __extends(AnimationMixer, _super);
        function AnimationMixer(root) {
            _super.call(this);
            this._controlInterpolantsResultBuffer = new Float32Array(1);
            this._root = root;
            this._initMemoryManager();
            this._accuIndex = 0;
            this.time = 0;
            this.timeScale = 1.0;
        }
        ;
        AnimationMixer.prototype.clipAction = function (clip, optionalRoot) {
            var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ?
                THREE.AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
            if (actionsForClip !== undefined) {
                var existingAction = actionsForClip.actionByRoot[rootUuid];
                if (existingAction !== undefined) {
                    return existingAction;
                }
                prototypeAction = actionsForClip.knownActions[0];
                if (clipObject === null)
                    clipObject = prototypeAction._clip;
            }
            if (clipObject === null)
                return null;
            var newAction = new THREE.
                AnimationMixer._Action(this, clipObject, optionalRoot);
            this._bindAction(newAction, prototypeAction);
            this._addInactiveAction(newAction, clipUuid, rootUuid);
            return newAction;
        };
        AnimationMixer.prototype.existingAction = function (clip, optionalRoot) {
            var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ?
                THREE.AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
            if (actionsForClip !== undefined) {
                return actionsForClip.actionByRoot[rootUuid] || null;
            }
            return null;
        };
        AnimationMixer.prototype.stopAllAction = function () {
            var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;
            this._nActiveActions = 0;
            this._nActiveBindings = 0;
            for (var i = 0; i !== nActions; ++i) {
                actions[i].reset();
            }
            for (var i = 0; i !== nBindings; ++i) {
                bindings[i].useCount = 0;
            }
            return this;
        };
        AnimationMixer.prototype.update = function (deltaTime) {
            deltaTime *= this.timeScale;
            var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = THREE.Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
            for (var i = 0; i !== nActions; ++i) {
                var action = actions[i];
                if (action.enabled) {
                    action._update(time, deltaTime, timeDirection, accuIndex);
                }
            }
            var bindings = this._bindings, nBindings = this._nActiveBindings;
            for (var i = 0; i !== nBindings; ++i) {
                bindings[i].apply(accuIndex);
            }
            return this;
        };
        AnimationMixer.prototype.getRoot = function () {
            return this._root;
        };
        AnimationMixer.prototype.uncacheClip = function (clip) {
            var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
            if (actionsForClip !== undefined) {
                var actionsToRemove = actionsForClip.knownActions;
                for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
                    var action = actionsToRemove[i];
                    this._deactivateAction(action);
                    var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                    action._cacheIndex = null;
                    action._byClipCacheIndex = null;
                    lastInactiveAction._cacheIndex = cacheIndex;
                    actions[cacheIndex] = lastInactiveAction;
                    actions.pop();
                    this._removeInactiveBindingsForAction(action);
                }
                delete actionsByClip[clipUuid];
            }
        };
        AnimationMixer.prototype.uncacheRoot = function (root) {
            var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
            for (var clipUuid in actionsByClip) {
                var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
                if (action !== undefined) {
                    this._deactivateAction(action);
                    this._removeInactiveAction(action);
                }
            }
            var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
            if (bindingByName !== undefined) {
                for (var trackName in bindingByName) {
                    var binding = bindingByName[trackName];
                    binding.restoreOriginalState();
                    this._removeInactiveBinding(binding);
                }
            }
        };
        AnimationMixer.prototype.uncacheAction = function (clip, optionalRoot) {
            var action = this.existingAction(clip, optionalRoot);
            if (action !== null) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
            }
        };
        AnimationMixer.prototype._bindAction = function (action, prototypeAction) {
            var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
            if (bindingsByName === undefined) {
                bindingsByName = {};
                bindingsByRoot[rootUuid] = bindingsByName;
            }
            for (var i = 0; i !== nTracks; ++i) {
                var track = tracks[i], trackName = track.name, binding = bindingsByName[trackName];
                if (binding !== undefined) {
                    bindings[i] = binding;
                }
                else {
                    binding = bindings[i];
                    if (binding !== undefined) {
                        if (binding._cacheIndex === null) {
                            ++binding.referenceCount;
                            this._addInactiveBinding(binding, rootUuid, trackName);
                        }
                        continue;
                    }
                    var path = prototypeAction && prototypeAction.
                        _propertyBindings[i].binding.parsedPath;
                    binding = new THREE.PropertyMixer(THREE.PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
                    ++binding.referenceCount;
                    this._addInactiveBinding(binding, rootUuid, trackName);
                    bindings[i] = binding;
                }
                interpolants[i].resultBuffer = binding.buffer;
            }
        };
        AnimationMixer.prototype._activateAction = function (action) {
            if (!this._isActiveAction(action)) {
                if (action._cacheIndex === null) {
                    var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                    this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                    this._addInactiveAction(action, clipUuid, rootUuid);
                }
                var bindings = action._propertyBindings;
                for (var i = 0, n = bindings.length; i !== n; ++i) {
                    var binding = bindings[i];
                    if (binding.useCount++ === 0) {
                        this._lendBinding(binding);
                        binding.saveOriginalState();
                    }
                }
                this._lendAction(action);
            }
        };
        AnimationMixer.prototype._deactivateAction = function (action) {
            if (this._isActiveAction(action)) {
                var bindings = action._propertyBindings;
                for (var i = 0, n = bindings.length; i !== n; ++i) {
                    var binding = bindings[i];
                    if (--binding.useCount === 0) {
                        binding.restoreOriginalState();
                        this._takeBackBinding(binding);
                    }
                }
                this._takeBackAction(action);
            }
        };
        AnimationMixer.prototype._initMemoryManager = function () {
            this._actions = [];
            this._nActiveActions = 0;
            this._actionsByClip = {};
            this._bindings = [];
            this._nActiveBindings = 0;
            this._bindingsByRootAndName = {};
            this._controlInterpolants = [];
            this._nActiveControlInterpolants = 0;
            var scope = this;
            this.stats = {
                actions: {
                    get total() { return scope._actions.length; },
                    get inUse() { return scope._nActiveActions; }
                },
                bindings: {
                    get total() { return scope._bindings.length; },
                    get inUse() { return scope._nActiveBindings; }
                },
                controlInterpolants: {
                    get total() { return scope._controlInterpolants.length; },
                    get inUse() { return scope._nActiveControlInterpolants; }
                }
            };
        };
        AnimationMixer.prototype._isActiveAction = function (action) {
            var index = action._cacheIndex;
            return index !== null && index < this._nActiveActions;
        };
        AnimationMixer.prototype._addInactiveAction = function (action, clipUuid, rootUuid) {
            var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
            if (actionsForClip === undefined) {
                actionsForClip = {
                    knownActions: [action],
                    actionByRoot: {}
                };
                action._byClipCacheIndex = 0;
                actionsByClip[clipUuid] = actionsForClip;
            }
            else {
                var knownActions = actionsForClip.knownActions;
                action._byClipCacheIndex = knownActions.length;
                knownActions.push(action);
            }
            action._cacheIndex = actions.length;
            actions.push(action);
            actionsForClip.actionByRoot[rootUuid] = action;
        };
        AnimationMixer.prototype._removeInactiveAction = function (action) {
            var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
            lastInactiveAction._cacheIndex = cacheIndex;
            actions[cacheIndex] = lastInactiveAction;
            actions.pop();
            action._cacheIndex = null;
            var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
            lastKnownAction._byClipCacheIndex = byClipCacheIndex;
            knownActionsForClip[byClipCacheIndex] = lastKnownAction;
            knownActionsForClip.pop();
            action._byClipCacheIndex = null;
            var actionByRoot = actionsForClip.actionByRoot, rootUuid = (actions._localRoot || this._root).uuid;
            delete actionByRoot[rootUuid];
            if (knownActionsForClip.length === 0) {
                delete actionsByClip[clipUuid];
            }
            this._removeInactiveBindingsForAction(action);
        };
        AnimationMixer.prototype._removeInactiveBindingsForAction = function (action) {
            var bindings = action._propertyBindings;
            for (var i = 0, n = bindings.length; i !== n; ++i) {
                var binding = bindings[i];
                if (--binding.referenceCount === 0) {
                    this._removeInactiveBinding(binding);
                }
            }
        };
        AnimationMixer.prototype._lendAction = function (action) {
            var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
            action._cacheIndex = lastActiveIndex;
            actions[lastActiveIndex] = action;
            firstInactiveAction._cacheIndex = prevIndex;
            actions[prevIndex] = firstInactiveAction;
        };
        AnimationMixer.prototype._takeBackAction = function (action) {
            var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
            action._cacheIndex = firstInactiveIndex;
            actions[firstInactiveIndex] = action;
            lastActiveAction._cacheIndex = prevIndex;
            actions[prevIndex] = lastActiveAction;
        };
        AnimationMixer.prototype._addInactiveBinding = function (binding, rootUuid, trackName) {
            var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;
            if (bindingByName === undefined) {
                bindingByName = {};
                bindingsByRoot[rootUuid] = bindingByName;
            }
            bindingByName[trackName] = binding;
            binding._cacheIndex = bindings.length;
            bindings.push(binding);
        };
        AnimationMixer.prototype._removeInactiveBinding = function (binding) {
            var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
            lastInactiveBinding._cacheIndex = cacheIndex;
            bindings[cacheIndex] = lastInactiveBinding;
            bindings.pop();
            delete bindingByName[trackName];
            remove_empty_map: {
                for (var _ in bindingByName)
                    break remove_empty_map;
                delete bindingsByRoot[rootUuid];
            }
        };
        AnimationMixer.prototype._lendBinding = function (binding) {
            var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
            binding._cacheIndex = lastActiveIndex;
            bindings[lastActiveIndex] = binding;
            firstInactiveBinding._cacheIndex = prevIndex;
            bindings[prevIndex] = firstInactiveBinding;
        };
        AnimationMixer.prototype._takeBackBinding = function (binding) {
            var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
            binding._cacheIndex = firstInactiveIndex;
            bindings[firstInactiveIndex] = binding;
            lastActiveBinding._cacheIndex = prevIndex;
            bindings[prevIndex] = lastActiveBinding;
        };
        AnimationMixer.prototype._lendControlInterpolant = function () {
            var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
            if (interpolant === undefined) {
                interpolant = new THREE.LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
                interpolant.__cacheIndex = lastActiveIndex;
                interpolants[lastActiveIndex] = interpolant;
            }
            return interpolant;
        };
        AnimationMixer.prototype._takeBackControlInterpolant = function (interpolant) {
            var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
            interpolant.__cacheIndex = firstInactiveIndex;
            interpolants[firstInactiveIndex] = interpolant;
            lastActiveInterpolant.__cacheIndex = prevIndex;
            interpolants[prevIndex] = lastActiveInterpolant;
        };
        AnimationMixer._Action = THREE.AnimationAction._new;
        return AnimationMixer;
    }(THREE.EventDispatcher));
    THREE.AnimationMixer = AnimationMixer;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var AnimationObjectGroup = (function () {
        function AnimationObjectGroup(var_args) {
            this.uuid = THREE.Math.generateUUID();
            this._objects = Array.prototype.slice.call(arguments);
            this.nCachedObjects_ = 0;
            var indices = {};
            this._indicesByUUID = indices;
            for (var i = 0, n = arguments.length; i !== n; ++i) {
                indices[arguments[i].uuid] = i;
            }
            this._paths = [];
            this._parsedPaths = [];
            this._bindings = [];
            this._bindingsIndicesByPath = {};
            var scope = this;
            this.stats = {
                objects: {
                    get total() { return scope._objects.length; },
                    get inUse() { return this.total - scope.nCachedObjects_; }
                },
                get bindingsPerObject() { return scope._bindings.length; }
            };
        }
        AnimationObjectGroup.prototype.add = function (var_args) {
            var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
            for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (index === undefined) {
                    index = nObjects++;
                    indicesByUUID[uuid] = index;
                    objects.push(object);
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        bindings[j].push(new THREE.PropertyBinding(object, paths[j], parsedPaths[j]));
                    }
                }
                else if (index < nCachedObjects) {
                    var knownObject = objects[index];
                    var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                    indicesByUUID[lastCachedObject.uuid] = index;
                    objects[index] = lastCachedObject;
                    indicesByUUID[uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = object;
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index];
                        bindingsForPath[index] = lastCached;
                        if (binding === undefined) {
                            binding = new THREE.PropertyBinding(object, paths[j], parsedPaths[j]);
                        }
                        bindingsForPath[firstActiveIndex] = binding;
                    }
                }
                else if (objects[index] !== knownObject) {
                    console.error("Different objects with the same UUID " +
                        "detected. Clean the caches or recreate your " +
                        "infrastructure when reloading scenes...");
                }
            }
            this.nCachedObjects_ = nCachedObjects;
        };
        AnimationObjectGroup.prototype.remove = function (var_args) {
            var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
            for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (index !== undefined && index >= nCachedObjects) {
                    var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                    indicesByUUID[firstActiveObject.uuid] = index;
                    objects[index] = firstActiveObject;
                    indicesByUUID[uuid] = lastCachedIndex;
                    objects[lastCachedIndex] = object;
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                        bindingsForPath[index] = firstActive;
                        bindingsForPath[lastCachedIndex] = binding;
                    }
                }
            }
            this.nCachedObjects_ = nCachedObjects;
        };
        AnimationObjectGroup.prototype.uncache = function (var_args) {
            var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
            for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (index !== undefined) {
                    delete indicesByUUID[uuid];
                    if (index < nCachedObjects) {
                        var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                        indicesByUUID[lastCachedObject.uuid] = index;
                        objects[index] = lastCachedObject;
                        indicesByUUID[lastObject.uuid] = firstActiveIndex;
                        objects[firstActiveIndex] = lastObject;
                        objects.pop();
                        for (var j = 0, m = nBindings; j !== m; ++j) {
                            var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                            bindingsForPath[index] = lastCached;
                            bindingsForPath[firstActiveIndex] = last;
                            bindingsForPath.pop();
                        }
                    }
                    else {
                        var lastIndex = --nObjects, lastObject = objects[lastIndex];
                        indicesByUUID[lastObject.uuid] = index;
                        objects[index] = lastObject;
                        objects.pop();
                        for (var j = 0, m = nBindings; j !== m; ++j) {
                            var bindingsForPath = bindings[j];
                            bindingsForPath[index] = bindingsForPath[lastIndex];
                            bindingsForPath.pop();
                        }
                    }
                }
            }
            this.nCachedObjects_ = nCachedObjects;
        };
        AnimationObjectGroup.prototype.subscribe_ = function (path, parsedPath) {
            var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
            if (index !== undefined)
                return bindings[index];
            var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
            index = bindings.length;
            indicesByPath[path] = index;
            paths.push(path);
            parsedPaths.push(parsedPath);
            bindings.push(bindingsForPath);
            for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
                var object = objects[i];
                bindingsForPath[i] =
                    new THREE.PropertyBinding(object, path, parsedPath);
            }
            return bindingsForPath;
        };
        AnimationObjectGroup.prototype.unsubscribe_ = function (path) {
            var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
            if (index !== undefined) {
                var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
                indicesByPath[lastBindingsPath] = index;
                bindings[index] = lastBindings;
                bindings.pop();
                parsedPaths[index] = parsedPaths[lastBindingsIndex];
                parsedPaths.pop();
                paths[index] = paths[lastBindingsIndex];
                paths.pop();
            }
        };
        return AnimationObjectGroup;
    }());
    THREE.AnimationObjectGroup = AnimationObjectGroup;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var AnimationUtils = (function () {
        function AnimationUtils() {
        }
        AnimationUtils.arraySlice = function (array, from, to) {
            if (AnimationUtils.isTypedArray(array)) {
                return new array.constructor(array.subarray(from, to));
            }
            return array.slice(from, to);
        };
        AnimationUtils.convertArray = function (array, type, forceClone) {
            if (!array ||
                !forceClone && array.constructor === type)
                return array;
            if (typeof type.BYTES_PER_ELEMENT === 'number') {
                return new type(array);
            }
            return Array.prototype.slice.call(array);
        };
        AnimationUtils.isTypedArray = function (object) {
            return ArrayBuffer.isView(object) &&
                !(object instanceof DataView);
        };
        AnimationUtils.getKeyframeOrder = function (times) {
            function compareTime(i, j) {
                return times[i] - times[j];
            }
            var n = times.length;
            var result = new Array(n);
            for (var i = 0; i !== n; ++i)
                result[i] = i;
            result.sort(compareTime);
            return result;
        };
        AnimationUtils.sortedArray = function (values, stride, order) {
            var nValues = values.length;
            var result = new values.constructor(nValues);
            for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
                var srcOffset = order[i] * stride;
                for (var j = 0; j !== stride; ++j) {
                    result[dstOffset++] = values[srcOffset + j];
                }
            }
            return result;
        };
        AnimationUtils.flattenJSON = function (jsonKeys, times, values, valuePropertyName) {
            var i = 1, key = jsonKeys[0];
            while (key !== undefined && key[valuePropertyName] === undefined) {
                key = jsonKeys[i++];
            }
            if (key === undefined)
                return;
            var value = key[valuePropertyName];
            if (value === undefined)
                return;
            if (Array.isArray(value)) {
                do {
                    value = key[valuePropertyName];
                    if (value !== undefined) {
                        times.push(key.time);
                        values.push.apply(values, value);
                    }
                    key = jsonKeys[i++];
                } while (key !== undefined);
            }
            else if (value.toArray !== undefined) {
                do {
                    value = key[valuePropertyName];
                    if (value !== undefined) {
                        times.push(key.time);
                        value.toArray(values, values.length);
                    }
                    key = jsonKeys[i++];
                } while (key !== undefined);
            }
            else {
                do {
                    value = key[valuePropertyName];
                    if (value !== undefined) {
                        times.push(key.time);
                        values.push(value);
                    }
                    key = jsonKeys[i++];
                } while (key !== undefined);
            }
        };
        return AnimationUtils;
    }());
    THREE.AnimationUtils = AnimationUtils;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var KeyframeTrack = (function () {
        function KeyframeTrack(name, times, values, interpolation) {
            this.DefaultInterpolation = THREE.InterpolateLinear;
            if (name === undefined)
                throw new Error("track name is undefined");
            if (times === undefined || times.length === 0) {
                throw new Error("no keyframes in track named " + name);
            }
            this.name = name;
            this.times = THREE.AnimationUtils.convertArray(times, this.TimeBufferType);
            this.values = THREE.AnimationUtils.convertArray(values, this.ValueBufferType);
            this.setInterpolation(interpolation || this.DefaultInterpolation);
            this.validate();
            this.optimize();
        }
        ;
        KeyframeTrack.prototype.InterpolantFactoryMethodDiscrete = function (result) {
            return new THREE.DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
        };
        KeyframeTrack.prototype.InterpolantFactoryMethodLinear = function (result) {
            return new THREE.LinearInterpolant(this.times, this.values, this.getValueSize(), result);
        };
        KeyframeTrack.prototype.InterpolantFactoryMethodSmooth = function (result) {
            return new THREE.CubicInterpolant(this.times, this.values, this.getValueSize(), result);
        };
        KeyframeTrack.prototype.setInterpolation = function (interpolation) {
            var factoryMethod;
            switch (interpolation) {
                case THREE.InterpolateDiscrete:
                    factoryMethod = this.InterpolantFactoryMethodDiscrete;
                    break;
                case THREE.InterpolateLinear:
                    factoryMethod = this.InterpolantFactoryMethodLinear;
                    break;
                case THREE.InterpolateSmooth:
                    factoryMethod = this.InterpolantFactoryMethodSmooth;
                    break;
            }
            if (factoryMethod === undefined) {
                var message = "unsupported interpolation for " +
                    this.ValueTypeName + " keyframe track named " + this.name;
                if (this.createInterpolant === undefined) {
                    if (interpolation !== this.DefaultInterpolation) {
                        this.setInterpolation(this.DefaultInterpolation);
                    }
                    else {
                        throw new Error(message);
                    }
                }
                console.warn(message);
                return;
            }
            this.createInterpolant = factoryMethod;
        };
        KeyframeTrack.prototype.getInterpolation = function () {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return THREE.InterpolateDiscrete;
                case this.InterpolantFactoryMethodLinear:
                    return THREE.InterpolateLinear;
                case this.InterpolantFactoryMethodSmooth:
                    return THREE.InterpolateSmooth;
            }
        };
        KeyframeTrack.prototype.getValueSize = function () {
            return this.values.length / this.times.length;
        };
        KeyframeTrack.prototype.shift = function (timeOffset) {
            if (timeOffset !== 0.0) {
                var times = this.times;
                for (var i = 0, n = times.length; i !== n; ++i) {
                    times[i] += timeOffset;
                }
            }
            return this;
        };
        KeyframeTrack.prototype.scale = function (timeScale) {
            if (timeScale !== 1.0) {
                var times = this.times;
                for (var i = 0, n = times.length; i !== n; ++i) {
                    times[i] *= timeScale;
                }
            }
            return this;
        };
        KeyframeTrack.prototype.trim = function (startTime, endTime) {
            var times = this.times, nKeys = times.length, from = 0, to = nKeys - 1;
            while (from !== nKeys && times[from] < startTime)
                ++from;
            while (to !== -1 && times[to] > endTime)
                --to;
            ++to;
            if (from !== 0 || to !== nKeys) {
                if (from >= to)
                    to = THREE.Math.max(to, 1), from = to - 1;
                var stride = this.getValueSize();
                this.times = THREE.AnimationUtils.arraySlice(times, from, to);
                this.values = THREE.AnimationUtils.
                    arraySlice(this.values, from * stride, to * stride);
            }
            return this;
        };
        KeyframeTrack.prototype.validate = function () {
            var valid = true;
            var valueSize = this.getValueSize();
            if (valueSize - THREE.Math.floor(valueSize) !== 0) {
                console.error("invalid value size in track", this);
                valid = false;
            }
            var times = this.times, values = this.values, nKeys = times.length;
            if (nKeys === 0) {
                console.error("track is empty", this);
                valid = false;
            }
            var prevTime = null;
            for (var i = 0; i !== nKeys; i++) {
                var currTime = times[i];
                if (typeof currTime === 'number' && isNaN(currTime)) {
                    console.error("time is not a valid number", this, i, currTime);
                    valid = false;
                    break;
                }
                if (prevTime !== null && prevTime > currTime) {
                    console.error("out of order keys", this, i, currTime, prevTime);
                    valid = false;
                    break;
                }
                prevTime = currTime;
            }
            if (values !== undefined) {
                if (THREE.AnimationUtils.isTypedArray(values)) {
                    for (var i = 0, n = values.length; i !== n; ++i) {
                        var value = values[i];
                        if (isNaN(value)) {
                            console.error("value is not a valid number", this, i, value);
                            valid = false;
                            break;
                        }
                    }
                }
            }
            return valid;
        };
        KeyframeTrack.prototype.optimize = function () {
            var times = this.times, values = this.values, stride = this.getValueSize(), writeIndex = 1;
            for (var i = 1, n = times.length - 1; i <= n; ++i) {
                var keep = false;
                var time = times[i];
                var timeNext = times[i + 1];
                if (time !== timeNext && (i !== 1 || time !== time[0])) {
                    var offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
                    for (var j = 0; j !== stride; ++j) {
                        var value = values[offset + j];
                        if (value !== values[offsetP + j] ||
                            value !== values[offsetN + j]) {
                            keep = true;
                            break;
                        }
                    }
                }
                if (keep) {
                    if (i !== writeIndex) {
                        times[writeIndex] = times[i];
                        var readOffset = i * stride, writeOffset = writeIndex * stride;
                        for (var j = 0; j !== stride; ++j) {
                            values[writeOffset + j] = values[readOffset + j];
                        }
                    }
                    ++writeIndex;
                }
            }
            if (writeIndex !== times.length) {
                this.times = THREE.AnimationUtils.arraySlice(times, 0, writeIndex);
                this.values = THREE.AnimationUtils.arraySlice(values, 0, writeIndex * stride);
            }
            return this;
        };
        KeyframeTrack.parse = function (json) {
            if (json.type === undefined) {
                throw new Error("track type undefined, can not parse");
            }
            var trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName(json.type);
            if (json.times === undefined) {
                var times = [], values = [];
                THREE.AnimationUtils.flattenJSON(json.keys, times, values, 'value');
                json.times = times;
                json.values = values;
            }
            if (trackType.parse !== undefined && trackType.parse !== KeyframeTrack.parse) {
                return trackType.parse(json);
            }
            else {
                return new trackType(json.name, json.times, json.values, json.interpolation);
            }
        };
        KeyframeTrack.toJSON = function (track) {
            var trackType = track.constructor;
            var json;
            if (trackType.toJSON !== undefined) {
                json = trackType.toJSON(track);
            }
            else {
                json = {
                    'name': track.name,
                    'times': THREE.AnimationUtils.convertArray(track.times, Array),
                    'values': THREE.AnimationUtils.convertArray(track.values, Array)
                };
                var interpolation = track.getInterpolation();
                if (interpolation !== track.DefaultInterpolation) {
                    json.interpolation = interpolation;
                }
            }
            json.type = track.ValueTypeName;
            return json;
        };
        KeyframeTrack._getTrackTypeForValueTypeName = function (typeName) {
            switch (typeName.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return THREE.NumberKeyframeTrack;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return THREE.VectorKeyframeTrack;
                case "color":
                    return THREE.ColorKeyframeTrack;
                case "quaternion":
                    return THREE.QuaternionKeyframeTrack;
                case "bool":
                case "boolean":
                    return THREE.BooleanKeyframeTrack;
                case "string":
                    return THREE.StringKeyframeTrack;
            }
            throw new Error("Unsupported typeName: " + typeName);
        };
        return KeyframeTrack;
    }());
    THREE.KeyframeTrack = KeyframeTrack;
    KeyframeTrack.prototype.TimeBufferType = Float32Array;
    KeyframeTrack.prototype.ValueBufferType = Float32Array;
    KeyframeTrack.prototype.DefaultInterpolation = THREE.InterpolateLinear;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var PropertyBinding = (function () {
        function PropertyBinding(rootNode, path, parsedPath) {
            this.BindingType = {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            };
            this.Versioning = {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            };
            this.GetterByBindingType = [
                this.getValue_direct,
                this.getValue_array,
                this.getValue_arrayElement,
                this.getValue_toArray
            ];
            this.SetterByBindingTypeAndVersioning = [
                [
                    this.setValue_direct,
                    this.setValue_direct_setNeedsUpdate,
                    this.setValue_direct_setMatrixWorldNeedsUpdate
                ],
                [
                    this.setValue_array,
                    this.setValue_array_setNeedsUpdate,
                    this.setValue_array_setMatrixWorldNeedsUpdate
                ],
                [
                    this.setValue_arrayElement,
                    this.setValue_arrayElement_setNeedsUpdate,
                    this.setValue_arrayElement_setMatrixWorldNeedsUpdate
                ],
                [
                    this.setValue_fromArray,
                    this.setValue_fromArray_setNeedsUpdate,
                    this.setValue_fromArray_setMatrixWorldNeedsUpdate
                ]
            ];
            this.path = path;
            this.parsedPath = parsedPath ||
                PropertyBinding.parseTrackName(path);
            this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
            this.rootNode = rootNode;
        }
        ;
        PropertyBinding.prototype.getValue = function (targetArray, offset) {
            this.bind();
            this.getValue(targetArray, offset);
        };
        PropertyBinding.prototype.setValue = function (sourceArray, offset) {
            this.bind();
            this.setValue(sourceArray, offset);
        };
        PropertyBinding.prototype.bind = function () {
            var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
            if (!targetObject) {
                targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
                this.node = targetObject;
            }
            this.getValue = this._getValue_unavailable;
            this.setValue = this._setValue_unavailable;
            if (!targetObject) {
                console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
                return;
            }
            if (objectName) {
                var objectIndex = parsedPath.objectIndex;
                switch (objectName) {
                    case 'materials':
                        if (!targetObject.material) {
                            console.error('  can not bind to material as node does not have a material', this);
                            return;
                        }
                        if (!targetObject.material.materials) {
                            console.error('  can not bind to material.materials as node.material does not have a materials array', this);
                            return;
                        }
                        targetObject = targetObject.material.materials;
                        break;
                    case 'bones':
                        if (!targetObject.skeleton) {
                            console.error('  can not bind to bones as node does not have a skeleton', this);
                            return;
                        }
                        targetObject = targetObject.skeleton.bones;
                        for (var i = 0; i < targetObject.length; i++) {
                            if (targetObject[i].name === objectIndex) {
                                objectIndex = i;
                                break;
                            }
                        }
                        break;
                    default:
                        if (targetObject[objectName] === undefined) {
                            console.error('  can not bind to objectName of node, undefined', this);
                            return;
                        }
                        targetObject = targetObject[objectName];
                }
                if (objectIndex !== undefined) {
                    if (targetObject[objectIndex] === undefined) {
                        console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject);
                        return;
                    }
                    targetObject = targetObject[objectIndex];
                }
            }
            var nodeProperty = targetObject[propertyName];
            if (nodeProperty === undefined) {
                var nodeName = parsedPath.nodeName;
                console.error("  trying to update property for track: " + nodeName +
                    '.' + propertyName + " but it wasn't found.", targetObject);
                return;
            }
            var versioning = this.Versioning.None;
            if (targetObject.needsUpdate !== undefined) {
                versioning = this.Versioning.NeedsUpdate;
                this.targetObject = targetObject;
            }
            else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
                versioning = this.Versioning.MatrixWorldNeedsUpdate;
                this.targetObject = targetObject;
            }
            var bindingType = this.BindingType.Direct;
            if (propertyIndex !== undefined) {
                if (propertyName === "morphTargetInfluences") {
                    if (!targetObject.geometry) {
                        console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry', this);
                        return;
                    }
                    if (!targetObject.geometry.morphTargets) {
                        console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this);
                        return;
                    }
                    for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
                        if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
                            propertyIndex = i;
                            break;
                        }
                    }
                }
                bindingType = this.BindingType.ArrayElement;
                this.resolvedProperty = nodeProperty;
                this.propertyIndex = propertyIndex;
            }
            else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
                bindingType = this.BindingType.HasFromToArray;
                this.resolvedProperty = nodeProperty;
            }
            else if (nodeProperty.length !== undefined) {
                bindingType = this.BindingType.EntireArray;
                this.resolvedProperty = nodeProperty;
            }
            else {
                this.propertyName = propertyName;
            }
            this.getValue = this.GetterByBindingType[bindingType];
            this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
        };
        PropertyBinding.prototype.unbind = function () {
            this.node = null;
            this.getValue = this._getValue_unbound;
            this.setValue = this._setValue_unbound;
        };
        PropertyBinding.prototype._getValue_unavailable = function () { };
        PropertyBinding.prototype._setValue_unavailable = function () { };
        PropertyBinding.prototype._getValue_unbound = function () { };
        PropertyBinding.prototype._setValue_unbound = function () { };
        PropertyBinding.prototype.getValue_direct = function (buffer, offset) {
            buffer[offset] = this.node[this.propertyName];
        };
        PropertyBinding.prototype.getValue_array = function (buffer, offset) {
            var source = this.resolvedProperty;
            for (var i = 0, n = source.length; i !== n; ++i) {
                buffer[offset++] = source[i];
            }
        };
        PropertyBinding.prototype.getValue_arrayElement = function (buffer, offset) {
            buffer[offset] = this.resolvedProperty[this.propertyIndex];
        };
        PropertyBinding.prototype.getValue_toArray = function (buffer, offset) {
            this.resolvedProperty.toArray(buffer, offset);
        };
        PropertyBinding.prototype.setValue_direct = function (buffer, offset) {
            this.node[this.propertyName] = buffer[offset];
        };
        PropertyBinding.prototype.setValue_direct_setNeedsUpdate = function (buffer, offset) {
            this.node[this.propertyName] = buffer[offset];
            this.targetObject.needsUpdate = true;
        };
        PropertyBinding.prototype.setValue_direct_setMatrixWorldNeedsUpdate = function (buffer, offset) {
            this.node[this.propertyName] = buffer[offset];
            this.targetObject.matrixWorldNeedsUpdate = true;
        };
        PropertyBinding.prototype.setValue_array = function (buffer, offset) {
            var dest = this.resolvedProperty;
            for (var i = 0, n = dest.length; i !== n; ++i) {
                dest[i] = buffer[offset++];
            }
        };
        PropertyBinding.prototype.setValue_array_setNeedsUpdate = function (buffer, offset) {
            var dest = this.resolvedProperty;
            for (var i = 0, n = dest.length; i !== n; ++i) {
                dest[i] = buffer[offset++];
            }
            this.targetObject.needsUpdate = true;
        };
        PropertyBinding.prototype.setValue_array_setMatrixWorldNeedsUpdate = function (buffer, offset) {
            var dest = this.resolvedProperty;
            for (var i = 0, n = dest.length; i !== n; ++i) {
                dest[i] = buffer[offset++];
            }
            this.targetObject.matrixWorldNeedsUpdate = true;
        };
        PropertyBinding.prototype.setValue_arrayElement = function (buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset];
        };
        PropertyBinding.prototype.setValue_arrayElement_setNeedsUpdate = function (buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset];
            this.targetObject.needsUpdate = true;
        };
        PropertyBinding.prototype.setValue_arrayElement_setMatrixWorldNeedsUpdate = function (buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset];
            this.targetObject.matrixWorldNeedsUpdate = true;
        };
        PropertyBinding.prototype.setValue_fromArray = function (buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset);
        };
        PropertyBinding.prototype.setValue_fromArray_setNeedsUpdate = function (buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset);
            this.targetObject.needsUpdate = true;
        };
        PropertyBinding.prototype.setValue_fromArray_setMatrixWorldNeedsUpdate = function (buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset);
            this.targetObject.matrixWorldNeedsUpdate = true;
        };
        PropertyBinding.create = function (root, path, parsedPath) {
            if (!(root instanceof THREE.AnimationObjectGroup)) {
                return new PropertyBinding(root, path, parsedPath);
            }
            else {
                return new PropertyBindingComposite(root, path, parsedPath);
            }
        };
        ;
        PropertyBinding.parseTrackName = function (trackName) {
            var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_.:\- ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/;
            var matches = re.exec(trackName);
            if (!matches) {
                throw new Error("cannot parse trackName at all: " + trackName);
            }
            if (matches.index === re.lastIndex) {
                re.lastIndex++;
            }
            var results = {
                nodeName: matches[3],
                objectName: matches[5],
                objectIndex: matches[7],
                propertyName: matches[9],
                propertyIndex: matches[11]
            };
            if (results.propertyName === null || results.propertyName.length === 0) {
                throw new Error("can not parse propertyName from trackName: " + trackName);
            }
            return results;
        };
        ;
        PropertyBinding.findNode = function (root, nodeName) {
            if (!nodeName
                || nodeName === ""
                || nodeName === "root"
                || nodeName === "."
                || nodeName === -1
                || nodeName === root.name
                || nodeName === root.uuid) {
                return root;
            }
            if (root.skeleton) {
                var searchSkeleton = function (skeleton) {
                    for (var i = 0; i < skeleton.bones.length; i++) {
                        var bone = skeleton.bones[i];
                        if (bone.name === nodeName) {
                            return bone;
                        }
                    }
                    return null;
                };
                var bone = searchSkeleton(root.skeleton);
                if (bone) {
                    return bone;
                }
            }
            if (root.children) {
                var searchNodeSubtree = function (children) {
                    for (var i = 0; i < children.length; i++) {
                        var childNode = children[i];
                        if (childNode.name === nodeName || childNode.uuid === nodeName) {
                            return childNode;
                        }
                        var result = searchNodeSubtree(childNode.children);
                        if (result)
                            return result;
                    }
                    return null;
                };
                var subTreeNode = searchNodeSubtree(root.children);
                if (subTreeNode) {
                    return subTreeNode;
                }
            }
            return null;
        };
        ;
        return PropertyBinding;
    }());
    THREE.PropertyBinding = PropertyBinding;
    PropertyBinding.prototype._getValue_unbound = PropertyBinding.prototype.getValue;
    PropertyBinding.prototype._setValue_unbound = PropertyBinding.prototype.setValue;
    var PropertyBindingComposite = (function () {
        function PropertyBindingComposite(targetGroup, path, optionalParsedPath) {
            var parsedPath = optionalParsedPath ||
                PropertyBinding.parseTrackName(path);
            this._targetGroup = targetGroup;
            this._bindings = targetGroup.subscribe_(path, parsedPath);
        }
        ;
        PropertyBindingComposite.prototype.getValue = function (array, offset) {
            this.bind();
            var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
            if (binding !== undefined)
                binding.getValue(array, offset);
        };
        PropertyBindingComposite.prototype.setValue = function (array, offset) {
            var bindings = this._bindings;
            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].setValue(array, offset);
            }
        };
        PropertyBindingComposite.prototype.bind = function () {
            var bindings = this._bindings;
            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].bind();
            }
        };
        PropertyBindingComposite.prototype.unbind = function () {
            var bindings = this._bindings;
            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].unbind();
            }
        };
        return PropertyBindingComposite;
    }());
    THREE.PropertyBindingComposite = PropertyBindingComposite;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var PropertyMixer = (function () {
        function PropertyMixer(binding, typeName, valueSize) {
            this.binding = binding;
            this.valueSize = valueSize;
            var bufferType = Float64Array;
            var mixFunction;
            switch (typeName) {
                case 'quaternion':
                    mixFunction = this._slerp;
                    break;
                case 'string':
                case 'bool':
                    bufferType = Array;
                    mixFunction = this._select;
                    break;
                default: mixFunction = this._lerp;
            }
            this.buffer = new bufferType(valueSize * 4);
            this._mixBufferRegion = mixFunction;
            this.cumulativeWeight = 0;
            this.useCount = 0;
            this.referenceCount = 0;
        }
        ;
        PropertyMixer.prototype.accumulate = function (accuIndex, weight) {
            var buffer = this.buffer;
            var stride = this.valueSize;
            var offset = accuIndex * stride + stride;
            var currentWeight = this.cumulativeWeight;
            if (currentWeight === 0) {
                for (var i = 0; i !== stride; ++i) {
                    buffer[offset + i] = buffer[i];
                }
                currentWeight = weight;
            }
            else {
                currentWeight += weight;
                var mix = weight / currentWeight;
                this._mixBufferRegion(buffer, offset, 0, mix, stride);
            }
            this.cumulativeWeight = currentWeight;
        };
        PropertyMixer.prototype.apply = function (accuIndex) {
            var stride = this.valueSize;
            var buffer = this.buffer;
            var offset = accuIndex * stride + stride;
            var weight = this.cumulativeWeight;
            var binding = this.binding;
            this.cumulativeWeight = 0;
            if (weight < 1) {
                var originalValueOffset = stride * 3;
                this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
            }
            for (var i = stride, e = stride + stride; i !== e; ++i) {
                if (buffer[i] !== buffer[i + stride]) {
                    binding.setValue(buffer, offset);
                    break;
                }
            }
        };
        PropertyMixer.prototype.saveOriginalState = function () {
            var binding = this.binding;
            var buffer = this.buffer;
            var stride = this.valueSize;
            var originalValueOffset = stride * 3;
            binding.getValue(buffer, originalValueOffset);
            for (var i = stride, e = originalValueOffset; i !== e; ++i) {
                buffer[i] = buffer[originalValueOffset + (i % stride)];
            }
            this.cumulativeWeight = 0;
        };
        PropertyMixer.prototype.restoreOriginalState = function () {
            var originalValueOffset = this.valueSize * 3;
            this.binding.setValue(this.buffer, originalValueOffset);
        };
        PropertyMixer.prototype._select = function (buffer, dstOffset, srcOffset, t, stride) {
            if (t >= 0.5) {
                for (var i = 0; i !== stride; ++i) {
                    buffer[dstOffset + i] = buffer[srcOffset + i];
                }
            }
        };
        PropertyMixer.prototype._slerp = function (buffer, dstOffset, srcOffset, t, stride) {
            THREE.Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
        };
        PropertyMixer.prototype._lerp = function (buffer, dstOffset, srcOffset, t, stride) {
            var s = 1 - t;
            for (var i = 0; i !== stride; ++i) {
                var j = dstOffset + i;
                buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
            }
        };
        return PropertyMixer;
    }());
    THREE.PropertyMixer = PropertyMixer;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var BooleanKeyframeTrack = (function (_super) {
        __extends(BooleanKeyframeTrack, _super);
        function BooleanKeyframeTrack(name, times, values) {
            _super.call(this, name, times, values);
        }
        ;
        return BooleanKeyframeTrack;
    }(THREE.KeyframeTrack));
    THREE.BooleanKeyframeTrack = BooleanKeyframeTrack;
    BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
    BooleanKeyframeTrack.prototype.ValueBufferType = Array;
    BooleanKeyframeTrack.prototype.DefaultInterpolation = THREE.InterpolateDiscrete;
    BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
    BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var ColorKeyframeTrack = (function (_super) {
        __extends(ColorKeyframeTrack, _super);
        function ColorKeyframeTrack(name, times, values, interpolation) {
            _super.call(this, name, times, values, interpolation);
        }
        ;
        return ColorKeyframeTrack;
    }(THREE.KeyframeTrack));
    THREE.ColorKeyframeTrack = ColorKeyframeTrack;
    ColorKeyframeTrack.prototype.ValueTypeName = 'color';
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var NumberKeyframeTrack = (function (_super) {
        __extends(NumberKeyframeTrack, _super);
        function NumberKeyframeTrack(name, times, values, interpolation) {
            _super.call(this, name, times, values, interpolation);
        }
        ;
        return NumberKeyframeTrack;
    }(THREE.KeyframeTrack));
    THREE.NumberKeyframeTrack = NumberKeyframeTrack;
    NumberKeyframeTrack.prototype.ValueTypeName = 'number';
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var QuaternionKeyframeTrack = (function (_super) {
        __extends(QuaternionKeyframeTrack, _super);
        function QuaternionKeyframeTrack(name, times, values, interpolation) {
            _super.call(this, name, times, values, interpolation);
        }
        ;
        QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodLinear = function (result) {
            return new THREE.QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
        };
        return QuaternionKeyframeTrack;
    }(THREE.KeyframeTrack));
    THREE.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
    QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
    QuaternionKeyframeTrack.prototype.DefaultInterpolation = THREE.InterpolateLinear;
    QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var StringKeyframeTrack = (function (_super) {
        __extends(StringKeyframeTrack, _super);
        function StringKeyframeTrack(name, times, values, interpolation) {
            _super.call(this, name, times, values, interpolation);
        }
        ;
        return StringKeyframeTrack;
    }(THREE.KeyframeTrack));
    THREE.StringKeyframeTrack = StringKeyframeTrack;
    StringKeyframeTrack.prototype.ValueTypeName = 'string';
    StringKeyframeTrack.prototype.ValueBufferType = Array;
    StringKeyframeTrack.prototype.DefaultInterpolation = THREE.InterpolateDiscrete;
    StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
    StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var VectorKeyframeTrack = (function (_super) {
        __extends(VectorKeyframeTrack, _super);
        function VectorKeyframeTrack(name, times, values, interpolation) {
            _super.call(this, name, times, values, interpolation);
        }
        return VectorKeyframeTrack;
    }(THREE.KeyframeTrack));
    THREE.VectorKeyframeTrack = VectorKeyframeTrack;
    VectorKeyframeTrack.prototype.ValueTypeName = 'vector';
})(THREE || (THREE = {}));
if (typeof define === 'function' && define.amd) {
    define('three', THREE);
}
else if ('undefined' !== typeof exports && 'undefined' !== typeof module) {
    module.exports = THREE;
}
if (Number.EPSILON === undefined) {
    Number.EPSILON = Math.pow(2, -52);
}
if (Math.sign === undefined) {
    Math.sign = function (x) {
        return (x < 0) ? -1 : (x > 0) ? 1 : +x;
    };
}
if (Function.prototype.name === undefined) {
    Object.defineProperty(Function.prototype, 'name', {
        get: function () {
            return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
        }
    });
}
if (Object.assign === undefined) {
    (function () {
        Object.assign = function (target) {
            'use strict';
            if (target === undefined || target === null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }
            var output = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (source !== undefined && source !== null) {
                    for (var nextKey in source) {
                        if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
                            output[nextKey] = source[nextKey];
                        }
                    }
                }
            }
            return output;
        };
    })();
}
var THREE;
(function (THREE) {
    THREE.REVISION = '79';
    THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
    THREE.CullFaceNone = 0;
    THREE.CullFaceBack = 1;
    THREE.CullFaceFront = 2;
    THREE.CullFaceFrontBack = 3;
    THREE.FrontFaceDirectionCW = 0;
    THREE.FrontFaceDirectionCCW = 1;
    THREE.BasicShadowMap = 0;
    THREE.PCFShadowMap = 1;
    THREE.PCFSoftShadowMap = 2;
    THREE.FrontSide = 0;
    THREE.BackSide = 1;
    THREE.DoubleSide = 2;
    THREE.FlatShading = 1;
    THREE.SmoothShading = 2;
    THREE.NoColors = 0;
    THREE.FaceColors = 1;
    THREE.VertexColors = 2;
    THREE.NoBlending = 0;
    THREE.NormalBlending = 1;
    THREE.AdditiveBlending = 2;
    THREE.SubtractiveBlending = 3;
    THREE.MultiplyBlending = 4;
    THREE.CustomBlending = 5;
    THREE.AddEquation = 100;
    THREE.SubtractEquation = 101;
    THREE.ReverseSubtractEquation = 102;
    THREE.MinEquation = 103;
    THREE.MaxEquation = 104;
    THREE.ZeroFactor = 200;
    THREE.OneFactor = 201;
    THREE.SrcColorFactor = 202;
    THREE.OneMinusSrcColorFactor = 203;
    THREE.SrcAlphaFactor = 204;
    THREE.OneMinusSrcAlphaFactor = 205;
    THREE.DstAlphaFactor = 206;
    THREE.OneMinusDstAlphaFactor = 207;
    THREE.DstColorFactor = 208;
    THREE.OneMinusDstColorFactor = 209;
    THREE.SrcAlphaSaturateFactor = 210;
    THREE.NeverDepth = 0;
    THREE.AlwaysDepth = 1;
    THREE.LessDepth = 2;
    THREE.LessEqualDepth = 3;
    THREE.EqualDepth = 4;
    THREE.GreaterEqualDepth = 5;
    THREE.GreaterDepth = 6;
    THREE.NotEqualDepth = 7;
    THREE.MultiplyOperation = 0;
    THREE.MixOperation = 1;
    THREE.AddOperation = 2;
    THREE.NoToneMapping = 0;
    THREE.LinearToneMapping = 1;
    THREE.ReinhardToneMapping = 2;
    THREE.Uncharted2ToneMapping = 3;
    THREE.CineonToneMapping = 4;
    (function (ToneMappingModes) {
        ToneMappingModes[ToneMappingModes["NoToneMapping"] = 0] = "NoToneMapping";
        ToneMappingModes[ToneMappingModes["LinearToneMapping"] = 1] = "LinearToneMapping";
        ToneMappingModes[ToneMappingModes["ReinhardToneMapping"] = 2] = "ReinhardToneMapping";
        ToneMappingModes[ToneMappingModes["Uncharted2ToneMapping"] = 3] = "Uncharted2ToneMapping";
        ToneMappingModes[ToneMappingModes["CineonToneMapping"] = 4] = "CineonToneMapping";
    })(THREE.ToneMappingModes || (THREE.ToneMappingModes = {}));
    var ToneMappingModes = THREE.ToneMappingModes;
    THREE.UVMapping = 300;
    THREE.CubeReflectionMapping = 301;
    THREE.CubeRefractionMapping = 302;
    THREE.EquirectangularReflectionMapping = 303;
    THREE.EquirectangularRefractionMapping = 304;
    THREE.SphericalReflectionMapping = 305;
    THREE.CubeUVReflectionMapping = 306;
    THREE.CubeUVRefractionMapping = 307;
    THREE.RepeatWrapping = 1000;
    THREE.ClampToEdgeWrapping = 1001;
    THREE.MirroredRepeatWrapping = 1002;
    THREE.NearestFilter = 1003;
    THREE.NearestMipMapNearestFilter = 1004;
    THREE.NearestMipMapLinearFilter = 1005;
    THREE.LinearFilter = 1006;
    THREE.LinearMipMapNearestFilter = 1007;
    THREE.LinearMipMapLinearFilter = 1008;
    THREE.UnsignedByteType = 1009;
    THREE.ByteType = 1010;
    THREE.ShortType = 1011;
    THREE.UnsignedShortType = 1012;
    THREE.IntType = 1013;
    THREE.UnsignedIntType = 1014;
    THREE.FloatType = 1015;
    THREE.HalfFloatType = 1025;
    THREE.UnsignedShort4444Type = 1016;
    THREE.UnsignedShort5551Type = 1017;
    THREE.UnsignedShort565Type = 1018;
    THREE.AlphaFormat = 1019;
    THREE.RGBFormat = 1020;
    THREE.RGBAFormat = 1021;
    THREE.LuminanceFormat = 1022;
    THREE.LuminanceAlphaFormat = 1023;
    THREE.RGBEFormat = THREE.RGBAFormat;
    THREE.DepthFormat = 1026;
    THREE.RGB_S3TC_DXT1_Format = 2001;
    THREE.RGBA_S3TC_DXT1_Format = 2002;
    THREE.RGBA_S3TC_DXT3_Format = 2003;
    THREE.RGBA_S3TC_DXT5_Format = 2004;
    THREE.RGB_PVRTC_4BPPV1_Format = 2100;
    THREE.RGB_PVRTC_2BPPV1_Format = 2101;
    THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
    THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
    THREE.RGB_ETC1_Format = 2151;
    THREE.LoopOnce = 2200;
    THREE.LoopRepeat = 2201;
    THREE.LoopPingPong = 2202;
    THREE.InterpolateDiscrete = 2300;
    THREE.InterpolateLinear = 2301;
    THREE.InterpolateSmooth = 2302;
    THREE.ZeroCurvatureEnding = 2400;
    THREE.ZeroSlopeEnding = 2401;
    THREE.WrapAroundEnding = 2402;
    THREE.TrianglesDrawMode = 0;
    THREE.TriangleStripDrawMode = 1;
    THREE.TriangleFanDrawMode = 2;
    THREE.LinearEncoding = 3000;
    THREE.sRGBEncoding = 3001;
    THREE.GammaEncoding = 3007;
    THREE.RGBEEncoding = 3002;
    THREE.LogLuvEncoding = 3003;
    THREE.RGBM7Encoding = 3004;
    THREE.RGBM16Encoding = 3005;
    THREE.RGBDEncoding = 3006;
    THREE.BasicDepthPacking = 3200;
    THREE.RGBADepthPacking = 3201;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Matrix3 = (function () {
        function Matrix3() {
            this.elements = new Float32Array([
                1, 0, 0,
                0, 1, 0,
                0, 0, 1
            ]);
        }
        Matrix3.prototype.set = function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            var te = this.elements;
            te[0] = n11;
            te[1] = n21;
            te[2] = n31;
            te[3] = n12;
            te[4] = n22;
            te[5] = n32;
            te[6] = n13;
            te[7] = n23;
            te[8] = n33;
            return this;
        };
        Matrix3.prototype.identity = function () {
            this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
            return this;
        };
        Matrix3.prototype.clone = function () {
            return new Matrix3().fromArray(this.elements);
        };
        Matrix3.prototype.copy = function (m) {
            var me = m.elements;
            this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
            return this;
        };
        Matrix3.prototype.setFromMatrix4 = function (m) {
            var me = m.elements;
            this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
            return this;
        };
        Matrix3.prototype.applyToVector3Array = function (array, offset, length) {
            if (offset === void 0) { offset = 0; }
            if (length === void 0) { length = array.length; }
            var v1 = new THREE.Vector3();
            var func = Matrix3.prototype.applyToVector3Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = array.length; }
                for (var i = 0, j = offset; i < length; i += 3, j += 3) {
                    v1.fromArray(array, j);
                    v1.applyMatrix3(this);
                    v1.toArray(array, j);
                }
                return array;
            };
            return func.apply(this, arguments);
        };
        Matrix3.prototype.applyToBuffer = function (buffer, offset, length) {
            var v1 = Matrix3[".applyToBuffer."] || (Matrix3[".applyToBuffer."] = new THREE.Vector3());
            if (offset === undefined)
                offset = 0;
            if (length === undefined)
                length = buffer.length / buffer.itemSize;
            for (var i = 0, j = offset; i < length; i++, j++) {
                v1.x = buffer.getX(j);
                v1.y = buffer.getY(j);
                v1.z = buffer.getZ(j);
                v1.applyMatrix3(this);
                buffer.setXYZ(v1.x, v1.y, v1.z);
            }
            return buffer;
        };
        Matrix3.prototype.multiplyScalar = function (s) {
            var te = this.elements;
            te[0] *= s;
            te[3] *= s;
            te[6] *= s;
            te[1] *= s;
            te[4] *= s;
            te[7] *= s;
            te[2] *= s;
            te[5] *= s;
            te[8] *= s;
            return this;
        };
        Matrix3.prototype.determinant = function () {
            var te = this.elements;
            var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
            return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
        };
        Matrix3.prototype.getInverse = function (matrix, throwOnDegenerate) {
            if (throwOnDegenerate === void 0) { throwOnDegenerate = false; }
            var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
            if (det === 0) {
                var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
                if (throwOnDegenerate || false) {
                    throw new Error(msg);
                }
                else {
                    console.warn(msg);
                }
                return this.identity();
            }
            var detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n31 * n23 - n33 * n21) * detInv;
            te[2] = (n32 * n21 - n31 * n22) * detInv;
            te[3] = t12 * detInv;
            te[4] = (n33 * n11 - n31 * n13) * detInv;
            te[5] = (n31 * n12 - n32 * n11) * detInv;
            te[6] = t13 * detInv;
            te[7] = (n21 * n13 - n23 * n11) * detInv;
            te[8] = (n22 * n11 - n21 * n12) * detInv;
            return this;
        };
        Matrix3.prototype.transpose = function () {
            var tmp, m = this.elements;
            tmp = m[1];
            m[1] = m[3];
            m[3] = tmp;
            tmp = m[2];
            m[2] = m[6];
            m[6] = tmp;
            tmp = m[5];
            m[5] = m[7];
            m[7] = tmp;
            return this;
        };
        Matrix3.prototype.getNormalMatrix = function (matrix4) {
            return this.setFromMatrix4(matrix4).getInverse(this).transpose();
        };
        Matrix3.prototype.transposeIntoArray = function (r) {
            var m = this.elements;
            r[0] = m[0];
            r[1] = m[3];
            r[2] = m[6];
            r[3] = m[1];
            r[4] = m[4];
            r[5] = m[7];
            r[6] = m[2];
            r[7] = m[5];
            r[8] = m[8];
            return this;
        };
        Matrix3.prototype.fromArray = function (array) {
            this.elements.set(array);
            return this;
        };
        Matrix3.prototype.toArray = function (array, offset) {
            if (array === void 0) { array = []; }
            if (offset === void 0) { offset = 0; }
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            var te = this.elements;
            array[offset] = te[0];
            array[offset + 1] = te[1];
            array[offset + 2] = te[2];
            array[offset + 3] = te[3];
            array[offset + 4] = te[4];
            array[offset + 5] = te[5];
            array[offset + 6] = te[6];
            array[offset + 7] = te[7];
            array[offset + 8] = te[8];
            return array;
        };
        return Matrix3;
    }());
    THREE.Matrix3 = Matrix3;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Matrix4 = (function () {
        function Matrix4() {
            this.elements = new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1]);
        }
        Matrix4.prototype.set = function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            var te = this.elements;
            te[0] = n11;
            te[4] = n12;
            te[8] = n13;
            te[12] = n14;
            te[1] = n21;
            te[5] = n22;
            te[9] = n23;
            te[13] = n24;
            te[2] = n31;
            te[6] = n32;
            te[10] = n33;
            te[14] = n34;
            te[3] = n41;
            te[7] = n42;
            te[11] = n43;
            te[15] = n44;
            return this;
        };
        Matrix4.prototype.identity = function () {
            this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        };
        Matrix4.prototype.clone = function () {
            return new Matrix4().fromArray(this.elements);
        };
        Matrix4.prototype.copy = function (m) {
            this.elements.set(m.elements);
            return this;
        };
        Matrix4.prototype.copyPosition = function (m) {
            var te = this.elements;
            var me = m.elements;
            te[12] = me[12];
            te[13] = me[13];
            te[14] = me[14];
            return this;
        };
        Matrix4.prototype.extractBasis = function (xAxis, yAxis, zAxis) {
            xAxis.setFromMatrixColumn(this, 0);
            yAxis.setFromMatrixColumn(this, 1);
            zAxis.setFromMatrixColumn(this, 2);
            return this;
        };
        Matrix4.prototype.makeBasis = function (xAxis, yAxis, zAxis) {
            this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
            return this;
        };
        Matrix4.prototype.extractRotation = function (m) {
            var v1 = new THREE.Vector3();
            var func = Matrix4.prototype.extractRotation = function (m) {
                var te = this.elements;
                var me = m.elements;
                var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
                var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
                var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
                te[0] = me[0] * scaleX;
                te[1] = me[1] * scaleX;
                te[2] = me[2] * scaleX;
                te[4] = me[4] * scaleY;
                te[5] = me[5] * scaleY;
                te[6] = me[6] * scaleY;
                te[8] = me[8] * scaleZ;
                te[9] = me[9] * scaleZ;
                te[10] = me[10] * scaleZ;
                return this;
            };
            return func.apply(this, arguments);
        };
        Matrix4.prototype.makeRotationFromEuler = function (euler) {
            if (euler instanceof THREE.Euler === false) {
                console.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
            }
            var te = this.elements;
            var x = euler.x, y = euler.y, z = euler.z;
            var a = THREE.Math.cos(x), b = THREE.Math.sin(x);
            var c = THREE.Math.cos(y), d = THREE.Math.sin(y);
            var e = THREE.Math.cos(z), f = THREE.Math.sin(z);
            if (euler.order === 'XYZ') {
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e;
                te[4] = -c * f;
                te[8] = d;
                te[1] = af + be * d;
                te[5] = ae - bf * d;
                te[9] = -b * c;
                te[2] = bf - ae * d;
                te[6] = be + af * d;
                te[10] = a * c;
            }
            else if (euler.order === 'YXZ') {
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce + df * b;
                te[4] = de * b - cf;
                te[8] = a * d;
                te[1] = a * f;
                te[5] = a * e;
                te[9] = -b;
                te[2] = cf * b - de;
                te[6] = df + ce * b;
                te[10] = a * c;
            }
            else if (euler.order === 'ZXY') {
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce - df * b;
                te[4] = -a * f;
                te[8] = de + cf * b;
                te[1] = cf + de * b;
                te[5] = a * e;
                te[9] = df - ce * b;
                te[2] = -a * d;
                te[6] = b;
                te[10] = a * c;
            }
            else if (euler.order === 'ZYX') {
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e;
                te[4] = be * d - af;
                te[8] = ae * d + bf;
                te[1] = c * f;
                te[5] = bf * d + ae;
                te[9] = af * d - be;
                te[2] = -d;
                te[6] = b * c;
                te[10] = a * c;
            }
            else if (euler.order === 'YZX') {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e;
                te[4] = bd - ac * f;
                te[8] = bc * f + ad;
                te[1] = f;
                te[5] = a * e;
                te[9] = -b * e;
                te[2] = -d * e;
                te[6] = ad * f + bc;
                te[10] = ac - bd * f;
            }
            else if (euler.order === 'XZY') {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e;
                te[4] = -f;
                te[8] = d * e;
                te[1] = ac * f + bd;
                te[5] = a * e;
                te[9] = ad * f - bc;
                te[2] = bc * f - ad;
                te[6] = b * e;
                te[10] = bd * f + ac;
            }
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;
            return this;
        };
        Matrix4.prototype.makeRotationFromQuaternion = function (q) {
            var te = this.elements;
            var x = q.x, y = q.y, z = q.z, w = q.w;
            var x2 = x + x, y2 = y + y, z2 = z + z;
            var xx = x * x2, xy = x * y2, xz = x * z2;
            var yy = y * y2, yz = y * z2, zz = z * z2;
            var wx = w * x2, wy = w * y2, wz = w * z2;
            te[0] = 1 - (yy + zz);
            te[4] = xy - wz;
            te[8] = xz + wy;
            te[1] = xy + wz;
            te[5] = 1 - (xx + zz);
            te[9] = yz - wx;
            te[2] = xz - wy;
            te[6] = yz + wx;
            te[10] = 1 - (xx + yy);
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;
            return this;
        };
        Matrix4.prototype.lookAt = function (eye, target, up) {
            var x = new THREE.Vector3();
            var y = new THREE.Vector3();
            var z = new THREE.Vector3();
            var func = Matrix4.prototype.lookAt = function (eye, target, up) {
                var te = this.elements;
                z.subVectors(eye, target).normalize();
                if (z.lengthSq() === 0) {
                    z.z = 1;
                }
                x.crossVectors(up, z).normalize();
                if (x.lengthSq() === 0) {
                    z.z += 0.0001;
                    x.crossVectors(up, z).normalize();
                }
                y.crossVectors(z, x);
                te[0] = x.x;
                te[4] = y.x;
                te[8] = z.x;
                te[1] = x.y;
                te[5] = y.y;
                te[9] = z.y;
                te[2] = x.z;
                te[6] = y.z;
                te[10] = z.z;
                return this;
            };
            return func.apply(this, arguments);
        };
        Matrix4.prototype.multiply = function (m) {
            return this.multiplyMatrices(this, m);
        };
        Matrix4.prototype.premultiply = function (m) {
            return this.multiplyMatrices(m, this);
        };
        Matrix4.prototype.multiplyMatrices = function (a, b) {
            var ae = a.elements;
            var be = b.elements;
            var te = this.elements;
            var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
            var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
            var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
            var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
            var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
            var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
            var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
            var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
            te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
            te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
            te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
            te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
            return this;
        };
        Matrix4.prototype.multiplyToArray = function (a, b, r) {
            var te = this.elements;
            this.multiplyMatrices(a, b);
            r[0] = te[0];
            r[1] = te[1];
            r[2] = te[2];
            r[3] = te[3];
            r[4] = te[4];
            r[5] = te[5];
            r[6] = te[6];
            r[7] = te[7];
            r[8] = te[8];
            r[9] = te[9];
            r[10] = te[10];
            r[11] = te[11];
            r[12] = te[12];
            r[13] = te[13];
            r[14] = te[14];
            r[15] = te[15];
            return this;
        };
        Matrix4.prototype.multiplyScalar = function (s) {
            var te = this.elements;
            te[0] *= s;
            te[4] *= s;
            te[8] *= s;
            te[12] *= s;
            te[1] *= s;
            te[5] *= s;
            te[9] *= s;
            te[13] *= s;
            te[2] *= s;
            te[6] *= s;
            te[10] *= s;
            te[14] *= s;
            te[3] *= s;
            te[7] *= s;
            te[11] *= s;
            te[15] *= s;
            return this;
        };
        Matrix4.prototype.applyToVector3Array = function (array, offset, length) {
            var v1 = new THREE.Vector3();
            var func = Matrix4.prototype.applyToVector3Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = array.length; }
                for (var i = 0, j = offset; i < length; i += 3, j += 3) {
                    v1.fromArray(array, j);
                    v1.applyMatrix4(this);
                    v1.toArray(array, j);
                }
                return array;
            };
            return func.apply(this, arguments);
        };
        Matrix4.prototype.applyToBuffer = function (buffer, offset, length) {
            var v1 = new THREE.Vector3();
            var func = Matrix4.prototype.applyToBuffer = function (buffer, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = buffer.length / buffer.itemSize; }
                for (var i = 0, j = offset; i < length; i++, j++) {
                    v1.x = buffer.getX(j);
                    v1.y = buffer.getY(j);
                    v1.z = buffer.getZ(j);
                    v1.applyMatrix4(this);
                    buffer.setXYZ(v1.x, v1.y, v1.z);
                }
                return buffer;
            };
            return func.apply(this, arguments);
        };
        Matrix4.prototype.determinant = function () {
            var te = this.elements;
            var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
            var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
            var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
            var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
            return (n41 * (+n14 * n23 * n32
                - n13 * n24 * n32
                - n14 * n22 * n33
                + n12 * n24 * n33
                + n13 * n22 * n34
                - n12 * n23 * n34) +
                n42 * (+n11 * n23 * n34
                    - n11 * n24 * n33
                    + n14 * n21 * n33
                    - n13 * n21 * n34
                    + n13 * n24 * n31
                    - n14 * n23 * n31) +
                n43 * (+n11 * n24 * n32
                    - n11 * n22 * n34
                    - n14 * n21 * n32
                    + n12 * n21 * n34
                    + n14 * n22 * n31
                    - n12 * n24 * n31) +
                n44 * (-n13 * n22 * n31
                    - n11 * n23 * n32
                    + n11 * n22 * n33
                    + n13 * n21 * n32
                    - n12 * n21 * n33
                    + n12 * n23 * n31));
        };
        Matrix4.prototype.transpose = function () {
            var te = this.elements;
            var tmp;
            tmp = te[1];
            te[1] = te[4];
            te[4] = tmp;
            tmp = te[2];
            te[2] = te[8];
            te[8] = tmp;
            tmp = te[6];
            te[6] = te[9];
            te[9] = tmp;
            tmp = te[3];
            te[3] = te[12];
            te[12] = tmp;
            tmp = te[7];
            te[7] = te[13];
            te[13] = tmp;
            tmp = te[11];
            te[11] = te[14];
            te[14] = tmp;
            return this;
        };
        Matrix4.prototype.setPosition = function (v) {
            var te = this.elements;
            te[12] = v.x;
            te[13] = v.y;
            te[14] = v.z;
            return this;
        };
        Matrix4.prototype.getInverse = function (m, throwOnDegenerate) {
            var te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
            var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
            if (det === 0) {
                var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
                if (throwOnDegenerate || false) {
                    throw new Error(msg);
                }
                else {
                    console.warn(msg);
                }
                return this.identity();
            }
            var detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
            te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
            te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
            te[4] = t12 * detInv;
            te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
            te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
            te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
            te[8] = t13 * detInv;
            te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
            te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
            te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
            te[12] = t14 * detInv;
            te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
            te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
            te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
            return this;
        };
        Matrix4.prototype.scale = function (v) {
            var te = this.elements;
            var x = v.x, y = v.y, z = v.z;
            te[0] *= x;
            te[4] *= y;
            te[8] *= z;
            te[1] *= x;
            te[5] *= y;
            te[9] *= z;
            te[2] *= x;
            te[6] *= y;
            te[10] *= z;
            te[3] *= x;
            te[7] *= y;
            te[11] *= z;
            return this;
        };
        Matrix4.prototype.getMaxScaleOnAxis = function () {
            var te = this.elements;
            var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
            var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
            var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
            return THREE.Math.sqrt(THREE.Math.max(scaleXSq, scaleYSq, scaleZSq));
        };
        Matrix4.prototype.makeTranslation = function (x, y, z) {
            this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
            return this;
        };
        Matrix4.prototype.makeRotationX = function (theta) {
            var c = THREE.Math.cos(theta), s = THREE.Math.sin(theta);
            this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
            return this;
        };
        Matrix4.prototype.makeRotationY = function (theta) {
            var c = THREE.Math.cos(theta), s = THREE.Math.sin(theta);
            this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
            return this;
        };
        Matrix4.prototype.makeRotationZ = function (theta) {
            var c = THREE.Math.cos(theta), s = THREE.Math.sin(theta);
            this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        };
        Matrix4.prototype.makeRotationAxis = function (axis, angle) {
            var c = THREE.Math.cos(angle);
            var s = THREE.Math.sin(angle);
            var t = 1 - c;
            var x = axis.x, y = axis.y, z = axis.z;
            var tx = t * x, ty = t * y;
            this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
            return this;
        };
        Matrix4.prototype.makeScale = function (x, y, z) {
            this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
            return this;
        };
        Matrix4.prototype.compose = function (position, quaternion, scale) {
            this.makeRotationFromQuaternion(quaternion);
            this.scale(scale);
            this.setPosition(position);
            return this;
        };
        Matrix4.prototype.decompose = function (position, quaternion, scale) {
            var vector = new THREE.Vector3();
            var matrix = new Matrix4();
            var func = Matrix4.prototype.decompose
                = function (position, quaternion, scale) {
                    var te = this.elements;
                    var sx = vector.set(te[0], te[1], te[2]).length();
                    var sy = vector.set(te[4], te[5], te[6]).length();
                    var sz = vector.set(te[8], te[9], te[10]).length();
                    var det = this.determinant();
                    if (det < 0) {
                        sx = -sx;
                    }
                    position.x = te[12];
                    position.y = te[13];
                    position.z = te[14];
                    matrix.elements.set(this.elements);
                    var invSX = 1 / sx;
                    var invSY = 1 / sy;
                    var invSZ = 1 / sz;
                    matrix.elements[0] *= invSX;
                    matrix.elements[1] *= invSX;
                    matrix.elements[2] *= invSX;
                    matrix.elements[4] *= invSY;
                    matrix.elements[5] *= invSY;
                    matrix.elements[6] *= invSY;
                    matrix.elements[8] *= invSZ;
                    matrix.elements[9] *= invSZ;
                    matrix.elements[10] *= invSZ;
                    quaternion.setFromRotationMatrix(matrix);
                    scale.x = sx;
                    scale.y = sy;
                    scale.z = sz;
                    return this;
                };
            return func.apply(this, arguments);
        };
        Matrix4.prototype.makeFrustum = function (left, right, bottom, top, near, far) {
            var te = this.elements;
            var x = 2 * near / (right - left);
            var y = 2 * near / (top - bottom);
            var a = (right + left) / (right - left);
            var b = (top + bottom) / (top - bottom);
            var c = -(far + near) / (far - near);
            var d = -2 * far * near / (far - near);
            te[0] = x;
            te[4] = 0;
            te[8] = a;
            te[12] = 0;
            te[1] = 0;
            te[5] = y;
            te[9] = b;
            te[13] = 0;
            te[2] = 0;
            te[6] = 0;
            te[10] = c;
            te[14] = d;
            te[3] = 0;
            te[7] = 0;
            te[11] = -1;
            te[15] = 0;
            return this;
        };
        Matrix4.prototype.makePerspective = function (fov, aspect, near, far) {
            var ymax = near * THREE.Math.tan(THREE.Math.DEG2RAD * fov * 0.5);
            var ymin = -ymax;
            var xmin = ymin * aspect;
            var xmax = ymax * aspect;
            return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
        };
        Matrix4.prototype.makeOrthographic = function (left, right, top, bottom, near, far) {
            var te = this.elements;
            var w = 1.0 / (right - left);
            var h = 1.0 / (top - bottom);
            var p = 1.0 / (far - near);
            var x = (right + left) * w;
            var y = (top + bottom) * h;
            var z = (far + near) * p;
            te[0] = 2 * w;
            te[4] = 0;
            te[8] = 0;
            te[12] = -x;
            te[1] = 0;
            te[5] = 2 * h;
            te[9] = 0;
            te[13] = -y;
            te[2] = 0;
            te[6] = 0;
            te[10] = -2 * p;
            te[14] = -z;
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            te[15] = 1;
            return this;
        };
        Matrix4.prototype.equals = function (matrix) {
            var te = this.elements;
            var me = matrix.elements;
            for (var i = 0; i < 16; i++) {
                if (te[i] !== me[i])
                    return false;
            }
            return true;
        };
        Matrix4.prototype.fromArray = function (array) {
            this.elements.set(array);
            return this;
        };
        Matrix4.prototype.toArray = function (array, offset) {
            if (array === void 0) { array = []; }
            if (offset === void 0) { offset = 0; }
            var te = this.elements;
            array[offset] = te[0];
            array[offset + 1] = te[1];
            array[offset + 2] = te[2];
            array[offset + 3] = te[3];
            array[offset + 4] = te[4];
            array[offset + 5] = te[5];
            array[offset + 6] = te[6];
            array[offset + 7] = te[7];
            array[offset + 8] = te[8];
            array[offset + 9] = te[9];
            array[offset + 10] = te[10];
            array[offset + 11] = te[11];
            array[offset + 12] = te[12];
            array[offset + 13] = te[13];
            array[offset + 14] = te[14];
            array[offset + 15] = te[15];
            return array;
        };
        return Matrix4;
    }());
    THREE.Matrix4 = Matrix4;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Vector2 = (function () {
        function Vector2(x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            this.x = x;
            this.y = y;
        }
        ;
        Object.defineProperty(Vector2.prototype, "width", {
            get: function () {
                return this.x;
            },
            set: function (value) {
                this.x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector2.prototype, "height", {
            get: function () {
                return this.y;
            },
            set: function (value) {
                this.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Vector2.prototype.set = function (x, y) {
            this.x = x;
            this.y = y;
            return this;
        };
        Vector2.prototype.setScalar = function (scalar) {
            this.x = scalar;
            this.y = scalar;
            return this;
        };
        Vector2.prototype.setX = function (x) {
            this.x = x;
            return this;
        };
        Vector2.prototype.setY = function (y) {
            this.y = y;
            return this;
        };
        Vector2.prototype.setComponent = function (index, value) {
            switch (index) {
                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                default: throw new Error('index is out of range: ' + index);
            }
        };
        Vector2.prototype.getComponent = function (index) {
            switch (index) {
                case 0: return this.x;
                case 1: return this.y;
                default: throw new Error('index is out of range: ' + index);
            }
        };
        Vector2.prototype.clone = function () {
            return new Vector2(this.x, this.y);
        };
        Vector2.prototype.copy = function (v) {
            this.x = v.x;
            this.y = v.y;
            return this;
        };
        Vector2.prototype.add = function (v) {
            this.x += v.x;
            this.y += v.y;
            return this;
        };
        Vector2.prototype.addScalar = function (s) {
            this.x += s;
            this.y += s;
            return this;
        };
        Vector2.prototype.addVectors = function (a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            return this;
        };
        Vector2.prototype.addScaledVector = function (v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            return this;
        };
        Vector2.prototype.sub = function (v) {
            this.x -= v.x;
            this.y -= v.y;
            return this;
        };
        Vector2.prototype.subScalar = function (s) {
            this.x -= s;
            this.y -= s;
            return this;
        };
        Vector2.prototype.subVectors = function (a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            return this;
        };
        Vector2.prototype.multiply = function (v) {
            this.x *= v.x;
            this.y *= v.y;
            return this;
        };
        Vector2.prototype.multiplyScalar = function (scalar) {
            if (isFinite(scalar)) {
                this.x *= scalar;
                this.y *= scalar;
            }
            else {
                this.x = 0;
                this.y = 0;
            }
            return this;
        };
        Vector2.prototype.divide = function (v) {
            this.x /= v.x;
            this.y /= v.y;
            return this;
        };
        Vector2.prototype.divideScalar = function (scalar) {
            return this.multiplyScalar(1 / scalar);
        };
        Vector2.prototype.min = function (v) {
            this.x = THREE.Math.min(this.x, v.x);
            this.y = THREE.Math.min(this.y, v.y);
            return this;
        };
        Vector2.prototype.max = function (v) {
            this.x = THREE.Math.max(this.x, v.x);
            this.y = THREE.Math.max(this.y, v.y);
            return this;
        };
        Vector2.prototype.clamp = function (min, max) {
            this.x = THREE.Math.max(min.x, THREE.Math.min(max.x, this.x));
            this.y = THREE.Math.max(min.y, THREE.Math.min(max.y, this.y));
            return this;
        };
        Vector2.prototype.clampLength = function (min, max) {
            var length = this.length();
            return this.multiplyScalar(THREE.Math.max(min, THREE.Math.min(max, length)) / length);
        };
        Vector2.prototype.floor = function () {
            this.x = THREE.Math.floor(this.x);
            this.y = THREE.Math.floor(this.y);
            return this;
        };
        Vector2.prototype.ceil = function () {
            this.x = THREE.Math.ceil(this.x);
            this.y = THREE.Math.ceil(this.y);
            return this;
        };
        Vector2.prototype.round = function () {
            this.x = THREE.Math.round(this.x);
            this.y = THREE.Math.round(this.y);
            return this;
        };
        Vector2.prototype.roundToZero = function () {
            this.x = (this.x < 0) ? THREE.Math.ceil(this.x) : THREE.Math.floor(this.x);
            this.y = (this.y < 0) ? THREE.Math.ceil(this.y) : THREE.Math.floor(this.y);
            return this;
        };
        Vector2.prototype.negate = function () {
            this.x = -this.x;
            this.y = -this.y;
            return this;
        };
        Vector2.prototype.dot = function (v) {
            return this.x * v.x + this.y * v.y;
        };
        Vector2.prototype.lengthSq = function () {
            return this.x * this.x + this.y * this.y;
        };
        Vector2.prototype.length = function () {
            return THREE.Math.sqrt(this.x * this.x + this.y * this.y);
        };
        Vector2.prototype.lengthManhattan = function () {
            return THREE.Math.abs(this.x) + THREE.Math.abs(this.y);
        };
        Vector2.prototype.normalize = function () {
            return this.divideScalar(this.length());
        };
        Vector2.prototype.angle = function () {
            var angle = THREE.Math.atan2(this.y, this.x);
            if (angle < 0)
                angle += 2 * THREE.Math.PI;
            return angle;
        };
        Vector2.prototype.distanceTo = function (v) {
            return THREE.Math.sqrt(this.distanceToSquared(v));
        };
        Vector2.prototype.distanceToSquared = function (v) {
            var dx = this.x - v.x, dy = this.y - v.y;
            return dx * dx + dy * dy;
        };
        Vector2.prototype.distanceToManhattan = function (v) {
            return THREE.Math.abs(this.x - v.x) + THREE.Math.abs(this.y - v.y);
        };
        Vector2.prototype.setLength = function (length) {
            return this.multiplyScalar(length / this.length());
        };
        Vector2.prototype.lerp = function (v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            return this;
        };
        Vector2.prototype.lerpVectors = function (v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        };
        Vector2.prototype.equals = function (v) {
            return ((v.x === this.x) && (v.y === this.y));
        };
        Vector2.prototype.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            this.x = array[offset];
            this.y = array[offset + 1];
            return this;
        };
        Vector2.prototype.toArray = function (array, offset) {
            if (array === void 0) { array = []; }
            if (offset === void 0) { offset = 0; }
            array[offset] = this.x;
            array[offset + 1] = this.y;
            return array;
        };
        Vector2.prototype.fromAttribute = function (attribute, index, offset) {
            if (offset === void 0) { offset = 0; }
            index = index * attribute.itemSize + offset;
            this.x = attribute.array[index];
            this.y = attribute.array[index + 1];
            return this;
        };
        Vector2.prototype.rotateAround = function (center, angle) {
            var c = THREE.Math.cos(angle), s = THREE.Math.sin(angle);
            var x = this.x - center.x;
            var y = this.y - center.y;
            this.x = x * c - y * s + center.x;
            this.y = x * s + y * c + center.y;
            return this;
        };
        Vector2.prototype.clampScalar = function (minVal, maxVal) {
            this.x = THREE.Math.max(minVal, THREE.Math.min(maxVal, this.x));
            this.y = THREE.Math.max(minVal, THREE.Math.min(maxVal, this.y));
            return this;
        };
        return Vector2;
    }());
    THREE.Vector2 = Vector2;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Vector3 = (function () {
        function Vector3(x, y, z) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            this.x = x;
            this.y = y;
            this.z = z;
        }
        Vector3.prototype.set = function (x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        };
        Vector3.prototype.setScalar = function (scalar) {
            this.x = scalar;
            this.y = scalar;
            this.z = scalar;
            return this;
        };
        Vector3.prototype.setX = function (x) {
            this.x = x;
            return this;
        };
        Vector3.prototype.setY = function (y) {
            this.y = y;
            return this;
        };
        Vector3.prototype.setZ = function (z) {
            this.z = z;
            return this;
        };
        Vector3.prototype.setComponent = function (index, value) {
            switch (index) {
                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                case 2:
                    this.z = value;
                    break;
                default: throw new Error('index is out of range: ' + index);
            }
        };
        Vector3.prototype.getComponent = function (index) {
            switch (index) {
                case 0: return this.x;
                case 1: return this.y;
                case 2: return this.z;
                default: throw new Error('index is out of range: ' + index);
            }
        };
        Vector3.prototype.clone = function () {
            return new Vector3(this.x, this.y, this.z);
        };
        Vector3.prototype.copy = function (v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            return this;
        };
        Vector3.prototype.add = function (v) {
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            return this;
        };
        Vector3.prototype.addScalar = function (s) {
            this.x += s;
            this.y += s;
            this.z += s;
            return this;
        };
        Vector3.prototype.addVectors = function (a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            return this;
        };
        Vector3.prototype.addScaledVector = function (v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;
            return this;
        };
        Vector3.prototype.sub = function (v) {
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            return this;
        };
        Vector3.prototype.subScalar = function (s) {
            this.x -= s;
            this.y -= s;
            this.z -= s;
            return this;
        };
        Vector3.prototype.subVectors = function (a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            return this;
        };
        Vector3.prototype.multiply = function (v) {
            this.x *= v.x;
            this.y *= v.y;
            this.z *= v.z;
            return this;
        };
        Vector3.prototype.multiplyScalar = function (scalar) {
            if (isFinite(scalar)) {
                this.x *= scalar;
                this.y *= scalar;
                this.z *= scalar;
            }
            else {
                this.x = 0;
                this.y = 0;
                this.z = 0;
            }
            return this;
        };
        Vector3.prototype.multiplyVectors = function (a, b) {
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;
            return this;
        };
        Vector3.prototype.applyEuler = function (euler) {
            var quaternion = new THREE.Quaternion();
            var func = Vector3.prototype.applyEuler = function (euler) {
                this.applyQuaternion(quaternion.setFromEuler(euler));
                return this;
            };
            return func.apply(this, arguments);
        };
        Vector3.prototype.applyAxisAngle = function (axis, angle) {
            var quaternion = new THREE.Quaternion();
            var func = Vector3.prototype.applyAxisAngle = function (axis, angle) {
                this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
                return this;
            };
            return func.apply(this, arguments);
        };
        Vector3.prototype.applyMatrix3 = function (m) {
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
            this.x = e[0] * x + e[3] * y + e[6] * z;
            this.y = e[1] * x + e[4] * y + e[7] * z;
            this.z = e[2] * x + e[5] * y + e[8] * z;
            return this;
        };
        Vector3.prototype.applyMatrix4 = function (m) {
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
            this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
            return this;
        };
        Vector3.prototype.applyProjection = function (m) {
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
            var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
            this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
            this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
            this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;
            return this;
        };
        Vector3.prototype.applyQuaternion = function (q) {
            var x = this.x, y = this.y, z = this.z;
            var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
            var ix = qw * x + qy * z - qz * y;
            var iy = qw * y + qz * x - qx * z;
            var iz = qw * z + qx * y - qy * x;
            var iw = -qx * x - qy * y - qz * z;
            this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return this;
        };
        Vector3.prototype.project = function (camera) {
            var matrix = new THREE.Matrix4();
            var func = Vector3.prototype.project
                = function (camera) {
                    matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
                    this.applyProjection(matrix);
                    return this;
                };
            return func.apply(this, arguments);
        };
        Vector3.prototype.unproject = function (camera) {
            var matrix = new THREE.Matrix4();
            var func = Vector3.prototype.unproject
                = function (camera) {
                    matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
                    this.applyProjection(matrix);
                    return this;
                };
            return func.apply(this, arguments);
        };
        Vector3.prototype.transformDirection = function (m) {
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z;
            this.y = e[1] * x + e[5] * y + e[9] * z;
            this.z = e[2] * x + e[6] * y + e[10] * z;
            return this.normalize();
        };
        Vector3.prototype.divide = function (v) {
            this.x /= v.x;
            this.y /= v.y;
            this.z /= v.z;
            return this;
        };
        Vector3.prototype.divideScalar = function (scalar) {
            return this.multiplyScalar(1 / scalar);
        };
        Vector3.prototype.min = function (v) {
            this.x = THREE.Math.min(this.x, v.x);
            this.y = THREE.Math.min(this.y, v.y);
            this.z = THREE.Math.min(this.z, v.z);
            return this;
        };
        Vector3.prototype.max = function (v) {
            this.x = THREE.Math.max(this.x, v.x);
            this.y = THREE.Math.max(this.y, v.y);
            this.z = THREE.Math.max(this.z, v.z);
            return this;
        };
        Vector3.prototype.clamp = function (min, max) {
            this.x = THREE.Math.max(min.x, THREE.Math.min(max.x, this.x));
            this.y = THREE.Math.max(min.y, THREE.Math.min(max.y, this.y));
            this.z = THREE.Math.max(min.z, THREE.Math.min(max.z, this.z));
            return this;
        };
        Vector3.prototype.clampScalar = function (minVal, maxVal) {
            var min = new Vector3();
            var max = new Vector3();
            var func = Vector3.prototype.clampScalar
                = function (minVal, maxVal) {
                    min.set(minVal, minVal, minVal);
                    max.set(maxVal, maxVal, maxVal);
                    this.clamp(min, max);
                    return this;
                };
            return func.apply(this, arguments);
        };
        Vector3.prototype.clampLength = function (min, max) {
            var length = this.length();
            return this.multiplyScalar(THREE.Math.max(min, THREE.Math.min(max, length)) / length);
        };
        Vector3.prototype.floor = function () {
            this.x = THREE.Math.floor(this.x);
            this.y = THREE.Math.floor(this.y);
            this.z = THREE.Math.floor(this.z);
            return this;
        };
        Vector3.prototype.ceil = function () {
            this.x = THREE.Math.ceil(this.x);
            this.y = THREE.Math.ceil(this.y);
            this.z = THREE.Math.ceil(this.z);
            return this;
        };
        Vector3.prototype.round = function () {
            this.x = THREE.Math.round(this.x);
            this.y = THREE.Math.round(this.y);
            this.z = THREE.Math.round(this.z);
            return this;
        };
        Vector3.prototype.roundToZero = function () {
            this.x = (this.x < 0) ? THREE.Math.ceil(this.x) : THREE.Math.floor(this.x);
            this.y = (this.y < 0) ? THREE.Math.ceil(this.y) : THREE.Math.floor(this.y);
            this.z = (this.z < 0) ? THREE.Math.ceil(this.z) : THREE.Math.floor(this.z);
            return this;
        };
        Vector3.prototype.negate = function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
        };
        Vector3.prototype.dot = function (v) {
            return this.x * v.x + this.y * v.y + this.z * v.z;
        };
        Vector3.prototype.lengthSq = function () {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        };
        Vector3.prototype.length = function () {
            return THREE.Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        };
        Vector3.prototype.lengthManhattan = function () {
            return THREE.Math.abs(this.x) + THREE.Math.abs(this.y) + THREE.Math.abs(this.z);
        };
        Vector3.prototype.normalize = function () {
            return this.divideScalar(this.length());
        };
        Vector3.prototype.setLength = function (length) {
            return this.multiplyScalar(length / this.length());
        };
        Vector3.prototype.lerp = function (v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            return this;
        };
        Vector3.prototype.lerpVectors = function (v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        };
        Vector3.prototype.cross = function (v) {
            var x = this.x, y = this.y, z = this.z;
            this.x = y * v.z - z * v.y;
            this.y = z * v.x - x * v.z;
            this.z = x * v.y - y * v.x;
            return this;
        };
        Vector3.prototype.crossVectors = function (a, b) {
            var ax = a.x, ay = a.y, az = a.z;
            var bx = b.x, by = b.y, bz = b.z;
            this.x = ay * bz - az * by;
            this.y = az * bx - ax * bz;
            this.z = ax * by - ay * bx;
            return this;
        };
        Vector3.prototype.projectOnVector = function (vector) {
            var scalar = vector.dot(this) / vector.lengthSq();
            return this.copy(vector).multiplyScalar(scalar);
        };
        Vector3.prototype.projectOnPlane = function (planeNormal) {
            var v1 = new Vector3();
            var func = Vector3.prototype.projectOnPlane
                = function (planeNormal) {
                    v1.copy(this).projectOnVector(planeNormal);
                    this.sub(v1);
                    return this;
                };
            return func.apply(this, arguments);
        };
        Vector3.prototype.reflect = function (normal) {
            var v1 = new Vector3();
            var func = Vector3.prototype.reflect = function (normal) {
                this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
                return this;
            };
            return func.apply(this, arguments);
        };
        Vector3.prototype.angleTo = function (v) {
            var theta = this.dot(v) / (THREE.Math.sqrt(this.lengthSq() * v.lengthSq()));
            return THREE.Math.acos(THREE.Math.clamp(theta, -1, 1));
        };
        Vector3.prototype.distanceTo = function (v) {
            return THREE.Math.sqrt(this.distanceToSquared(v));
        };
        Vector3.prototype.distanceToSquared = function (v) {
            var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
            return dx * dx + dy * dy + dz * dz;
        };
        Vector3.prototype.distanceToManhattan = function (v) {
            return THREE.Math.abs(this.x - v.x) + THREE.Math.abs(this.y - v.y) + THREE.Math.abs(this.z - v.z);
        };
        Vector3.prototype.setFromSpherical = function (s) {
            var sinPhiRadius = THREE.Math.sin(s.phi) * s.radius;
            this.x = sinPhiRadius * THREE.Math.sin(s.theta);
            this.y = THREE.Math.cos(s.phi) * s.radius;
            this.z = sinPhiRadius * THREE.Math.cos(s.theta);
            return this;
        };
        Vector3.prototype.setFromMatrixPosition = function (m) {
            return this.setFromMatrixColumn(m, 3);
        };
        Vector3.prototype.setFromMatrixScale = function (m) {
            var sx = this.setFromMatrixColumn(m, 0).length();
            var sy = this.setFromMatrixColumn(m, 1).length();
            var sz = this.setFromMatrixColumn(m, 2).length();
            this.x = sx;
            this.y = sy;
            this.z = sz;
            return this;
        };
        Vector3.prototype.setFromMatrixColumn = function (m, index) {
            return this.fromArray(m.elements, index * 4);
        };
        Vector3.prototype.equals = function (v) {
            return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));
        };
        Vector3.prototype.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            return this;
        };
        Vector3.prototype.toArray = function (array, offset) {
            if (array === void 0) { array = []; }
            if (offset === void 0) { offset = 0; }
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            return array;
        };
        Vector3.prototype.fromAttribute = function (attribute, index, offset) {
            if (offset === void 0) { offset = 0; }
            index = index * attribute.itemSize + offset;
            this.x = attribute.array[index];
            this.y = attribute.array[index + 1];
            this.z = attribute.array[index + 2];
            return this;
        };
        return Vector3;
    }());
    THREE.Vector3 = Vector3;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Vector4 = (function () {
        function Vector4(x, y, z, w) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (w === void 0) { w = 1; }
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        ;
        Vector4.prototype.set = function (x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        };
        Vector4.prototype.setScalar = function (scalar) {
            this.x = scalar;
            this.y = scalar;
            this.z = scalar;
            this.w = scalar;
            return this;
        };
        Vector4.prototype.setX = function (x) {
            this.x = x;
            return this;
        };
        Vector4.prototype.setY = function (y) {
            this.y = y;
            return this;
        };
        Vector4.prototype.setZ = function (z) {
            this.z = z;
            return this;
        };
        Vector4.prototype.setW = function (w) {
            this.w = w;
            return this;
        };
        Vector4.prototype.setComponent = function (index, value) {
            switch (index) {
                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                case 2:
                    this.z = value;
                    break;
                case 3:
                    this.w = value;
                    break;
                default: throw new Error('index is out of range: ' + index);
            }
        };
        Vector4.prototype.getComponent = function (index) {
            switch (index) {
                case 0: return this.x;
                case 1: return this.y;
                case 2: return this.z;
                case 3: return this.w;
                default: throw new Error('index is out of range: ' + index);
            }
        };
        Vector4.prototype.clone = function () {
            return new Vector4(this.x, this.y, this.z, this.w);
        };
        Vector4.prototype.copy = function (v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            this.w = (v.w !== undefined) ? v.w : 1;
            return this;
        };
        Vector4.prototype.add = function (v) {
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            this.w += v.w;
            return this;
        };
        Vector4.prototype.addScalar = function (s) {
            this.x += s;
            this.y += s;
            this.z += s;
            this.w += s;
            return this;
        };
        Vector4.prototype.addVectors = function (a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            this.w = a.w + b.w;
            return this;
        };
        Vector4.prototype.addScaledVector = function (v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;
            this.w += v.w * s;
            return this;
        };
        Vector4.prototype.sub = function (v) {
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            this.w -= v.w;
            return this;
        };
        Vector4.prototype.subScalar = function (s) {
            this.x -= s;
            this.y -= s;
            this.z -= s;
            this.w -= s;
            return this;
        };
        Vector4.prototype.subVectors = function (a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            this.w = a.w - b.w;
            return this;
        };
        Vector4.prototype.multiplyScalar = function (scalar) {
            if (isFinite(scalar)) {
                this.x *= scalar;
                this.y *= scalar;
                this.z *= scalar;
                this.w *= scalar;
            }
            else {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.w = 0;
            }
            return this;
        };
        Vector4.prototype.applyMatrix4 = function (m) {
            var x = this.x, y = this.y, z = this.z, w = this.w;
            var e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
            this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
            this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
            return this;
        };
        Vector4.prototype.divideScalar = function (scalar) {
            return this.multiplyScalar(1 / scalar);
        };
        Vector4.prototype.setAxisAngleFromQuaternion = function (q) {
            this.w = 2 * THREE.Math.acos(q.w);
            var s = THREE.Math.sqrt(1 - q.w * q.w);
            if (s < 0.0001) {
                this.x = 1;
                this.y = 0;
                this.z = 0;
            }
            else {
                this.x = q.x / s;
                this.y = q.y / s;
                this.z = q.z / s;
            }
            return this;
        };
        Vector4.prototype.setAxisAngleFromRotationMatrix = function (m) {
            var angle, x, y, z, epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
            if ((THREE.Math.abs(m12 - m21) < epsilon) &&
                (THREE.Math.abs(m13 - m31) < epsilon) &&
                (THREE.Math.abs(m23 - m32) < epsilon)) {
                if ((THREE.Math.abs(m12 + m21) < epsilon2) &&
                    (THREE.Math.abs(m13 + m31) < epsilon2) &&
                    (THREE.Math.abs(m23 + m32) < epsilon2) &&
                    (THREE.Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {
                    this.set(1, 0, 0, 0);
                    return this;
                }
                angle = THREE.Math.PI;
                var xx = (m11 + 1) / 2;
                var yy = (m22 + 1) / 2;
                var zz = (m33 + 1) / 2;
                var xy = (m12 + m21) / 4;
                var xz = (m13 + m31) / 4;
                var yz = (m23 + m32) / 4;
                if ((xx > yy) && (xx > zz)) {
                    if (xx < epsilon) {
                        x = 0;
                        y = 0.707106781;
                        z = 0.707106781;
                    }
                    else {
                        x = THREE.Math.sqrt(xx);
                        y = xy / x;
                        z = xz / x;
                    }
                }
                else if (yy > zz) {
                    if (yy < epsilon) {
                        x = 0.707106781;
                        y = 0;
                        z = 0.707106781;
                    }
                    else {
                        y = THREE.Math.sqrt(yy);
                        x = xy / y;
                        z = yz / y;
                    }
                }
                else {
                    if (zz < epsilon) {
                        x = 0.707106781;
                        y = 0.707106781;
                        z = 0;
                    }
                    else {
                        z = THREE.Math.sqrt(zz);
                        x = xz / z;
                        y = yz / z;
                    }
                }
                this.set(x, y, z, angle);
                return this;
            }
            var s = THREE.Math.sqrt((m32 - m23) * (m32 - m23) +
                (m13 - m31) * (m13 - m31) +
                (m21 - m12) * (m21 - m12));
            if (THREE.Math.abs(s) < 0.001)
                s = 1;
            this.x = (m32 - m23) / s;
            this.y = (m13 - m31) / s;
            this.z = (m21 - m12) / s;
            this.w = THREE.Math.acos((m11 + m22 + m33 - 1) / 2);
            return this;
        };
        Vector4.prototype.min = function (v) {
            this.x = THREE.Math.min(this.x, v.x);
            this.y = THREE.Math.min(this.y, v.y);
            this.z = THREE.Math.min(this.z, v.z);
            this.w = THREE.Math.min(this.w, v.w);
            return this;
        };
        Vector4.prototype.max = function (v) {
            this.x = THREE.Math.max(this.x, v.x);
            this.y = THREE.Math.max(this.y, v.y);
            this.z = THREE.Math.max(this.z, v.z);
            this.w = THREE.Math.max(this.w, v.w);
            return this;
        };
        Vector4.prototype.clamp = function (min, max) {
            this.x = THREE.Math.max(min.x, THREE.Math.min(max.x, this.x));
            this.y = THREE.Math.max(min.y, THREE.Math.min(max.y, this.y));
            this.z = THREE.Math.max(min.z, THREE.Math.min(max.z, this.z));
            this.w = THREE.Math.max(min.w, THREE.Math.min(max.w, this.w));
            return this;
        };
        Vector4.prototype.clampScalar = function (minVal, maxVal) {
            var min = new Vector4();
            var max = new Vector4();
            var func = Vector4.prototype.clampScalar = function (minVal, maxVal) {
                min.set(minVal, minVal, minVal, minVal);
                max.set(maxVal, maxVal, maxVal, maxVal);
                return this.clamp(min, max);
            };
            return func.apply(this, arguments);
        };
        Vector4.prototype.floor = function () {
            this.x = THREE.Math.floor(this.x);
            this.y = THREE.Math.floor(this.y);
            this.z = THREE.Math.floor(this.z);
            this.w = THREE.Math.floor(this.w);
            return this;
        };
        Vector4.prototype.ceil = function () {
            this.x = THREE.Math.ceil(this.x);
            this.y = THREE.Math.ceil(this.y);
            this.z = THREE.Math.ceil(this.z);
            this.w = THREE.Math.ceil(this.w);
            return this;
        };
        Vector4.prototype.round = function () {
            this.x = THREE.Math.round(this.x);
            this.y = THREE.Math.round(this.y);
            this.z = THREE.Math.round(this.z);
            this.w = THREE.Math.round(this.w);
            return this;
        };
        Vector4.prototype.roundToZero = function () {
            this.x = (this.x < 0) ? THREE.Math.ceil(this.x) : THREE.Math.floor(this.x);
            this.y = (this.y < 0) ? THREE.Math.ceil(this.y) : THREE.Math.floor(this.y);
            this.z = (this.z < 0) ? THREE.Math.ceil(this.z) : THREE.Math.floor(this.z);
            this.w = (this.w < 0) ? THREE.Math.ceil(this.w) : THREE.Math.floor(this.w);
            return this;
        };
        Vector4.prototype.negate = function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            this.w = -this.w;
            return this;
        };
        Vector4.prototype.dot = function (v) {
            return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        };
        Vector4.prototype.lengthSq = function () {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        };
        Vector4.prototype.length = function () {
            return THREE.Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        };
        Vector4.prototype.lengthManhattan = function () {
            return THREE.Math.abs(this.x) + THREE.Math.abs(this.y) + THREE.Math.abs(this.z) + THREE.Math.abs(this.w);
        };
        Vector4.prototype.normalize = function () {
            return this.divideScalar(this.length());
        };
        Vector4.prototype.setLength = function (length) {
            return this.multiplyScalar(length / this.length());
        };
        Vector4.prototype.lerp = function (v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            this.w += (v.w - this.w) * alpha;
            return this;
        };
        Vector4.prototype.lerpVectors = function (v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        };
        Vector4.prototype.equals = function (v) {
            return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));
        };
        Vector4.prototype.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            this.w = array[offset + 3];
            return this;
        };
        Vector4.prototype.toArray = function (array, offset) {
            if (array === void 0) { array = []; }
            if (offset === void 0) { offset = 0; }
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            array[offset + 3] = this.w;
            return array;
        };
        Vector4.prototype.fromAttribute = function (attribute, index, offset) {
            if (offset === void 0) { offset = 0; }
            if (offset === undefined)
                offset = 0;
            index = index * attribute.itemSize + offset;
            this.x = attribute.array[index];
            this.y = attribute.array[index + 1];
            this.z = attribute.array[index + 2];
            this.w = attribute.array[index + 3];
            return this;
        };
        return Vector4;
    }());
    THREE.Vector4 = Vector4;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Color = (function () {
        function Color(r, g, b) {
            this.r = 1;
            this.g = 1;
            this.b = 1;
            if (g === undefined && b === undefined) {
                this.set(r);
            }
            else if (typeof r === 'number')
                this.setRGB(r, g, b);
        }
        Color.prototype.set = function (value) {
            if (value instanceof Color) {
                this.copy(value);
            }
            else if (typeof value === 'number') {
                this.setHex(value);
            }
            else if (typeof value === 'string') {
                this.setStyle(value);
            }
            return this;
        };
        Color.prototype.setScalar = function (scalar) {
            this.r = scalar;
            this.g = scalar;
            this.b = scalar;
        };
        Color.prototype.setHex = function (hex) {
            hex = THREE.Math.floor(hex);
            this.r = (hex >> 16 & 255) / 255;
            this.g = (hex >> 8 & 255) / 255;
            this.b = (hex & 255) / 255;
            return this;
        };
        Color.prototype.setRGB = function (r, g, b) {
            this.r = r;
            this.g = g;
            this.b = b;
            return this;
        };
        Color.hue2rgb = function (p, q, t) {
            if (t < 0)
                t += 1;
            if (t > 1)
                t -= 1;
            if (t < 1 / 6)
                return p + (q - p) * 6 * t;
            if (t < 1 / 2)
                return q;
            if (t < 2 / 3)
                return p + (q - p) * 6 * (2 / 3 - t);
            return p;
        };
        Color.prototype.setHSL = function (h, s, l) {
            h = THREE.Math.euclideanModulo(h, 1);
            s = THREE.Math.clamp(s, 0, 1);
            l = THREE.Math.clamp(l, 0, 1);
            if (s === 0) {
                this.r = this.g = this.b = l;
            }
            else {
                var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
                var q = (2 * l) - p;
                this.r = Color.hue2rgb(q, p, h + 1 / 3);
                this.g = Color.hue2rgb(q, p, h);
                this.b = Color.hue2rgb(q, p, h - 1 / 3);
            }
            return this;
        };
        Color.prototype.setStyle = function (style) {
            function handleAlpha(string) {
                if (string === undefined)
                    return;
                if (parseFloat(string) < 1) {
                    console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
                }
            }
            var m;
            if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
                var color;
                var name = m[1];
                var components = m[2];
                switch (name) {
                    case 'rgb':
                    case 'rgba':
                        if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                            this.r = THREE.Math.min(255, parseInt(color[1], 10)) / 255;
                            this.g = THREE.Math.min(255, parseInt(color[2], 10)) / 255;
                            this.b = THREE.Math.min(255, parseInt(color[3], 10)) / 255;
                            handleAlpha(color[5]);
                            return this;
                        }
                        if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                            this.r = THREE.Math.min(100, parseInt(color[1], 10)) / 100;
                            this.g = THREE.Math.min(100, parseInt(color[2], 10)) / 100;
                            this.b = THREE.Math.min(100, parseInt(color[3], 10)) / 100;
                            handleAlpha(color[5]);
                            return this;
                        }
                        break;
                    case 'hsl':
                    case 'hsla':
                        if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                            var h = parseFloat(color[1]) / 360;
                            var s = parseInt(color[2], 10) / 100;
                            var l = parseInt(color[3], 10) / 100;
                            handleAlpha(color[5]);
                            return this.setHSL(h, s, l);
                        }
                        break;
                }
            }
            else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
                var hex = m[1];
                var size = hex.length;
                if (size === 3) {
                    this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                    this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                    this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                    return this;
                }
                else if (size === 6) {
                    this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                    this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                    this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                    return this;
                }
            }
            if (style && style.length > 0) {
                var hex = THREE.ColorKeywords[style];
                if (hex !== undefined) {
                    this.setHex(hex);
                }
                else {
                    console.warn('THREE.Color: Unknown color ' + style);
                }
            }
            return this;
        };
        Color.prototype.clone = function () {
            return new Color(this.r, this.g, this.b);
        };
        Color.prototype.copy = function (color) {
            this.r = color.r;
            this.g = color.g;
            this.b = color.b;
            return this;
        };
        Color.prototype.copyGammaToLinear = function (color, gammaFactor) {
            if (gammaFactor === undefined)
                gammaFactor = 2.0;
            this.r = THREE.Math.pow(color.r, gammaFactor);
            this.g = THREE.Math.pow(color.g, gammaFactor);
            this.b = THREE.Math.pow(color.b, gammaFactor);
            return this;
        };
        Color.prototype.copyLinearToGamma = function (color, gammaFactor) {
            if (gammaFactor === undefined)
                gammaFactor = 2.0;
            var safeInverse = (gammaFactor > 0) ? (1.0 / gammaFactor) : 1.0;
            this.r = THREE.Math.pow(color.r, safeInverse);
            this.g = THREE.Math.pow(color.g, safeInverse);
            this.b = THREE.Math.pow(color.b, safeInverse);
            return this;
        };
        Color.prototype.convertGammaToLinear = function () {
            var r = this.r, g = this.g, b = this.b;
            this.r = r * r;
            this.g = g * g;
            this.b = b * b;
            return this;
        };
        Color.prototype.convertLinearToGamma = function () {
            this.r = THREE.Math.sqrt(this.r);
            this.g = THREE.Math.sqrt(this.g);
            this.b = THREE.Math.sqrt(this.b);
            return this;
        };
        Color.prototype.getHex = function () {
            return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;
        };
        Color.prototype.getHexString = function () {
            return ('000000' + this.getHex().toString(16)).slice(-6);
        };
        Color.prototype.getHSL = function (optionalTarget) {
            var hsl = optionalTarget || { h: 0, s: 0, l: 0 };
            var r = this.r, g = this.g, b = this.b;
            var max = THREE.Math.max(r, g, b);
            var min = THREE.Math.min(r, g, b);
            var hue, saturation;
            var lightness = (min + max) / 2.0;
            if (min === max) {
                hue = 0;
                saturation = 0;
            }
            else {
                var delta = max - min;
                saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
                switch (max) {
                    case r:
                        hue = (g - b) / delta + (g < b ? 6 : 0);
                        break;
                    case g:
                        hue = (b - r) / delta + 2;
                        break;
                    case b:
                        hue = (r - g) / delta + 4;
                        break;
                }
                hue /= 6;
            }
            hsl.h = hue;
            hsl.s = saturation;
            hsl.l = lightness;
            return hsl;
        };
        Color.prototype.getStyle = function () {
            return 'rgb(' + ((this.r * 255) | 0) + ',' + ((this.g * 255) | 0) + ',' + ((this.b * 255) | 0) + ')';
        };
        Color.prototype.offsetHSL = function (h, s, l) {
            var hsl = this.getHSL();
            hsl.h += h;
            hsl.s += s;
            hsl.l += l;
            this.setHSL(hsl.h, hsl.s, hsl.l);
            return this;
        };
        Color.prototype.add = function (color) {
            this.r += color.r;
            this.g += color.g;
            this.b += color.b;
            return this;
        };
        Color.prototype.addColors = function (color1, color2) {
            this.r = color1.r + color2.r;
            this.g = color1.g + color2.g;
            this.b = color1.b + color2.b;
            return this;
        };
        Color.prototype.addScalar = function (s) {
            this.r += s;
            this.g += s;
            this.b += s;
            return this;
        };
        Color.prototype.sub = function (color) {
            this.r = THREE.Math.max(0, this.r - color.r);
            this.g = THREE.Math.max(0, this.g - color.g);
            this.b = THREE.Math.max(0, this.b - color.b);
            return this;
        };
        Color.prototype.multiply = function (color) {
            this.r *= color.r;
            this.g *= color.g;
            this.b *= color.b;
            return this;
        };
        Color.prototype.multiplyScalar = function (s) {
            this.r *= s;
            this.g *= s;
            this.b *= s;
            return this;
        };
        Color.prototype.lerp = function (color, alpha) {
            this.r += (color.r - this.r) * alpha;
            this.g += (color.g - this.g) * alpha;
            this.b += (color.b - this.b) * alpha;
            return this;
        };
        Color.prototype.equals = function (c) {
            return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);
        };
        Color.prototype.fromArray = function (array, offset) {
            if (offset === undefined)
                offset = 0;
            this.r = array[offset];
            this.g = array[offset + 1];
            this.b = array[offset + 2];
            return this;
        };
        Color.prototype.toArray = function (array, offset) {
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            array[offset] = this.r;
            array[offset + 1] = this.g;
            array[offset + 2] = this.b;
            return array;
        };
        return Color;
    }());
    THREE.Color = Color;
    THREE.ColorKeywords = {
        'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
        'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
        'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
        'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
        'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
        'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
        'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
        'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
        'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
        'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
        'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
        'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
        'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
        'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
        'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
        'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
        'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
        'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
        'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
        'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
        'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
        'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
        'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
        'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32
    };
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Box2 = (function () {
        function Box2(min, max) {
            if (min === void 0) { min = new THREE.Vector2(+Infinity, +Infinity); }
            if (max === void 0) { max = new THREE.Vector2(-Infinity, -Infinity); }
            this.min = min;
            this.max = max;
        }
        Box2.prototype.set = function (min, max) {
            this.min.copy(min);
            this.max.copy(max);
            return this;
        };
        Box2.prototype.setFromPoints = function (points) {
            this.makeEmpty();
            for (var i = 0, il = points.length; i < il; i++) {
                this.expandByPoint(points[i]);
            }
            return this;
        };
        Box2.prototype.setFromCenterAndSize = function (center, size) {
            var v1 = Box2.setFromCenterAndSize_v1;
            var halfSize = v1.copy(size).multiplyScalar(0.5);
            this.min.copy(center).sub(halfSize);
            this.max.copy(center).add(halfSize);
            return this;
        };
        Box2.prototype.clone = function () {
            return new Box2().copy(this);
        };
        Box2.prototype.copy = function (box) {
            this.min.copy(box.min);
            this.max.copy(box.max);
            return this;
        };
        Box2.prototype.makeEmpty = function () {
            this.min.x = this.min.y = +Infinity;
            this.max.x = this.max.y = -Infinity;
            return this;
        };
        Box2.prototype.isEmpty = function () {
            return (this.max.x < this.min.x) || (this.max.y < this.min.y);
        };
        Box2.prototype.center = function (optionalTarget) {
            if (optionalTarget === void 0) { optionalTarget = new THREE.Vector2(); }
            return optionalTarget.addVectors(this.min, this.max).multiplyScalar(0.5);
        };
        Box2.prototype.size = function (optionalTarget) {
            if (optionalTarget === void 0) { optionalTarget = new THREE.Vector2(); }
            var result = optionalTarget;
            return result.subVectors(this.max, this.min);
        };
        Box2.prototype.expandByPoint = function (point) {
            this.min.min(point);
            this.max.max(point);
            return this;
        };
        Box2.prototype.expandByVector = function (vector) {
            this.min.sub(vector);
            this.max.add(vector);
            return this;
        };
        Box2.prototype.expandByScalar = function (scalar) {
            this.min.addScalar(-scalar);
            this.max.addScalar(scalar);
            return this;
        };
        Box2.prototype.containsPoint = function (point) {
            if (point.x < this.min.x || point.x > this.max.x ||
                point.y < this.min.y || point.y > this.max.y) {
                return false;
            }
            return true;
        };
        Box2.prototype.containsBox = function (box) {
            if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) &&
                (this.min.y <= box.min.y) && (box.max.y <= this.max.y)) {
                return true;
            }
            return false;
        };
        Box2.prototype.getParameter = function (point, optionalTarget) {
            if (optionalTarget === void 0) { optionalTarget = new THREE.Vector2(); }
            var result = optionalTarget || new THREE.Vector2();
            return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
        };
        Box2.prototype.intersectsBox = function (box) {
            if (box.max.x < this.min.x || box.min.x > this.max.x ||
                box.max.y < this.min.y || box.min.y > this.max.y) {
                return false;
            }
            return true;
        };
        Box2.prototype.clampPoint = function (point, optionalTarget) {
            var result = optionalTarget || new THREE.Vector2();
            return result.copy(point).clamp(this.min, this.max);
        };
        Box2.prototype.distanceToPoint = function (point) {
            var v1 = Box2.distanceToPoint_v1;
            if (v1 === undefined)
                v1 = Box2.distanceToPoint_v1 = new THREE.Vector2();
            var func = Box2.prototype.distanceToPoint = function (point) {
                var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                clampedPoint.sub(point).length();
                return this;
            };
            return func.apply(this, arguments);
        };
        Box2.prototype.intersect = function (box) {
            this.min.max(box.min);
            this.max.min(box.max);
            return this;
        };
        Box2.prototype.union = function (box) {
            this.min.min(box.min);
            this.max.max(box.max);
            return this;
        };
        Box2.prototype.translate = function (offset) {
            this.min.add(offset);
            this.max.add(offset);
            return this;
        };
        Box2.prototype.equals = function (box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        };
        Box2.setFromCenterAndSize_v1 = new THREE.Vector2();
        return Box2;
    }());
    THREE.Box2 = Box2;
    ;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Box3 = (function () {
        function Box3(min, max) {
            if (min === void 0) { min = new THREE.Vector3(+Infinity, +Infinity, +Infinity); }
            if (max === void 0) { max = new THREE.Vector3(-Infinity, -Infinity, -Infinity); }
            this.min = min;
            this.max = max;
        }
        Box3.prototype.set = function (min, max) {
            this.min.copy(min);
            this.max.copy(max);
            return this;
        };
        Box3.prototype.setFromArray = function (array) {
            var minX = +Infinity;
            var minY = +Infinity;
            var minZ = +Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;
            var maxZ = -Infinity;
            for (var i = 0, l = array.length; i < l; i += 3) {
                var x = array[i];
                var y = array[i + 1];
                var z = array[i + 2];
                if (x < minX)
                    minX = x;
                if (y < minY)
                    minY = y;
                if (z < minZ)
                    minZ = z;
                if (x > maxX)
                    maxX = x;
                if (y > maxY)
                    maxY = y;
                if (z > maxZ)
                    maxZ = z;
            }
            this.min.set(minX, minY, minZ);
            this.max.set(maxX, maxY, maxZ);
        };
        Box3.prototype.setFromPoints = function (points) {
            this.makeEmpty();
            for (var i = 0, il = points.length; i < il; i++) {
                this.expandByPoint(points[i]);
            }
            return this;
        };
        Box3.prototype.setFromCenterAndSize = function (center, size) {
            var v1 = new THREE.Vector3();
            var func = Box3.prototype.setFromCenterAndSize = function (center, size) {
                var halfSize = v1.copy(size).multiplyScalar(0.5);
                this.min.copy(center).sub(halfSize);
                this.max.copy(center).add(halfSize);
                return this;
            };
            return func.apply(this, arguments);
        };
        Box3.prototype.setFromObject = function (object) {
            var v1 = new THREE.Vector3();
            var func = Box3.prototype.setFromObject = function (object) {
                var scope = this;
                object.updateMatrixWorld(true);
                this.makeEmpty();
                object.traverse(function (node) {
                    var geometry = node.geometry;
                    if (geometry !== undefined) {
                        if (geometry instanceof THREE.Geometry) {
                            var vertices = geometry.vertices;
                            for (var i = 0, il = vertices.length; i < il; i++) {
                                v1.copy(vertices[i]);
                                v1.applyMatrix4(node.matrixWorld);
                                scope.expandByPoint(v1);
                            }
                        }
                        else if (geometry instanceof THREE.BufferGeometry) {
                            var attribute = geometry.attributes.position;
                            if (attribute !== undefined) {
                                var array, offset, stride;
                                if (attribute instanceof THREE.InterleavedBufferAttribute) {
                                    array = attribute.data.array;
                                    offset = attribute.offset;
                                    stride = attribute.data.stride;
                                }
                                else {
                                    array = attribute.array;
                                    offset = 0;
                                    stride = 3;
                                }
                                for (var i_1 = offset, il_1 = array.length; i_1 < il_1; i_1 += stride) {
                                    v1.fromArray(array, i_1);
                                    v1.applyMatrix4(node.matrixWorld);
                                    scope.expandByPoint(v1);
                                }
                            }
                        }
                    }
                });
                return this;
            };
            return func.apply(this, arguments);
        };
        Box3.prototype.clone = function () {
            return new Box3().copy(this);
        };
        Box3.prototype.copy = function (box) {
            this.min.copy(box.min);
            this.max.copy(box.max);
            return this;
        };
        Box3.prototype.makeEmpty = function () {
            this.min.x = this.min.y = this.min.z = +Infinity;
            this.max.x = this.max.y = this.max.z = -Infinity;
            return this;
        };
        Box3.prototype.isEmpty = function () {
            return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);
        };
        Box3.prototype.center = function (optionalTarget) {
            var result = optionalTarget || new THREE.Vector3();
            return result.addVectors(this.min, this.max).multiplyScalar(0.5);
        };
        Box3.prototype.size = function (optionalTarget) {
            var result = optionalTarget || new THREE.Vector3();
            return result.subVectors(this.max, this.min);
        };
        Box3.prototype.expandByPoint = function (point) {
            this.min.min(point);
            this.max.max(point);
            return this;
        };
        Box3.prototype.expandByVector = function (vector) {
            this.min.sub(vector);
            this.max.add(vector);
            return this;
        };
        Box3.prototype.expandByScalar = function (scalar) {
            this.min.addScalar(-scalar);
            this.max.addScalar(scalar);
            return this;
        };
        Box3.prototype.containsPoint = function (point) {
            if (point.x < this.min.x || point.x > this.max.x ||
                point.y < this.min.y || point.y > this.max.y ||
                point.z < this.min.z || point.z > this.max.z) {
                return false;
            }
            return true;
        };
        Box3.prototype.containsBox = function (box) {
            if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) &&
                (this.min.y <= box.min.y) && (box.max.y <= this.max.y) &&
                (this.min.z <= box.min.z) && (box.max.z <= this.max.z)) {
                return true;
            }
            return false;
        };
        Box3.prototype.getParameter = function (point, optionalTarget) {
            var result = optionalTarget || new THREE.Vector3();
            return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
        };
        Box3.prototype.intersectsBox = function (box) {
            if (box.max.x < this.min.x || box.min.x > this.max.x ||
                box.max.y < this.min.y || box.min.y > this.max.y ||
                box.max.z < this.min.z || box.min.z > this.max.z) {
                return false;
            }
            return true;
        };
        Box3.prototype.intersectsSphere = function (sphere) {
            var closestPoint = new THREE.Vector3();
            var func = Box3.prototype.intersectsSphere = function (sphere) {
                this.clampPoint(sphere.center, closestPoint);
                var result = closestPoint.distanceToSquared(sphere.center) <= (sphere.radius * sphere.radius);
                return result;
            };
            return func.apply(this, arguments);
        };
        Box3.prototype.intersectsPlane = function (plane) {
            var min, max;
            if (plane.normal.x > 0) {
                min = plane.normal.x * this.min.x;
                max = plane.normal.x * this.max.x;
            }
            else {
                min = plane.normal.x * this.max.x;
                max = plane.normal.x * this.min.x;
            }
            if (plane.normal.y > 0) {
                min += plane.normal.y * this.min.y;
                max += plane.normal.y * this.max.y;
            }
            else {
                min += plane.normal.y * this.max.y;
                max += plane.normal.y * this.min.y;
            }
            if (plane.normal.z > 0) {
                min += plane.normal.z * this.min.z;
                max += plane.normal.z * this.max.z;
            }
            else {
                min += plane.normal.z * this.max.z;
                max += plane.normal.z * this.min.z;
            }
            return (min <= plane.constant && max >= plane.constant);
        };
        Box3.prototype.clampPoint = function (point, optionalTarget) {
            var result = optionalTarget || new THREE.Vector3();
            return result.copy(point).clamp(this.min, this.max);
        };
        Box3.prototype.distanceToPoint = function (point) {
            var v1 = Box3.distanceToPoint_v1;
            var clampedPoint = v1.copy(point).clamp(this.min, this.max);
            var result = clampedPoint.sub(point).length();
            return result;
        };
        Box3.prototype.getBoundingSphere = function (optionalTarget) {
            var v1 = Box3.getBoundingSphere_v1;
            var result = optionalTarget || new THREE.Sphere();
            result.center = this.center();
            result.radius = this.size(v1).length() * 0.5;
            return result;
        };
        Box3.prototype.intersect = function (box) {
            this.min.max(box.min);
            this.max.min(box.max);
            if (this.isEmpty())
                this.makeEmpty();
            return this;
        };
        Box3.prototype.union = function (box) {
            this.min.min(box.min);
            this.max.max(box.max);
            return this;
        };
        Box3.prototype.applyMatrix4 = function (matrix) {
            if (Box3.applyMatrix4_points === undefined) {
                Box3.applyMatrix4_points = [
                    new THREE.Vector3(),
                    new THREE.Vector3(),
                    new THREE.Vector3(),
                    new THREE.Vector3(),
                    new THREE.Vector3(),
                    new THREE.Vector3(),
                    new THREE.Vector3(),
                    new THREE.Vector3()];
            }
            var points = Box3.applyMatrix4_points;
            if (this.isEmpty())
                return this;
            points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
            points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
            points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
            points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
            points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
            points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
            points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
            points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
            this.setFromPoints(points);
            return this;
        };
        Box3.prototype.translate = function (offset) {
            this.min.add(offset);
            this.max.add(offset);
            return this;
        };
        Box3.prototype.equals = function (box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        };
        Box3.distanceToPoint_v1 = new THREE.Vector3();
        Box3.getBoundingSphere_v1 = new THREE.Vector3();
        return Box3;
    }());
    THREE.Box3 = Box3;
    ;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Sphere = (function () {
        function Sphere(center, radius) {
            if (center === void 0) { center = new THREE.Vector3(); }
            if (radius === void 0) { radius = 0; }
            this.center = center;
            this.radius = radius;
        }
        Sphere.prototype.set = function (center, radius) {
            this.center.copy(center);
            this.radius = radius;
            return this;
        };
        Sphere.prototype.setFromPoints = function (points, optionalCenter) {
            var box = new THREE.Box3();
            var func = Sphere.prototype.setFromPoints = function (points, optionalCenter) {
                var center = this.center;
                if (optionalCenter !== undefined) {
                    center.copy(optionalCenter);
                }
                else {
                    box.setFromPoints(points).center(center);
                }
                var maxRadiusSq = 0;
                for (var i = 0, il = points.length; i < il; i++) {
                    maxRadiusSq = THREE.Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
                }
                this.radius = THREE.Math.sqrt(maxRadiusSq);
                return this;
            };
            return func.apply(this, arguments);
        };
        Sphere.prototype.clone = function () {
            return new Sphere().copy(this);
        };
        Sphere.prototype.copy = function (sphere) {
            this.center.copy(sphere.center);
            this.radius = sphere.radius;
            return this;
        };
        Sphere.prototype.empty = function () {
            return (this.radius <= 0);
        };
        Sphere.prototype.containsPoint = function (point) {
            return (point.distanceToSquared(this.center) <= (this.radius * this.radius));
        };
        Sphere.prototype.distanceToPoint = function (point) {
            return (point.distanceTo(this.center) - this.radius);
        };
        Sphere.prototype.intersectsSphere = function (sphere) {
            var radiusSum = this.radius + sphere.radius;
            return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);
        };
        Sphere.prototype.intersectsBox = function (box) {
            return box.intersectsSphere(this);
        };
        Sphere.prototype.intersectsPlane = function (plane) {
            return THREE.Math.abs(this.center.dot(plane.normal) - plane.constant) <= this.radius;
        };
        Sphere.prototype.clampPoint = function (point, optionalTarget) {
            var deltaLengthSq = this.center.distanceToSquared(point);
            var result = optionalTarget || new THREE.Vector3();
            result.copy(point);
            if (deltaLengthSq > (this.radius * this.radius)) {
                result.sub(this.center).normalize();
                result.multiplyScalar(this.radius).add(this.center);
            }
            return result;
        };
        Sphere.prototype.getBoundingBox = function (optionalTarget) {
            var box = optionalTarget || new THREE.Box3();
            box.set(this.center, this.center);
            box.expandByScalar(this.radius);
            return box;
        };
        Sphere.prototype.applyMatrix4 = function (matrix) {
            this.center.applyMatrix4(matrix);
            this.radius = this.radius * matrix.getMaxScaleOnAxis();
            return this;
        };
        Sphere.prototype.translate = function (offset) {
            this.center.add(offset);
            return this;
        };
        Sphere.prototype.equals = function (sphere) {
            return sphere.center.equals(this.center) && (sphere.radius === this.radius);
        };
        return Sphere;
    }());
    THREE.Sphere = Sphere;
    ;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Spherical = (function () {
        function Spherical(radius, phi, theta) {
            if (radius === void 0) { radius = 1; }
            if (phi === void 0) { phi = 0; }
            if (theta === void 0) { theta = 0; }
            this.radius = radius;
            this.phi = phi;
            this.theta = theta;
        }
        Spherical.prototype.set = function (radius, phi, theta) {
            this.radius = radius;
            this.phi = phi;
            this.theta = theta;
            return this;
        };
        Spherical.prototype.clone = function () {
            return new Spherical().copy(this);
        };
        Spherical.prototype.copy = function (other) {
            this.radius = (other.radius);
            this.phi = (other.phi);
            this.theta = (other.theta);
            return this;
        };
        Spherical.prototype.makeSafe = function () {
            var EPS = 0.000001;
            this.phi = THREE.Math.max(EPS, THREE.Math.min(THREE.Math.PI - EPS, this.phi));
            return this;
        };
        Spherical.prototype.setFromVector3 = function (vec3) {
            this.radius = vec3.length();
            if (this.radius === 0) {
                this.theta = 0;
                this.phi = 0;
            }
            else {
                this.theta = THREE.Math.atan2(vec3.x, vec3.z);
                this.phi = THREE.Math.acos(THREE.Math.clamp(vec3.y / this.radius, -1, 1));
            }
            return this;
        };
        return Spherical;
    }());
    THREE.Spherical = Spherical;
    ;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Triangle = (function () {
        function Triangle(a, b, c) {
            if (a === void 0) { a = new THREE.Vector3(); }
            if (b === void 0) { b = new THREE.Vector3(); }
            if (c === void 0) { c = new THREE.Vector3(); }
            this.a = a;
            this.b = b;
            this.c = c;
        }
        Triangle.normal = function (a, b, c, optionalTarget) {
            var v0 = new THREE.Vector3();
            var func = Triangle.normal = function (a, b, c, optionalTarget) {
                var result = optionalTarget || new THREE.Vector3();
                result.subVectors(c, b);
                v0.subVectors(a, b);
                result.cross(v0);
                var resultLengthSq = result.lengthSq();
                if (resultLengthSq > 0) {
                    return result.multiplyScalar(1 / THREE.Math.sqrt(resultLengthSq));
                }
                return result.set(0, 0, 0);
            };
            return func.apply(this, arguments);
        };
        Triangle.barycoordFromPoint = function (point, a, b, c, optionalTarget) {
            var v0 = new THREE.Vector3();
            var v1 = new THREE.Vector3();
            var v2 = new THREE.Vector3();
            var func = Triangle.barycoordFromPoint = function (point, a, b, c, optionalTarget) {
                v0.subVectors(c, a);
                v1.subVectors(b, a);
                v2.subVectors(point, a);
                var dot00 = v0.dot(v0);
                var dot01 = v0.dot(v1);
                var dot02 = v0.dot(v2);
                var dot11 = v1.dot(v1);
                var dot12 = v1.dot(v2);
                var denom = (dot00 * dot11 - dot01 * dot01);
                var result = optionalTarget || new THREE.Vector3();
                if (denom === 0) {
                    return result.set(-2, -1, -1);
                }
                var invDenom = 1 / denom;
                var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                return result.set(1 - u - v, v, u);
            };
            return func.apply(this, arguments);
        };
        Triangle.containsPoint = function (point, a, b, c) {
            var v1 = new THREE.Vector3();
            var func = Triangle.containsPoint = function (point, a, b, c) {
                var result = Triangle.barycoordFromPoint(point, a, b, c, v1);
                var r = (result.x >= 0) && (result.y >= 0) && ((result.x + result.y) <= 1);
                return r;
            };
            return func.apply(this, arguments);
        };
        Triangle.prototype.set = function (a, b, c) {
            this.a.copy(a);
            this.b.copy(b);
            this.c.copy(c);
            return this;
        };
        Triangle.prototype.setFromPointsAndIndices = function (points, i0, i1, i2) {
            this.a.copy(points[i0]);
            this.b.copy(points[i1]);
            this.c.copy(points[i2]);
            return this;
        };
        Triangle.prototype.clone = function () {
            return new Triangle().copy(this);
        };
        Triangle.prototype.copy = function (triangle) {
            this.a.copy(triangle.a);
            this.b.copy(triangle.b);
            this.c.copy(triangle.c);
            return this;
        };
        Triangle.prototype.area = function () {
            var v0 = new THREE.Vector3();
            var v1 = new THREE.Vector3();
            var func = Triangle.prototype.area = function () {
                v0.subVectors(this.c, this.b);
                v1.subVectors(this.a, this.b);
                var area = v0.cross(v1).length() * 0.5;
                return area;
            };
            return func.apply(this, arguments);
        };
        Triangle.prototype.midpoint = function (optionalTarget) {
            var result = optionalTarget || new THREE.Vector3();
            return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        };
        Triangle.prototype.normal = function (optionalTarget) {
            return Triangle.normal(this.a, this.b, this.c, optionalTarget);
        };
        Triangle.prototype.plane = function (optionalTarget) {
            var result = optionalTarget || new THREE.Plane();
            return result.setFromCoplanarPoints(this.a, this.b, this.c);
        };
        Triangle.prototype.barycoordFromPoint = function (point, optionalTarget) {
            return Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
        };
        Triangle.prototype.containsPoint = function (point) {
            return Triangle.containsPoint(point, this.a, this.b, this.c);
        };
        Triangle.prototype.closestPointToPoint = function (point, optionalTarget) {
            var plane = new THREE.Plane();
            var edgeList = [new THREE.Line3(), new THREE.Line3(), new THREE.Line3()];
            var projectedPoint = new THREE.Vector3();
            var closestPoint = new THREE.Vector3();
            var func = Triangle.prototype.closestPointToPoint = function (point, optionalTarget) {
                var result = optionalTarget || new THREE.Vector3();
                var minDistance = Infinity;
                plane.setFromCoplanarPoints(this.a, this.b, this.c);
                plane.projectPoint(point, projectedPoint);
                if (this.containsPoint(projectedPoint) === true) {
                    result.copy(projectedPoint);
                }
                else {
                    edgeList[0].set(this.a, this.b);
                    edgeList[1].set(this.b, this.c);
                    edgeList[2].set(this.c, this.a);
                    for (var i = 0; i < edgeList.length; i++) {
                        edgeList[i].closestPointToPoint(projectedPoint, true, closestPoint);
                        var distance = projectedPoint.distanceToSquared(closestPoint);
                        if (distance < minDistance) {
                            minDistance = distance;
                            result.copy(closestPoint);
                        }
                    }
                }
                return result;
            };
            return func.apply(this, arguments);
        };
        Triangle.prototype.equals = function (triangle) {
            return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
        };
        return Triangle;
    }());
    THREE.Triangle = Triangle;
    ;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Object3D = (function (_super) {
        __extends(Object3D, _super);
        function Object3D() {
            _super.call(this);
            this._id = THREE.Object3DIdCount++;
            this.uuid = THREE.Math.generateUUID();
            this.name = '';
            this.type = 'Object3D';
            this.parent = null;
            this.children = [];
            this.up = Object3D.DefaultUp.clone();
            this._position = new THREE.Vector3();
            this._rotation = new THREE.Euler();
            this._quaternion = new THREE.Quaternion();
            this._scale = new THREE.Vector3(1, 1, 1);
            this._modelViewMatrix = new THREE.Matrix4();
            this._normalMatrix = new THREE.Matrix3();
            this.matrix = new THREE.Matrix4();
            this.matrixWorld = new THREE.Matrix4();
            this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
            this.matrixWorldNeedsUpdate = false;
            this.layers = new THREE.Layers();
            this.visible = true;
            this.castShadow = false;
            this.receiveShadow = false;
            this.frustumCulled = true;
            this.renderOrder = 0;
            this.userData = {};
            this.rotation.onChange(this.onRotationChange, this);
            this.quaternion.onChange(this.onQuaternionChange, this);
        }
        Object.defineProperty(Object3D.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object3D.prototype.onRotationChange = function () {
            this.quaternion.setFromEuler(this.rotation, false);
        };
        Object3D.prototype.onQuaternionChange = function () {
            this.rotation.setFromQuaternion(this.quaternion, undefined, false);
        };
        Object.defineProperty(Object3D.prototype, "position", {
            get: function () {
                return this._position;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotation", {
            get: function () {
                return this._rotation;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "quaternion", {
            get: function () {
                return this._quaternion;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scale", {
            get: function () {
                return this._scale;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "modelViewMatrix", {
            get: function () {
                return this._modelViewMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "normalMatrix", {
            get: function () {
                return this._normalMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object3D.prototype.applyMatrix = function (matrix) {
            this.matrix.multiplyMatrices(matrix, this.matrix);
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        };
        Object3D.prototype.setRotationFromAxisAngle = function (axis, angle) {
            this.quaternion.setFromAxisAngle(axis, angle);
        };
        Object3D.prototype.setRotationFromEuler = function (euler) {
            this.quaternion.setFromEuler(euler, true);
        };
        Object3D.prototype.setRotationFromMatrix = function (m) {
            this.quaternion.setFromRotationMatrix(m);
        };
        Object3D.prototype.setRotationFromQuaternion = function (q) {
            this.quaternion.copy(q);
        };
        Object3D.prototype.rotateOnAxis = function (axis, angle) {
            var q1 = new THREE.Quaternion();
            var func = Object3D.prototype.rotateOnAxis
                = function (axis, angle) {
                    q1.setFromAxisAngle(axis, angle);
                    this.quaternion.multiply(q1);
                    return this;
                };
            return func.apply(this, arguments);
        };
        Object3D.prototype.rotateX = function (angle) {
            var v1 = new THREE.Vector3(1, 0, 0);
            var func = Object3D.prototype.rotateX = function (angle) {
                return this.rotateOnAxis(v1, angle);
            };
            return func.apply(this, arguments);
        };
        Object3D.prototype.rotateY = function (angle) {
            var v1 = new THREE.Vector3(0, 1, 0);
            var func = Object3D.prototype.rotateY = function (angle) {
                this.rotateOnAxis(v1, angle);
                return this;
            };
            return func.apply(this, arguments);
        };
        Object3D.prototype.rotateZ = function (angle) {
            var v1 = new THREE.Vector3(0, 0, 1);
            var func = Object3D.prototype.rotateZ = function (angle) {
                this.rotateOnAxis(v1, angle);
                return this;
            };
            return func.apply(this, arguments);
        };
        Object3D.prototype.translateOnAxis = function (axis, distance) {
            var v1 = new THREE.Vector3();
            var func = Object3D.prototype.translateOnAxis = function (axis, distance) {
                v1.copy(axis).applyQuaternion(this.quaternion);
                this.position.add(v1.multiplyScalar(distance));
                return this;
            };
            return func.apply(this, arguments);
        };
        Object3D.prototype.translateX = function (distance) {
            var v1 = new THREE.Vector3(1, 0, 0);
            var func = Object3D.prototype.translateX = function (distance) {
                return this.translateOnAxis(v1, distance);
            };
            return func.apply(this, arguments);
        };
        Object3D.prototype.translateY = function (distance) {
            var v1 = new THREE.Vector3(0, 1, 0);
            var func = Object3D.prototype.translateY = function (distance) {
                return this.translateOnAxis(v1, distance);
            };
            return func.apply(this, arguments);
        };
        Object3D.prototype.translateZ = function (distance) {
            var v1 = new THREE.Vector3(0, 0, 1);
            var func = Object3D.prototype.translateZ = function (distance) {
                return this.translateOnAxis(v1, distance);
            };
            return func.apply(this, arguments);
        };
        Object3D.prototype.localToWorld = function (vector) {
            return vector.applyMatrix4(this.matrixWorld);
        };
        Object3D.prototype.worldToLocal = function (vector) {
            var m1 = new THREE.Matrix4();
            var func = Object3D.prototype.worldToLocal = function (vector) {
                return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
            };
            return func.apply(this, arguments);
        };
        Object3D.prototype.lookAt = function (vector) {
            var m1 = new THREE.Matrix4();
            var func = Object3D.prototype.lookAt = function (vector) {
                m1.lookAt(vector, this.position, this.up);
                this.quaternion.setFromRotationMatrix(m1);
            };
            func.apply(this, arguments);
        };
        Object3D.prototype.add = function (object) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                    this.add(arguments[i]);
                }
                return this;
            }
            if (object === this) {
                console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
                return this;
            }
            if (object instanceof Object3D) {
                if (object.parent !== null) {
                    object.parent.remove(object);
                }
                object.parent = this;
                object.dispatchEvent({ type: 'added' });
                this.children.push(object);
            }
            else {
                console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
            }
            return this;
        };
        Object3D.prototype.remove = function (object) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                    this.remove(arguments[i]);
                }
            }
            var index = this.children.indexOf(object);
            if (index !== -1) {
                object.parent = null;
                object.dispatchEvent({ type: 'removed' });
                this.children.splice(index, 1);
            }
        };
        Object3D.prototype.getObjectById = function (id) {
            return this.getObjectByProperty('id', id);
        };
        Object3D.prototype.getObjectByName = function (name) {
            return this.getObjectByProperty('name', name);
        };
        Object3D.prototype.getObjectByProperty = function (name, value) {
            if (this[name] === value)
                return this;
            for (var i = 0, l = this.children.length; i < l; i++) {
                var child = this.children[i];
                var object = child.getObjectByProperty(name, value);
                if (object !== undefined) {
                    return object;
                }
            }
            return undefined;
        };
        Object3D.prototype.getWorldPosition = function (optionalTarget) {
            var result = optionalTarget || new THREE.Vector3();
            this.updateMatrixWorld(true);
            return result.setFromMatrixPosition(this.matrixWorld);
        };
        Object3D.prototype.getWorldQuaternion = function (optionalTarget) {
            var position = new THREE.Vector3();
            var scale = new THREE.Vector3();
            var func = Object3D.prototype.getWorldQuaternion = function (optionalTarget) {
                var result = optionalTarget || new THREE.Quaternion();
                this.updateMatrixWorld(true);
                this.matrixWorld.decompose(position, result, scale);
                return result;
            };
            return func.apply(this, arguments);
        };
        Object3D.prototype.getWorldRotation = function (optionalTarget) {
            var quaternion = new THREE.Quaternion();
            var func = Object3D.prototype.getWorldRotation = function (optionalTarget) {
                var result = optionalTarget || new THREE.Euler();
                this.getWorldQuaternion(quaternion);
                return result.setFromQuaternion(quaternion, this.rotation.order, false);
            };
            return func.apply(this, arguments);
        };
        Object3D.prototype.getWorldScale = function (optionalTarget) {
            var position = new THREE.Vector3();
            var quaternion = new THREE.Quaternion();
            var func = Object3D.prototype.getWorldScale = function (optionalTarget) {
                var result = optionalTarget || new THREE.Vector3();
                this.updateMatrixWorld(true);
                this.matrixWorld.decompose(position, quaternion, result);
                return result;
            };
            return func.apply(this, arguments);
        };
        Object3D.prototype.getWorldDirection = function (optionalTarget) {
            var quaternion = new THREE.Quaternion();
            var func = Object3D.prototype.getWorldDirection = function (optionalTarget) {
                var result = optionalTarget || new THREE.Vector3();
                this.getWorldQuaternion(quaternion);
                return result.set(0, 0, 1).applyQuaternion(quaternion);
            };
            return func.apply(this, arguments);
        };
        Object3D.prototype.raycast = function (raycaster, intersects) { };
        Object3D.prototype.traverse = function (callback) {
            callback(this);
            var children = this.children;
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].traverse(callback);
            }
        };
        Object3D.prototype.traverseVisible = function (callback) {
            if (this.visible === false)
                return;
            callback(this);
            var children = this.children;
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].traverseVisible(callback);
            }
        };
        Object3D.prototype.traverseAncestors = function (callback) {
            var parent = this.parent;
            if (parent !== null) {
                callback(parent);
                parent.traverseAncestors(callback);
            }
        };
        Object3D.prototype.updateMatrix = function () {
            this.matrix.compose(this.position, this.quaternion, this.scale);
            this.matrixWorldNeedsUpdate = true;
        };
        Object3D.prototype.updateMatrixWorld = function (force) {
            if (this.matrixAutoUpdate === true)
                this.updateMatrix();
            if (this.matrixWorldNeedsUpdate === true || force === true) {
                if (this.parent === null) {
                    this.matrixWorld.copy(this.matrix);
                }
                else {
                    this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                }
                this.matrixWorldNeedsUpdate = false;
                force = true;
            }
            for (var i = 0, l = this.children.length; i < l; i++) {
                this.children[i].updateMatrixWorld(force);
            }
        };
        Object3D.prototype.toJSON = function (meta) {
            var isRootObject = (meta === undefined || meta === '');
            var output = {};
            if (isRootObject) {
                meta = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {}
                };
                output.metadata = {
                    version: 4.4,
                    type: 'Object',
                    generator: 'Object3D.toJSON'
                };
            }
            var object = {};
            object.uuid = this.uuid;
            object.type = this.type;
            if (this.name !== '')
                object.name = this.name;
            if (JSON.stringify(this.userData) !== '{}')
                object.userData = this.userData;
            if (this.castShadow === true)
                object.castShadow = true;
            if (this.receiveShadow === true)
                object.receiveShadow = true;
            if (this.visible === false)
                object.visible = false;
            object.matrix = this.matrix.toArray();
            if (this.geometry !== undefined) {
                if (meta.geometries[this.geometry.uuid] === undefined) {
                    meta.geometries[this.geometry.uuid] = this.geometry.toJSON(meta);
                }
                object.geometry = this.geometry.uuid;
            }
            if (this.material !== undefined) {
                if (meta.materials[this.material.uuid] === undefined) {
                    meta.materials[this.material.uuid] = this.material.toJSON(meta);
                }
                object.material = this.material.uuid;
            }
            if (this.children.length > 0) {
                object.children = [];
                for (var i = 0; i < this.children.length; i++) {
                    object.children.push(this.children[i].toJSON(meta).object);
                }
            }
            if (isRootObject) {
                var geometries = extractFromCache(meta.geometries);
                var materials = extractFromCache(meta.materials);
                var textures = extractFromCache(meta.textures);
                var images = extractFromCache(meta.images);
                if (geometries.length > 0)
                    output.geometries = geometries;
                if (materials.length > 0)
                    output.materials = materials;
                if (textures.length > 0)
                    output.textures = textures;
                if (images.length > 0)
                    output.images = images;
            }
            output.object = object;
            return output;
            function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                    var data = cache[key];
                    delete data.metadata;
                    values.push(data);
                }
                return values;
            }
        };
        Object3D.prototype.clone = function (recursive) {
            return new this.constructor().copy(this, recursive);
        };
        Object3D.prototype.copy = function (source, recursive) {
            if (recursive === undefined)
                recursive = true;
            this.name = source.name;
            this.up.copy(source.up);
            this.position.copy(source.position);
            this.quaternion.copy(source.quaternion);
            this.scale.copy(source.scale);
            this.matrix.copy(source.matrix);
            this.matrixWorld.copy(source.matrixWorld);
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
            this.visible = source.visible;
            this.castShadow = source.castShadow;
            this.receiveShadow = source.receiveShadow;
            this.frustumCulled = source.frustumCulled;
            this.renderOrder = source.renderOrder;
            this.userData = JSON.parse(JSON.stringify(source.userData));
            if (recursive === true) {
                for (var i = 0; i < source.children.length; i++) {
                    var child = source.children[i];
                    this.add(child.clone());
                }
            }
            return this;
        };
        Object3D.DefaultUp = new THREE.Vector3(0, 1, 0);
        Object3D.DefaultMatrixAutoUpdate = true;
        return Object3D;
    }(THREE.EventDispatcher));
    THREE.Object3D = Object3D;
    THREE.Object3DIdCount = 0;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Audio = (function (_super) {
        __extends(Audio, _super);
        function Audio(listener) {
            _super.call(this);
            this.type = 'Audio';
            this.context = listener.context;
            this.source = this.context.createBufferSource();
            this.source.onended = this.onEnded.bind(this);
            this.gain = this.context.createGain();
            this.gain.connect(listener.getInput());
            this.autoplay = false;
            this.startTime = 0;
            this.playbackRate = 1;
            this.isPlaying = false;
            this.hasPlaybackControl = true;
            this.sourceType = 'empty';
            this.filters = [];
        }
        ;
        Audio.prototype.getOutput = function () {
            return this.gain;
        };
        Audio.prototype.setNodeSource = function (audioNode) {
            this.hasPlaybackControl = false;
            this.sourceType = 'audioNode';
            this.source = audioNode;
            this.connect();
            return this;
        };
        Audio.prototype.setBuffer = function (audioBuffer) {
            this.source.buffer = audioBuffer;
            this.sourceType = 'buffer';
            if (this.autoplay)
                this.play();
            return this;
        };
        Audio.prototype.play = function () {
            if (this.isPlaying === true) {
                console.warn('THREE.Audio: Audio is already playing.');
                return;
            }
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            var source = this.context.createBufferSource();
            source.buffer = this.source.buffer;
            source.loop = this.source.loop;
            source.onended = this.source.onended;
            source.start(0, this.startTime);
            source.playbackRate.value = this.playbackRate;
            this.isPlaying = true;
            this.source = source;
            return this.connect();
        };
        Audio.prototype.pause = function () {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this.source.stop();
            this.startTime = this.context.currentTime;
            this.isPlaying = false;
            return this;
        };
        Audio.prototype.stop = function () {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this.source.stop();
            this.startTime = 0;
            this.isPlaying = false;
            return this;
        };
        Audio.prototype.connect = function () {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var i = 1, l = this.filters.length; i < l; i++) {
                    this.filters[i - 1].connect(this.filters[i]);
                }
                this.filters[this.filters.length - 1].connect(this.getOutput());
            }
            else {
                this.source.connect(this.getOutput());
            }
            return this;
        };
        Audio.prototype.disconnect = function () {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var i = 1, l = this.filters.length; i < l; i++) {
                    this.filters[i - 1].disconnect(this.filters[i]);
                }
                this.filters[this.filters.length - 1].disconnect(this.getOutput());
            }
            else {
                this.source.disconnect(this.getOutput());
            }
            return this;
        };
        Audio.prototype.getFilters = function () {
            return this.filters;
        };
        Audio.prototype.setFilters = function (value) {
            if (!value)
                value = [];
            if (this.isPlaying === true) {
                this.disconnect();
                this.filters = value;
                this.connect();
            }
            else {
                this.filters = value;
            }
            return this;
        };
        Audio.prototype.getFilter = function () {
            return this.getFilters()[0];
        };
        Audio.prototype.setFilter = function (filter) {
            return this.setFilters(filter ? [filter] : []);
        };
        Audio.prototype.setPlaybackRate = function (value) {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this.playbackRate = value;
            if (this.isPlaying === true) {
                this.source.playbackRate.value = this.playbackRate;
            }
            return this;
        };
        Audio.prototype.getPlaybackRate = function () {
            return this.playbackRate;
        };
        Audio.prototype.onEnded = function () {
            this.isPlaying = false;
        };
        Audio.prototype.getLoop = function () {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return false;
            }
            return this.source.loop;
        };
        Audio.prototype.setLoop = function (value) {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this.source.loop = value;
        };
        Audio.prototype.getVolume = function () {
            return this.gain.gain.value;
        };
        Audio.prototype.setVolume = function (value) {
            this.gain.gain.value = value;
            return this;
        };
        return Audio;
    }(THREE.Object3D));
    THREE.Audio = Audio;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var AudioAnalyser = (function () {
        function AudioAnalyser(audio, fftSize) {
            this.analyser = audio.context.createAnalyser();
            this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
            this.data = new Uint8Array(this.analyser.frequencyBinCount);
            audio.getOutput().connect(this.analyser);
        }
        ;
        AudioAnalyser.prototype.getFrequencyData = function () {
            this.analyser.getByteFrequencyData(this.data);
            return this.data;
        };
        AudioAnalyser.prototype.getAverageFrequency = function () {
            var value = 0, data = this.getFrequencyData();
            for (var i = 0; i < data.length; i++) {
                value += data[i];
            }
            return value / data.length;
        };
        return AudioAnalyser;
    }());
    THREE.AudioAnalyser = AudioAnalyser;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
})(THREE || (THREE = {}));
Object.defineProperty(THREE, 'AudioContext', {
    get: (function () {
        var context;
        return function get() {
            if (context === undefined) {
                context = new (window.AudioContext || window.webkitAudioContext)();
            }
            return context;
        };
    })()
});
var THREE;
(function (THREE) {
    var AudioListener = (function (_super) {
        __extends(AudioListener, _super);
        function AudioListener() {
            _super.call(this);
            this.type = 'AudioListener';
            this.context = THREE.AudioContext;
            this.gain = this.context.createGain();
            this.gain.connect(this.context.destination);
            this.filter = null;
        }
        ;
        AudioListener.prototype.getInput = function () {
            return this.gain;
        };
        AudioListener.prototype.removeFilter = function () {
            if (this.filter !== null) {
                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
                this.gain.connect(this.context.destination);
                this.filter = null;
            }
        };
        AudioListener.prototype.getFilter = function () {
            return this.filter;
        };
        AudioListener.prototype.setFilter = function (value) {
            if (this.filter !== null) {
                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
            }
            else {
                this.gain.disconnect(this.context.destination);
            }
            this.filter = value;
            this.gain.connect(this.filter);
            this.filter.connect(this.context.destination);
        };
        AudioListener.prototype.getMasterVolume = function () {
            return this.gain.gain.value;
        };
        AudioListener.prototype.setMasterVolume = function (value) {
            this.gain.gain.value = value;
        };
        AudioListener.prototype.updateMatrixWorld = function (force) {
            var position = AudioListener[".umw.position"];
            var quaternion = AudioListener[".umw.quaternion"];
            var scale = AudioListener[".umw.scale"];
            var orientation = AudioListener[".umw.orientation"];
            if (position === undefined) {
                position = AudioListener[".umw.position"] = new THREE.Vector3();
                quaternion = AudioListener[".umw.quaternion"] = new THREE.Quaternion();
                scale = AudioListener[".umw.scale"] = new THREE.Vector3();
                orientation = AudioListener[".umw.orientation"] = new THREE.Vector3();
            }
            _super.prototype.updateMatrixWorld.call(this, force);
            var listener = this.context.listener;
            var up = this.up;
            this.matrixWorld.decompose(position, quaternion, scale);
            orientation.set(0, 0, -1).applyQuaternion(quaternion);
            listener.setPosition(position.x, position.y, position.z);
            listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
        };
        return AudioListener;
    }(THREE.Object3D));
    THREE.AudioListener = AudioListener;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var PositionalAudio = (function (_super) {
        __extends(PositionalAudio, _super);
        function PositionalAudio(listener) {
            _super.call(this, listener);
            this.panner = this.context.createPanner();
            this.panner.connect(this.gain);
        }
        ;
        PositionalAudio.prototype.getOutput = function () {
            return this.panner;
        };
        PositionalAudio.prototype.getRefDistance = function () {
            return this.panner.refDistance;
        };
        PositionalAudio.prototype.setRefDistance = function (value) {
            this.panner.refDistance = value;
        };
        PositionalAudio.prototype.getRolloffFactor = function () {
            return this.panner.rolloffFactor;
        };
        PositionalAudio.prototype.setRolloffFactor = function (value) {
            this.panner.rolloffFactor = value;
        };
        PositionalAudio.prototype.getDistanceModel = function () {
            return this.panner.distanceModel;
        };
        PositionalAudio.prototype.setDistanceModel = function (value) {
            this.panner.distanceModel = value;
        };
        PositionalAudio.prototype.getMaxDistance = function () {
            return this.panner.maxDistance;
        };
        PositionalAudio.prototype.setMaxDistance = function (value) {
            this.panner.maxDistance = value;
        };
        PositionalAudio.prototype.updateMatrixWorld = function (force) {
            var position = PositionalAudio[".umw.pos"] || (PositionalAudio[".umw.pos"] = new THREE.Vector3());
            _super.prototype.updateMatrixWorld.call(this, force);
            position.setFromMatrixPosition(this.matrixWorld);
            this.panner.setPosition(position.x, position.y, position.z);
        };
        return PositionalAudio;
    }(THREE.Audio));
    THREE.PositionalAudio = PositionalAudio;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Camera = (function (_super) {
        __extends(Camera, _super);
        function Camera() {
            _super.call(this);
            this.matrixWorldInverse = new THREE.Matrix4();
            this.projectionMatrix = new THREE.Matrix4();
            this.type = 'Camera';
        }
        ;
        Camera.prototype.getWorldDirection = function (optionalTarget) {
            var quaternion = Camera[".getWorldDirection.quaternion."] || (Camera[".getWorldDirection.quaternion."] = new THREE.Quaternion());
            var result = optionalTarget || new THREE.Vector3();
            this.getWorldQuaternion(quaternion);
            return result.set(0, 0, -1).applyQuaternion(quaternion);
        };
        Camera.prototype.lookAt = function (vector) {
            var m1 = Camera[".lookAt.m1."] || (Camera[".lookAt.m1."] = new THREE.Matrix4());
            m1.lookAt(this.position, vector, this.up);
            this.quaternion.setFromRotationMatrix(m1);
        };
        Camera.prototype.clone = function () {
            return new this.constructor().copy(this);
        };
        ;
        Camera.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.matrixWorldInverse.copy(source.matrixWorldInverse);
            this.projectionMatrix.copy(source.projectionMatrix);
            return this;
        };
        ;
        Camera.prototype.updateProjectionMatrix = function () { };
        ;
        return Camera;
    }(THREE.Object3D));
    THREE.Camera = Camera;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var CubeCamera = (function (_super) {
        __extends(CubeCamera, _super);
        function CubeCamera(near, far, cubeResolution) {
            _super.call(this);
            this.type = 'CubeCamera';
            var fov = 90, aspect = 1;
            var cameraPX = this.cameraPX = new THREE.PerspectiveCamera(fov, aspect, near, far);
            cameraPX.up.set(0, -1, 0);
            cameraPX.lookAt(new THREE.Vector3(1, 0, 0));
            this.add(cameraPX);
            var cameraNX = this.cameraNX = new THREE.PerspectiveCamera(fov, aspect, near, far);
            cameraNX.up.set(0, -1, 0);
            cameraNX.lookAt(new THREE.Vector3(-1, 0, 0));
            this.add(cameraNX);
            var cameraPY = this.cameraPY = new THREE.PerspectiveCamera(fov, aspect, near, far);
            cameraPY.up.set(0, 0, 1);
            cameraPY.lookAt(new THREE.Vector3(0, 1, 0));
            this.add(cameraPY);
            var cameraNY = this.cameraNY = new THREE.PerspectiveCamera(fov, aspect, near, far);
            cameraNY.up.set(0, 0, -1);
            cameraNY.lookAt(new THREE.Vector3(0, -1, 0));
            this.add(cameraNY);
            var cameraPZ = this.cameraPZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
            cameraPZ.up.set(0, -1, 0);
            cameraPZ.lookAt(new THREE.Vector3(0, 0, 1));
            this.add(cameraPZ);
            var cameraNZ = this.cameraPZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
            cameraNZ.up.set(0, -1, 0);
            cameraNZ.lookAt(new THREE.Vector3(0, 0, -1));
            this.add(cameraNZ);
            var options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };
            this.renderTarget = new THREE.WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
        }
        ;
        CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
            if (this.parent === null)
                this.updateMatrixWorld();
            var renderTarget = this.renderTarget;
            var generateMipmaps = renderTarget.texture.generateMipmaps;
            renderTarget.texture.generateMipmaps = false;
            renderTarget.activeCubeFace = 0;
            renderer.render(scene, this.cameraPX, renderTarget);
            renderTarget.activeCubeFace = 1;
            renderer.render(scene, this.cameraNX, renderTarget);
            renderTarget.activeCubeFace = 2;
            renderer.render(scene, this.cameraPY, renderTarget);
            renderTarget.activeCubeFace = 3;
            renderer.render(scene, this.cameraNY, renderTarget);
            renderTarget.activeCubeFace = 4;
            renderer.render(scene, this.cameraPZ, renderTarget);
            renderTarget.texture.generateMipmaps = generateMipmaps;
            renderTarget.activeCubeFace = 5;
            renderer.render(scene, this.cameraNZ, renderTarget);
            renderer.setRenderTarget(null);
        };
        ;
        return CubeCamera;
    }(THREE.Object3D));
    THREE.CubeCamera = CubeCamera;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var OrthographicCamera = (function (_super) {
        __extends(OrthographicCamera, _super);
        function OrthographicCamera(left, right, top, bottom, near, far) {
            _super.call(this);
            this.type = 'OrthographicCamera';
            this.zoom = 1;
            this.view = null;
            this.left = left;
            this.right = right;
            this.top = top;
            this.bottom = bottom;
            this.near = (near !== undefined) ? near : 0.1;
            this.far = (far !== undefined) ? far : 2000;
            this.updateProjectionMatrix();
        }
        ;
        OrthographicCamera.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.left = source.left;
            this.right = source.right;
            this.top = source.top;
            this.bottom = source.bottom;
            this.near = source.near;
            this.far = source.far;
            this.zoom = source.zoom;
            this.view = source.view === null ? null : Object.assign({}, source.view);
            return this;
        };
        OrthographicCamera.prototype.setViewOffset = function (fullWidth, fullHeight, x, y, width, height) {
            this.view = {
                fullWidth: fullWidth,
                fullHeight: fullHeight,
                offsetX: x,
                offsetY: y,
                width: width,
                height: height
            };
            this.updateProjectionMatrix();
        };
        OrthographicCamera.prototype.clearViewOffset = function () {
            this.view = null;
            this.updateProjectionMatrix();
        };
        OrthographicCamera.prototype.updateProjectionMatrix = function () {
            var dx = (this.right - this.left) / (2 * this.zoom);
            var dy = (this.top - this.bottom) / (2 * this.zoom);
            var cx = (this.right + this.left) / 2;
            var cy = (this.top + this.bottom) / 2;
            var left = cx - dx;
            var right = cx + dx;
            var top = cy + dy;
            var bottom = cy - dy;
            if (this.view !== null) {
                var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
                var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
                var scaleW = (this.right - this.left) / this.view.width;
                var scaleH = (this.top - this.bottom) / this.view.height;
                left += scaleW * (this.view.offsetX / zoomW);
                right = left + scaleW * (this.view.width / zoomW);
                top -= scaleH * (this.view.offsetY / zoomH);
                bottom = top - scaleH * (this.view.height / zoomH);
            }
            this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        };
        OrthographicCamera.prototype.toJSON = function (meta) {
            var data = _super.prototype.toJSON.call(this, meta);
            data.object.zoom = this.zoom;
            data.object.left = this.left;
            data.object.right = this.right;
            data.object.top = this.top;
            data.object.bottom = this.bottom;
            data.object.near = this.near;
            data.object.far = this.far;
            if (this.view !== null)
                data.object.view = Object.assign({}, this.view);
            return data;
        };
        return OrthographicCamera;
    }(THREE.Camera));
    THREE.OrthographicCamera = OrthographicCamera;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var PerspectiveCamera = (function (_super) {
        __extends(PerspectiveCamera, _super);
        function PerspectiveCamera(fov, aspect, near, far) {
            _super.call(this);
            this.type = 'PerspectiveCamera';
            this.fov = fov !== undefined ? fov : 50;
            this.zoom = 1;
            this.near = near !== undefined ? near : 0.1;
            this.far = far !== undefined ? far : 2000;
            this.focus = 10;
            this.aspect = aspect !== undefined ? aspect : 1;
            this.view = null;
            this.filmGauge = 35;
            this.filmOffset = 0;
            this.updateProjectionMatrix();
        }
        ;
        PerspectiveCamera.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.fov = source.fov;
            this.zoom = source.zoom;
            this.near = source.near;
            this.far = source.far;
            this.focus = source.focus;
            this.aspect = source.aspect;
            this.view = source.view === null ? null : Object.assign({}, source.view);
            this.filmGauge = source.filmGauge;
            this.filmOffset = source.filmOffset;
            return this;
        };
        PerspectiveCamera.prototype.setFocalLength = function (focalLength) {
            var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
            this.fov = THREE.Math.RAD2DEG * 2 * THREE.Math.atan(vExtentSlope);
            this.updateProjectionMatrix();
        };
        PerspectiveCamera.prototype.getFocalLength = function () {
            var vExtentSlope = THREE.Math.tan(THREE.Math.DEG2RAD * 0.5 * this.fov);
            return 0.5 * this.getFilmHeight() / vExtentSlope;
        };
        PerspectiveCamera.prototype.getEffectiveFOV = function () {
            return THREE.Math.RAD2DEG * 2 * THREE.Math.atan(THREE.Math.tan(THREE.Math.DEG2RAD * 0.5 * this.fov) / this.zoom);
        };
        PerspectiveCamera.prototype.getFilmWidth = function () {
            return this.filmGauge * THREE.Math.min(this.aspect, 1);
        };
        PerspectiveCamera.prototype.getFilmHeight = function () {
            return this.filmGauge / THREE.Math.max(this.aspect, 1);
        };
        PerspectiveCamera.prototype.setViewOffset = function (fullWidth, fullHeight, x, y, width, height) {
            this.aspect = fullWidth / fullHeight;
            this.view = {
                fullWidth: fullWidth,
                fullHeight: fullHeight,
                offsetX: x,
                offsetY: y,
                width: width,
                height: height
            };
            this.updateProjectionMatrix();
        };
        PerspectiveCamera.prototype.clearViewOffset = function () {
            this.view = null;
            this.updateProjectionMatrix();
        };
        PerspectiveCamera.prototype.updateProjectionMatrix = function () {
            var near = this.near, top = near * THREE.Math.tan(THREE.Math.DEG2RAD * 0.5 * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -0.5 * width, view = this.view;
            if (view !== null) {
                var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
                left += view.offsetX * width / fullWidth;
                top -= view.offsetY * height / fullHeight;
                width *= view.width / fullWidth;
                height *= view.height / fullHeight;
            }
            var skew = this.filmOffset;
            if (skew !== 0)
                left += near * skew / this.getFilmWidth();
            this.projectionMatrix.makeFrustum(left, left + width, top - height, top, near, this.far);
        };
        PerspectiveCamera.prototype.toJSON = function (meta) {
            var data = _super.prototype.toJSON.call(this, meta);
            data.object.fov = this.fov;
            data.object.zoom = this.zoom;
            data.object.near = this.near;
            data.object.far = this.far;
            data.object.focus = this.focus;
            data.object.aspect = this.aspect;
            if (this.view !== null)
                data.object.view = Object.assign({}, this.view);
            data.object.filmGauge = this.filmGauge;
            data.object.filmOffset = this.filmOffset;
            return data;
        };
        return PerspectiveCamera;
    }(THREE.Camera));
    THREE.PerspectiveCamera = PerspectiveCamera;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var StereoCamera = (function () {
        function StereoCamera() {
            this.type = 'StereoCamera';
            this.aspect = 1;
            this.cameraL = new THREE.PerspectiveCamera();
            this.cameraL.layers.enable(1);
            this.cameraL.matrixAutoUpdate = false;
            this.cameraR = new THREE.PerspectiveCamera();
            this.cameraR.layers.enable(2);
            this.cameraR.matrixAutoUpdate = false;
        }
        ;
        StereoCamera.prototype.update = function (camera) {
            var _static = StereoCamera.__update_static;
            var needsUpdate = _static.focus !== camera.focus
                || _static.fov !== camera.fov
                || _static.aspect !== camera.aspect * this.aspect
                || _static.near !== camera.near
                || _static.far !== camera.far;
            var eyeLeft = _static.eyeLeft;
            var eyeRight = _static.eyeRight;
            if (needsUpdate) {
                var focus = _static.focus = camera.focus;
                var fov = _static.fov = camera.fov;
                var aspect = _static.aspect = camera.aspect * this.aspect;
                var near = _static.near = camera.near;
                var far = _static.far = camera.far;
                var projectionMatrix = camera.projectionMatrix.clone();
                var eyeSep = 0.064 / 2;
                var eyeSepOnProjection = eyeSep * near / focus;
                var ymax = near * THREE.Math.tan(THREE.Math.DEG2RAD * fov * 0.5);
                var xmin, xmax;
                eyeLeft.elements[12] = -eyeSep;
                eyeRight.elements[12] = eyeSep;
                xmin = -ymax * aspect + eyeSepOnProjection;
                xmax = ymax * aspect + eyeSepOnProjection;
                projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                this.cameraL.projectionMatrix.copy(projectionMatrix);
                xmin = -ymax * aspect - eyeSepOnProjection;
                xmax = ymax * aspect - eyeSepOnProjection;
                projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                this.cameraR.projectionMatrix.copy(projectionMatrix);
            }
            this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
            this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
        };
        StereoCamera.__update_static = {
            focus: NaN,
            fov: NaN,
            aspect: NaN,
            near: NaN,
            far: NaN,
            eyeRight: new THREE.Matrix4(),
            eyeLeft: new THREE.Matrix4()
        };
        return StereoCamera;
    }());
    THREE.StereoCamera = StereoCamera;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var BufferAttribute = (function () {
        function BufferAttribute(array, itemSize, normalized) {
            this.dynamic = false;
            this.updateRange = { offset: 0, count: -1 };
            this.version = 0;
            this.uuid = THREE.Math.generateUUID();
            this.array = array;
            this.itemSize = itemSize;
            this.dynamic = false;
            this.updateRange = { offset: 0, count: -1 };
            this.version = 0;
            this.normalized = normalized === true;
        }
        Object.defineProperty(BufferAttribute.prototype, "count", {
            get: function () {
                return this.array.length / this.itemSize;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
            set: function (value) {
                if (value === true)
                    this.version++;
            },
            enumerable: true,
            configurable: true
        });
        BufferAttribute.prototype.setDynamic = function (value) {
            this.dynamic = value;
            return this;
        };
        BufferAttribute.prototype.copy = function (source) {
            this.array = new source.array.constructor(source.array);
            this.itemSize = source.itemSize;
            this.dynamic = source.dynamic;
            return this;
        };
        BufferAttribute.prototype.copyAt = function (index1, attribute, index2) {
            index1 *= this.itemSize;
            index2 *= attribute.itemSize;
            for (var i = 0, l = this.itemSize; i < l; i++) {
                this.array[index1 + i] = attribute.array[index2 + i];
            }
            return this;
        };
        BufferAttribute.prototype.copyArray = function (array) {
            this.array.set(array);
            return this;
        };
        BufferAttribute.prototype.copyColorsArray = function (colors) {
            var array = this.array, offset = 0;
            for (var i = 0, l = colors.length; i < l; i++) {
                var color = colors[i];
                array[offset++] = color.r;
                array[offset++] = color.g;
                array[offset++] = color.b;
            }
            return this;
        };
        BufferAttribute.prototype.copyIndicesArray = function (indices) {
            var array = this.array, offset = 0;
            for (var i = 0, l = indices.length; i < l; i++) {
                var index = indices[i];
                array[offset++] = index.a;
                array[offset++] = index.b;
                array[offset++] = index.c;
            }
            return this;
        };
        BufferAttribute.prototype.copyVector2sArray = function (vectors) {
            var array = this.array, offset = 0;
            for (var i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                array[offset++] = vector.x;
                array[offset++] = vector.y;
            }
            return this;
        };
        BufferAttribute.prototype.copyVector3sArray = function (vectors) {
            var array = this.array, offset = 0;
            for (var i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                array[offset++] = vector.x;
                array[offset++] = vector.y;
                array[offset++] = vector.z;
            }
            return this;
        };
        BufferAttribute.prototype.copyVector4sArray = function (vectors) {
            var array = this.array, offset = 0;
            for (var i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                array[offset++] = vector.x;
                array[offset++] = vector.y;
                array[offset++] = vector.z;
                array[offset++] = vector.w;
            }
            return this;
        };
        BufferAttribute.prototype.set = function (value, offset) {
            if (offset === undefined)
                offset = 0;
            this.array.set(value, offset);
            return this;
        };
        BufferAttribute.prototype.getX = function (index) {
            return this.array[index * this.itemSize];
        };
        BufferAttribute.prototype.setX = function (index, x) {
            this.array[index * this.itemSize] = x;
            return this;
        };
        BufferAttribute.prototype.getY = function (index) {
            return this.array[index * this.itemSize + 1];
        };
        BufferAttribute.prototype.setY = function (index, y) {
            this.array[index * this.itemSize + 1] = y;
            return this;
        };
        BufferAttribute.prototype.getZ = function (index) {
            return this.array[index * this.itemSize + 2];
        };
        BufferAttribute.prototype.setZ = function (index, z) {
            this.array[index * this.itemSize + 2] = z;
            return this;
        };
        BufferAttribute.prototype.getW = function (index) {
            return this.array[index * this.itemSize + 3];
        };
        BufferAttribute.prototype.setW = function (index, w) {
            this.array[index * this.itemSize + 3] = w;
            return this;
        };
        BufferAttribute.prototype.setXY = function (index, x, y) {
            index *= this.itemSize;
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            return this;
        };
        BufferAttribute.prototype.setXYZ = function (index, x, y, z) {
            index *= this.itemSize;
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            this.array[index + 2] = z;
            return this;
        };
        BufferAttribute.prototype.setXYZW = function (index, x, y, z, w) {
            index *= this.itemSize;
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            this.array[index + 2] = z;
            this.array[index + 3] = w;
            return this;
        };
        BufferAttribute.prototype.clone = function () {
            return new this.constructor().copy(this);
        };
        return BufferAttribute;
    }());
    THREE.BufferAttribute = BufferAttribute;
    ;
    var Int8Attribute = (function (_super) {
        __extends(Int8Attribute, _super);
        function Int8Attribute(array, itemSize) {
            _super.call(this, new Int8Array(array), itemSize);
        }
        ;
        return Int8Attribute;
    }(BufferAttribute));
    THREE.Int8Attribute = Int8Attribute;
    var Uint8Attribut = (function (_super) {
        __extends(Uint8Attribut, _super);
        function Uint8Attribut(array, itemSize) {
            _super.call(this, new Uint8Array(array), itemSize);
        }
        ;
        return Uint8Attribut;
    }(BufferAttribute));
    THREE.Uint8Attribut = Uint8Attribut;
    var Uint8ClampedAttribute = (function (_super) {
        __extends(Uint8ClampedAttribute, _super);
        function Uint8ClampedAttribute(array, itemSize) {
            _super.call(this, new Uint8ClampedArray(array), itemSize);
        }
        ;
        return Uint8ClampedAttribute;
    }(BufferAttribute));
    THREE.Uint8ClampedAttribute = Uint8ClampedAttribute;
    var Int16Attribute = (function (_super) {
        __extends(Int16Attribute, _super);
        function Int16Attribute(array, itemSize) {
            _super.call(this, new Int16Array(array), itemSize);
        }
        ;
        return Int16Attribute;
    }(BufferAttribute));
    THREE.Int16Attribute = Int16Attribute;
    var Uint16Attribute = (function (_super) {
        __extends(Uint16Attribute, _super);
        function Uint16Attribute(array, itemSize) {
            _super.call(this, new Uint16Array(array), itemSize);
        }
        ;
        return Uint16Attribute;
    }(BufferAttribute));
    THREE.Uint16Attribute = Uint16Attribute;
    var Int32Attribute = (function (_super) {
        __extends(Int32Attribute, _super);
        function Int32Attribute(array, itemSize) {
            _super.call(this, new Int32Array(array), itemSize);
        }
        ;
        return Int32Attribute;
    }(BufferAttribute));
    THREE.Int32Attribute = Int32Attribute;
    var Uint32Attribute = (function (_super) {
        __extends(Uint32Attribute, _super);
        function Uint32Attribute(array, itemSize) {
            _super.call(this, new Uint32Array(array), itemSize);
        }
        ;
        return Uint32Attribute;
    }(BufferAttribute));
    THREE.Uint32Attribute = Uint32Attribute;
    var Float32Attribute = (function (_super) {
        __extends(Float32Attribute, _super);
        function Float32Attribute(array, itemSize) {
            if (typeof array === "number")
                _super.call(this, new Float32Array(array), itemSize);
            else
                _super.call(this, new Float32Array(array), itemSize);
        }
        ;
        return Float32Attribute;
    }(BufferAttribute));
    THREE.Float32Attribute = Float32Attribute;
    var Float64Attribute = (function (_super) {
        __extends(Float64Attribute, _super);
        function Float64Attribute(array, itemSize) {
            _super.call(this, new Float64Array(array), itemSize);
        }
        ;
        return Float64Attribute;
    }(BufferAttribute));
    THREE.Float64Attribute = Float64Attribute;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Geometry = (function (_super) {
        __extends(Geometry, _super);
        function Geometry() {
            _super.apply(this, arguments);
            this._id = THREE.GeometryIdCount++;
            this.uuid = THREE.Math.generateUUID();
            this.name = '';
            this.type = 'Geometry';
            this.vertices = [];
            this.colors = [];
            this.faces = [];
            this.faceVertexUvs = [[]];
            this.morphTargets = [];
            this.morphNormals = [];
            this.skinWeights = [];
            this.skinIndices = [];
            this.lineDistances = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            this.elementsNeedUpdate = false;
            this.verticesNeedUpdate = false;
            this.uvsNeedUpdate = false;
            this.normalsNeedUpdate = false;
            this.colorsNeedUpdate = false;
            this.lineDistancesNeedUpdate = false;
            this.groupsNeedUpdate = false;
        }
        Object.defineProperty(Geometry.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Geometry.prototype.applyMatrix = function (matrix) {
            var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
            for (var i = 0, il = this.vertices.length; i < il; i++) {
                var vertex = this.vertices[i];
                vertex.applyMatrix4(matrix);
            }
            for (var i = 0, il = this.faces.length; i < il; i++) {
                var face = this.faces[i];
                face.normal.applyMatrix3(normalMatrix).normalize();
                for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                    face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
                }
            }
            if (this.boundingBox !== null) {
                this.computeBoundingBox();
            }
            if (this.boundingSphere !== null) {
                this.computeBoundingSphere();
            }
            this.verticesNeedUpdate = true;
            this.normalsNeedUpdate = true;
            return this;
        };
        Geometry.prototype.rotateX = function (angle) {
            var m1 = Geometry[".rotateX.m1"] || (Geometry[".rotateX.m1"] = new THREE.Matrix4());
            m1.makeRotationX(angle);
            this.applyMatrix(m1);
            return this;
        };
        Geometry.prototype.rotateY = function (angle) {
            var m1 = Geometry[".rotateY.m1"] || (Geometry[".rotateY.m1"] = new THREE.Matrix4());
            m1.makeRotationY(angle);
            this.applyMatrix(m1);
            return this;
        };
        Geometry.prototype.rotateZ = function (angle) {
            var m1 = Geometry[".rotateZ.m1"] || (Geometry[".rotateZ.m1"] = new THREE.Matrix4());
            m1.makeRotationZ(angle);
            this.applyMatrix(m1);
            return this;
        };
        Geometry.prototype.translate = function (x, y, z) {
            var m1 = Geometry[".translate.m1"] || (Geometry[".translate.m1"] = new THREE.Matrix4());
            m1.makeTranslation(x, y, z);
            this.applyMatrix(m1);
            return this;
        };
        Geometry.prototype.scale = function (x, y, z) {
            var m1 = Geometry[".scale.m1"] || (Geometry[".scale.m1"] = new THREE.Matrix4());
            m1.makeScale(x, y, z);
            this.applyMatrix(m1);
            return this;
        };
        Geometry.prototype.lookAt = function (vector) {
            var obj = Geometry[".obj.m1"] || (Geometry[".obj.m1"] = new THREE.Object3D());
            obj.lookAt(vector);
            obj.updateMatrix();
            this.applyMatrix(obj.matrix);
        };
        Geometry.prototype.fromBufferGeometry = function (geometry) {
            var scope = this;
            var indices = geometry.index !== null ? geometry.index.array : undefined;
            var attributes = geometry.attributes;
            var positions = attributes.position.array;
            var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
            var colors = attributes.color !== undefined ? attributes.color.array : undefined;
            var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
            var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
            if (uvs2 !== undefined)
                this.faceVertexUvs[1] = [];
            var tempNormals = [];
            var tempUVs = [];
            var tempUVs2 = [];
            for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {
                scope.vertices.push(new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]));
                if (normals !== undefined) {
                    tempNormals.push(new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]));
                }
                if (colors !== undefined) {
                    scope.colors.push(new THREE.Color(colors[i], colors[i + 1], colors[i + 2]));
                }
                if (uvs !== undefined) {
                    tempUVs.push(new THREE.Vector2(uvs[j], uvs[j + 1]));
                }
                if (uvs2 !== undefined) {
                    tempUVs2.push(new THREE.Vector2(uvs2[j], uvs2[j + 1]));
                }
            }
            var addFace = function (a, b, c, materialIndex) {
                var vertexNormals = normals !== undefined ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];
                var vertexColors = colors !== undefined ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];
                var face = new THREE.Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
                scope.faces.push(face);
                if (uvs !== undefined) {
                    scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]);
                }
                if (uvs2 !== undefined) {
                    scope.faceVertexUvs[1].push([tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone()]);
                }
            };
            if (indices !== undefined) {
                var groups = geometry.groups;
                if (groups.length > 0) {
                    for (var i = 0; i < groups.length; i++) {
                        var group = groups[i];
                        var start = group.start;
                        var count = group.count;
                        for (var j = start, jl = start + count; j < jl; j += 3) {
                            addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
                        }
                    }
                }
                else {
                    for (var i = 0; i < indices.length; i += 3) {
                        addFace(indices[i], indices[i + 1], indices[i + 2]);
                    }
                }
            }
            else {
                for (var i = 0; i < positions.length / 3; i += 3) {
                    addFace(i, i + 1, i + 2);
                }
            }
            this.computeFaceNormals();
            if (geometry.boundingBox !== null) {
                this.boundingBox = geometry.boundingBox.clone();
            }
            if (geometry.boundingSphere !== null) {
                this.boundingSphere = geometry.boundingSphere.clone();
            }
            return this;
        };
        Geometry.prototype.center = function () {
            this.computeBoundingBox();
            var offset = this.boundingBox.center().negate();
            this.translate(offset.x, offset.y, offset.z);
            return offset;
        };
        Geometry.prototype.normalize = function () {
            this.computeBoundingSphere();
            var center = this.boundingSphere.center;
            var radius = this.boundingSphere.radius;
            var s = radius === 0 ? 1 : 1.0 / radius;
            var matrix = new THREE.Matrix4();
            matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
            this.applyMatrix(matrix);
            return this;
        };
        Geometry.prototype.computeFaceNormals = function () {
            var cb = new THREE.Vector3(), ab = new THREE.Vector3();
            for (var f = 0, fl = this.faces.length; f < fl; f++) {
                var face = this.faces[f];
                var vA = this.vertices[face.a];
                var vB = this.vertices[face.b];
                var vC = this.vertices[face.c];
                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                cb.cross(ab);
                cb.normalize();
                face.normal.copy(cb);
            }
        };
        Geometry.prototype.computeVertexNormals = function (areaWeighted) {
            if (areaWeighted === void 0) { areaWeighted = true; }
            var v, vl, f, fl, face, vertices;
            vertices = new Array(this.vertices.length);
            for (v = 0, vl = this.vertices.length; v < vl; v++) {
                vertices[v] = new THREE.Vector3();
            }
            if (areaWeighted) {
                var vA, vB, vC;
                var cb = new THREE.Vector3(), ab = new THREE.Vector3();
                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];
                    vA = this.vertices[face.a];
                    vB = this.vertices[face.b];
                    vC = this.vertices[face.c];
                    cb.subVectors(vC, vB);
                    ab.subVectors(vA, vB);
                    cb.cross(ab);
                    vertices[face.a].add(cb);
                    vertices[face.b].add(cb);
                    vertices[face.c].add(cb);
                }
            }
            else {
                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];
                    vertices[face.a].add(face.normal);
                    vertices[face.b].add(face.normal);
                    vertices[face.c].add(face.normal);
                }
            }
            for (v = 0, vl = this.vertices.length; v < vl; v++) {
                vertices[v].normalize();
            }
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                var vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                    vertexNormals[0].copy(vertices[face.a]);
                    vertexNormals[1].copy(vertices[face.b]);
                    vertexNormals[2].copy(vertices[face.c]);
                }
                else {
                    vertexNormals[0] = vertices[face.a].clone();
                    vertexNormals[1] = vertices[face.b].clone();
                    vertexNormals[2] = vertices[face.c].clone();
                }
            }
            if (this.faces.length > 0) {
                this.normalsNeedUpdate = true;
            }
        };
        Geometry.prototype.computeMorphNormals = function () {
            var i, il, f, fl, face;
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                if (!face.__originalFaceNormal) {
                    face.__originalFaceNormal = face.normal.clone();
                }
                else {
                    face.__originalFaceNormal.copy(face.normal);
                }
                if (!face.__originalVertexNormals)
                    face.__originalVertexNormals = [];
                for (i = 0, il = face.vertexNormals.length; i < il; i++) {
                    if (!face.__originalVertexNormals[i]) {
                        face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
                    }
                    else {
                        face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
                    }
                }
            }
            var tmpGeo = new Geometry();
            tmpGeo.faces = this.faces;
            for (i = 0, il = this.morphTargets.length; i < il; i++) {
                if (!this.morphNormals[i]) {
                    this.morphNormals[i] = {};
                    this.morphNormals[i].faceNormals = [];
                    this.morphNormals[i].vertexNormals = [];
                    var dstNormalsFace = this.morphNormals[i].faceNormals;
                    var dstNormalsVertex = this.morphNormals[i].vertexNormals;
                    var faceNormal;
                    var vertexNormals;
                    for (f = 0, fl = this.faces.length; f < fl; f++) {
                        faceNormal = new THREE.Vector3();
                        vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };
                        dstNormalsFace.push(faceNormal);
                        dstNormalsVertex.push(vertexNormals);
                    }
                }
                var morphNormals = this.morphNormals[i];
                tmpGeo.vertices = this.morphTargets[i].vertices;
                tmpGeo.computeFaceNormals();
                tmpGeo.computeVertexNormals();
                var faceNormal;
                var vertexNormals;
                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];
                    faceNormal = morphNormals.faceNormals[f];
                    vertexNormals = morphNormals.vertexNormals[f];
                    faceNormal.copy(face.normal);
                    vertexNormals.a.copy(face.vertexNormals[0]);
                    vertexNormals.b.copy(face.vertexNormals[1]);
                    vertexNormals.c.copy(face.vertexNormals[2]);
                }
            }
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                face.normal = face.__originalFaceNormal;
                face.vertexNormals = face.__originalVertexNormals;
            }
        };
        Geometry.prototype.computeLineDistances = function () {
            var d = 0;
            var vertices = this.vertices;
            for (var i = 0, il = vertices.length; i < il; i++) {
                if (i > 0) {
                    d += vertices[i].distanceTo(vertices[i - 1]);
                }
                this.lineDistances[i] = d;
            }
        };
        Geometry.prototype.computeBoundingBox = function () {
            if (this.boundingBox === null) {
                this.boundingBox = new THREE.Box3();
            }
            this.boundingBox.setFromPoints(this.vertices);
        };
        Geometry.prototype.computeBoundingSphere = function () {
            if (this.boundingSphere === null) {
                this.boundingSphere = new THREE.Sphere();
            }
            this.boundingSphere.setFromPoints(this.vertices);
        };
        Geometry.prototype.merge = function (geometry, matrix, materialIndexOffset) {
            if (materialIndexOffset === void 0) { materialIndexOffset = 0; }
            var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry.faceVertexUvs[0];
            if (matrix !== undefined) {
                normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
            }
            for (var i = 0, il = vertices2.length; i < il; i++) {
                var vertex = vertices2[i];
                var vertexCopy = vertex.clone();
                if (matrix !== undefined)
                    vertexCopy.applyMatrix4(matrix);
                vertices1.push(vertexCopy);
            }
            for (i = 0, il = faces2.length; i < il; i++) {
                var face = faces2[i], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
                faceCopy = new THREE.Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
                faceCopy.normal.copy(face.normal);
                if (normalMatrix !== undefined) {
                    faceCopy.normal.applyMatrix3(normalMatrix).normalize();
                }
                for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
                    normal = faceVertexNormals[j].clone();
                    if (normalMatrix !== undefined) {
                        normal.applyMatrix3(normalMatrix).normalize();
                    }
                    faceCopy.vertexNormals.push(normal);
                }
                faceCopy.color.copy(face.color);
                for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
                    color = faceVertexColors[j];
                    faceCopy.vertexColors.push(color.clone());
                }
                faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
                faces1.push(faceCopy);
            }
            for (i = 0, il = uvs2.length; i < il; i++) {
                var uv = uvs2[i], uvCopy = [];
                if (uv === undefined) {
                    continue;
                }
                for (var j = 0, jl = uv.length; j < jl; j++) {
                    uvCopy.push(uv[j].clone());
                }
                uvs1.push(uvCopy);
            }
        };
        Geometry.prototype.mergeMesh = function (mesh) {
            mesh.matrixAutoUpdate && mesh.updateMatrix();
            this.merge(mesh.geometry, mesh.matrix);
        };
        Geometry.prototype.mergeVertices = function () {
            var verticesMap = {};
            var unique = [], changes = [];
            var v, key;
            var precisionPoints = 4;
            var precision = THREE.Math.pow(10, precisionPoints);
            var i, il, face;
            var indices, j, jl;
            for (i = 0, il = this.vertices.length; i < il; i++) {
                v = this.vertices[i];
                key = THREE.Math.round(v.x * precision) + '_' + THREE.Math.round(v.y * precision) + '_' + THREE.Math.round(v.z * precision);
                if (verticesMap[key] === undefined) {
                    verticesMap[key] = i;
                    unique.push(this.vertices[i]);
                    changes[i] = unique.length - 1;
                }
                else {
                    changes[i] = changes[verticesMap[key]];
                }
            }
            var faceIndicesToRemove = [];
            for (i = 0, il = this.faces.length; i < il; i++) {
                face = this.faces[i];
                face.a = changes[face.a];
                face.b = changes[face.b];
                face.c = changes[face.c];
                indices = [face.a, face.b, face.c];
                var dupIndex = -1;
                for (var n = 0; n < 3; n++) {
                    if (indices[n] === indices[(n + 1) % 3]) {
                        dupIndex = n;
                        faceIndicesToRemove.push(i);
                        break;
                    }
                }
            }
            for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
                var idx = faceIndicesToRemove[i];
                this.faces.splice(idx, 1);
                for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
                    this.faceVertexUvs[j].splice(idx, 1);
                }
            }
            var diff = this.vertices.length - unique.length;
            this.vertices = unique;
            return diff;
        };
        Geometry.prototype.sortFacesByMaterialIndex = function () {
            var faces = this.faces;
            var length = faces.length;
            for (var i = 0; i < length; i++) {
                faces[i]._id = i;
            }
            function materialIndexSort(a, b) {
                return a.materialIndex - b.materialIndex;
            }
            faces.sort(materialIndexSort);
            var uvs1 = this.faceVertexUvs[0];
            var uvs2 = this.faceVertexUvs[1];
            var newUvs1, newUvs2;
            if (uvs1 && uvs1.length === length)
                newUvs1 = [];
            if (uvs2 && uvs2.length === length)
                newUvs2 = [];
            for (var i = 0; i < length; i++) {
                var id = faces[i]._id;
                if (newUvs1)
                    newUvs1.push(uvs1[id]);
                if (newUvs2)
                    newUvs2.push(uvs2[id]);
            }
            if (newUvs1)
                this.faceVertexUvs[0] = newUvs1;
            if (newUvs2)
                this.faceVertexUvs[1] = newUvs2;
        };
        Geometry.prototype.toJSON = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var data = {
                metadata: {
                    version: 4.4,
                    type: 'Geometry',
                    generator: 'Geometry.toJSON'
                }
            };
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '')
                data.name = this.name;
            if (this.parameters !== undefined) {
                var parameters = this.parameters;
                for (var key in parameters) {
                    if (parameters[key] !== undefined)
                        data[key] = parameters[key];
                }
                return data;
            }
            var vertices = [];
            for (var i = 0; i < this.vertices.length; i++) {
                var vertex = this.vertices[i];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
            var faces = [];
            var normals = [];
            var normalsHash = {};
            var colors = [];
            var colorsHash = {};
            var uvs = [];
            var uvsHash = {};
            for (var i = 0; i < this.faces.length; i++) {
                var face = this.faces[i];
                var hasMaterial = true;
                var hasFaceUv = false;
                var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
                var hasFaceNormal = face.normal.length() > 0;
                var hasFaceVertexNormal = face.vertexNormals.length > 0;
                var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
                var hasFaceVertexColor = face.vertexColors.length > 0;
                var faceType = 0;
                faceType = setBit(faceType, 0, false);
                faceType = setBit(faceType, 1, hasMaterial);
                faceType = setBit(faceType, 2, hasFaceUv);
                faceType = setBit(faceType, 3, hasFaceVertexUv);
                faceType = setBit(faceType, 4, hasFaceNormal);
                faceType = setBit(faceType, 5, hasFaceVertexNormal);
                faceType = setBit(faceType, 6, hasFaceColor);
                faceType = setBit(faceType, 7, hasFaceVertexColor);
                faces.push(faceType);
                faces.push(face.a, face.b, face.c);
                faces.push(face.materialIndex);
                if (hasFaceVertexUv) {
                    var faceVertexUvs = this.faceVertexUvs[0][i];
                    faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
                }
                if (hasFaceNormal) {
                    faces.push(getNormalIndex(face.normal));
                }
                if (hasFaceVertexNormal) {
                    var vertexNormals = face.vertexNormals;
                    faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
                }
                if (hasFaceColor) {
                    faces.push(getColorIndex(face.color));
                }
                if (hasFaceVertexColor) {
                    var vertexColors = face.vertexColors;
                    faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
                }
            }
            function setBit(value, position, enabled) {
                return enabled ? value | (1 << position) : value & (~(1 << position));
            }
            function getNormalIndex(normal) {
                var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
                if (normalsHash[hash] !== undefined) {
                    return normalsHash[hash];
                }
                normalsHash[hash] = normals.length / 3;
                normals.push(normal.x, normal.y, normal.z);
                return normalsHash[hash];
            }
            function getColorIndex(color) {
                var hash = color.r.toString() + color.g.toString() + color.b.toString();
                if (colorsHash[hash] !== undefined) {
                    return colorsHash[hash];
                }
                colorsHash[hash] = colors.length;
                colors.push(color.getHex());
                return colorsHash[hash];
            }
            function getUvIndex(uv) {
                var hash = uv.x.toString() + uv.y.toString();
                if (uvsHash[hash] !== undefined) {
                    return uvsHash[hash];
                }
                uvsHash[hash] = uvs.length / 2;
                uvs.push(uv.x, uv.y);
                return uvsHash[hash];
            }
            data.data = {};
            data.data.vertices = vertices;
            data.data.normals = normals;
            if (colors.length > 0)
                data.data.colors = colors;
            if (uvs.length > 0)
                data.data.uvs = [uvs];
            data.data.faces = faces;
            return data;
        };
        Geometry.prototype.clone = function () {
            return new Geometry().copy(this);
        };
        Geometry.prototype.copy = function (source) {
            this.vertices = [];
            this.faces = [];
            this.faceVertexUvs = [[]];
            var vertices = source.vertices;
            for (var i = 0, il = vertices.length; i < il; i++) {
                this.vertices.push(vertices[i].clone());
            }
            var faces = source.faces;
            for (var i = 0, il = faces.length; i < il; i++) {
                this.faces.push(faces[i].clone());
            }
            for (var i = 0, il = source.faceVertexUvs.length; i < il; i++) {
                var faceVertexUvs = source.faceVertexUvs[i];
                if (this.faceVertexUvs[i] === undefined) {
                    this.faceVertexUvs[i] = [];
                }
                for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {
                    var uvs = faceVertexUvs[j], uvsCopy = [];
                    for (var k = 0, kl = uvs.length; k < kl; k++) {
                        var uv = uvs[k];
                        uvsCopy.push(uv.clone());
                    }
                    this.faceVertexUvs[i].push(uvsCopy);
                }
            }
            return this;
        };
        Geometry.prototype.dispose = function () {
            this.dispatchEvent({ type: 'dispose' });
        };
        return Geometry;
    }(THREE.EventDispatcher));
    THREE.Geometry = Geometry;
    THREE.GeometryIdCount = 0;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var BufferGeometry = (function (_super) {
        __extends(BufferGeometry, _super);
        function BufferGeometry() {
            _super.call(this);
            this.type = 'BufferGeometry';
            this.index = null;
            this.attributes = {};
            this.morphAttributes = {};
            this.groups = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            this.drawRange = { start: 0, count: Infinity };
            this._id = THREE.GeometryIdCount++;
        }
        Object.defineProperty(BufferGeometry.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        BufferGeometry.prototype.getIndex = function () {
            return this.index;
        };
        BufferGeometry.prototype.setIndex = function (index) {
            this.index = index;
        };
        BufferGeometry.prototype.addAttribute = function (name, attribute) {
            this.attributes[name] = attribute;
            return this;
        };
        BufferGeometry.prototype.getAttribute = function (name) {
            return this.attributes[name];
        };
        BufferGeometry.prototype.removeAttribute = function (name) {
            delete this.attributes[name];
            return this;
        };
        BufferGeometry.prototype.addGroup = function (start, count, materialIndex) {
            if (materialIndex === void 0) { materialIndex = 0; }
            this.groups.push({
                start: start,
                count: count,
                materialIndex: materialIndex
            });
        };
        BufferGeometry.prototype.clearGroups = function () {
            this.groups = [];
        };
        BufferGeometry.prototype.setDrawRange = function (start, count) {
            this.drawRange.start = start;
            this.drawRange.count = count;
        };
        BufferGeometry.prototype.applyMatrix = function (matrix) {
            var position = this.attributes.position;
            if (position !== undefined) {
                matrix.applyToVector3Array(position.array);
                position.needsUpdate = true;
            }
            var normal = this.attributes.normal;
            if (normal !== undefined) {
                var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
                normalMatrix.applyToVector3Array(normal.array);
                normal.needsUpdate = true;
            }
            if (this.boundingBox !== null) {
                this.computeBoundingBox();
            }
            if (this.boundingSphere !== null) {
                this.computeBoundingSphere();
            }
            return this;
        };
        BufferGeometry.prototype.rotateX = function (angle) {
            var m1 = BufferGeometry[".rotateX.m1"] || (BufferGeometry[".rotateX.m1"] = new THREE.Matrix4());
            m1.makeRotationX(angle);
            this.applyMatrix(m1);
            return this;
        };
        BufferGeometry.prototype.rotateY = function (angle) {
            var m1 = BufferGeometry[".rotateY.m1"] || (BufferGeometry[".rotateY.m1"] = new THREE.Matrix4());
            m1.makeRotationY(angle);
            this.applyMatrix(m1);
            return this;
        };
        BufferGeometry.prototype.rotateZ = function (angle) {
            var m1 = BufferGeometry[".rotateZ.m1"] || (BufferGeometry[".rotateZ.m1"] = new THREE.Matrix4());
            m1.makeRotationZ(angle);
            this.applyMatrix(m1);
            return this;
        };
        BufferGeometry.prototype.translate = function (x, y, z) {
            var m1 = BufferGeometry[".translate.m1"] || (BufferGeometry[".translate.m1"] = new THREE.Matrix4());
            m1.makeTranslation(x, y, z);
            this.applyMatrix(m1);
            return this;
        };
        BufferGeometry.prototype.scale = function (x, y, z) {
            var m1 = BufferGeometry[".scale.m1"] || (BufferGeometry[".scale.m1"] = new THREE.Matrix4());
            m1.makeScale(x, y, z);
            this.applyMatrix(m1);
            return this;
        };
        BufferGeometry.prototype.lookAt = function (vector) {
            var obj = BufferGeometry[".lookAt.obj"] || (BufferGeometry[".lookAt.obj"] = new THREE.Object3D());
            obj.lookAt(vector);
            obj.updateMatrix();
            return this.applyMatrix(obj.matrix);
        };
        BufferGeometry.prototype.center = function () {
            this.computeBoundingBox();
            var offset = this.boundingBox.center().negate();
            this.translate(offset.x, offset.y, offset.z);
            return offset;
        };
        BufferGeometry.prototype.setFromObject = function (object) {
            var geometry = object.geometry;
            if (object instanceof THREE.Points || object instanceof THREE.Line) {
                var positions = new THREE.Float32Attribute(geometry.vertices.length * 3, 3);
                var colors = new THREE.Float32Attribute(geometry.colors.length * 3, 3);
                this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
                this.addAttribute('color', colors.copyColorsArray(geometry.colors));
                if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                    var lineDistances = new THREE.Float32Attribute(geometry.lineDistances.length, 1);
                    this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
                }
                if (geometry.boundingSphere !== null) {
                    this.boundingSphere = geometry.boundingSphere.clone();
                }
                if (geometry.boundingBox !== null) {
                    this.boundingBox = geometry.boundingBox.clone();
                }
            }
            else if (object instanceof THREE.Mesh) {
                if (geometry instanceof THREE.Geometry) {
                    this.fromGeometry(geometry);
                }
            }
            return this;
        };
        BufferGeometry.prototype.updateFromObject = function (object) {
            var geometry = object.geometry;
            if (object instanceof THREE.Mesh) {
                var direct = geometry.__directGeometry;
                if (direct === undefined || geometry.elementsNeedUpdate === true) {
                    return this.fromGeometry(geometry);
                }
                direct.verticesNeedUpdate = geometry.verticesNeedUpdate || geometry.elementsNeedUpdate;
                direct.normalsNeedUpdate = geometry.normalsNeedUpdate || geometry.elementsNeedUpdate;
                direct.colorsNeedUpdate = geometry.colorsNeedUpdate || geometry.elementsNeedUpdate;
                direct.uvsNeedUpdate = geometry.uvsNeedUpdate || geometry.elementsNeedUpdate;
                direct.groupsNeedUpdate = geometry.groupsNeedUpdate || geometry.elementsNeedUpdate;
                geometry.elementsNeedUpdate = false;
                geometry.verticesNeedUpdate = false;
                geometry.normalsNeedUpdate = false;
                geometry.colorsNeedUpdate = false;
                geometry.uvsNeedUpdate = false;
                geometry.groupsNeedUpdate = false;
                geometry = direct;
            }
            var attribute;
            if (geometry.verticesNeedUpdate === true) {
                attribute = this.attributes.position;
                if (attribute !== undefined) {
                    attribute.copyVector3sArray(geometry.vertices);
                    attribute.needsUpdate = true;
                }
                geometry.verticesNeedUpdate = false;
            }
            if (geometry.normalsNeedUpdate === true) {
                attribute = this.attributes.normal;
                if (attribute !== undefined) {
                    attribute.copyVector3sArray(geometry.normals);
                    attribute.needsUpdate = true;
                }
                geometry.normalsNeedUpdate = false;
            }
            if (geometry.colorsNeedUpdate === true) {
                attribute = this.attributes.color;
                if (attribute !== undefined) {
                    attribute.copyColorsArray(geometry.colors);
                    attribute.needsUpdate = true;
                }
                geometry.colorsNeedUpdate = false;
            }
            if (geometry.uvsNeedUpdate) {
                attribute = this.attributes.uv;
                if (attribute !== undefined) {
                    attribute.copyVector2sArray(geometry.uvs);
                    attribute.needsUpdate = true;
                }
                geometry.uvsNeedUpdate = false;
            }
            if (geometry.lineDistancesNeedUpdate) {
                attribute = this.attributes.lineDistance;
                if (attribute !== undefined) {
                    attribute.copyArray(geometry.lineDistances);
                    attribute.needsUpdate = true;
                }
                geometry.lineDistancesNeedUpdate = false;
            }
            if (geometry.groupsNeedUpdate) {
                geometry.computeGroups(object.geometry);
                this.groups = geometry.groups;
                geometry.groupsNeedUpdate = false;
            }
            return this;
        };
        BufferGeometry.prototype.fromGeometry = function (geometry) {
            geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry(geometry);
            return this.fromDirectGeometry(geometry.__directGeometry);
        };
        BufferGeometry.prototype.fromDirectGeometry = function (geometry) {
            var positions = new Float32Array(geometry.vertices.length * 3);
            this.addAttribute('position', new THREE.BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
            if (geometry.normals.length > 0) {
                var normals = new Float32Array(geometry.normals.length * 3);
                this.addAttribute('normal', new THREE.BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
            }
            if (geometry.colors.length > 0) {
                var colors = new Float32Array(geometry.colors.length * 3);
                this.addAttribute('color', new THREE.BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
            }
            if (geometry.uvs.length > 0) {
                var uvs = new Float32Array(geometry.uvs.length * 2);
                this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
            }
            if (geometry.uvs2.length > 0) {
                var uvs2 = new Float32Array(geometry.uvs2.length * 2);
                this.addAttribute('uv2', new THREE.BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
            }
            if (geometry.indices.length > 0) {
                var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
                var indices = new TypeArray(geometry.indices.length * 3);
                this.setIndex(new THREE.BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));
            }
            this.groups = geometry.groups;
            for (var name in geometry.morphTargets) {
                var array = [];
                var morphTargets = geometry.morphTargets[name];
                for (var i = 0, l = morphTargets.length; i < l; i++) {
                    var morphTarget = morphTargets[i];
                    var attribute = new THREE.Float32Attribute(morphTarget.length * 3, 3);
                    array.push(attribute.copyVector3sArray(morphTarget));
                }
                this.morphAttributes[name] = array;
            }
            if (geometry.skinIndices.length > 0) {
                var skinIndices = new THREE.Float32Attribute(geometry.skinIndices.length * 4, 4);
                this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
            }
            if (geometry.skinWeights.length > 0) {
                var skinWeights = new THREE.Float32Attribute(geometry.skinWeights.length * 4, 4);
                this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
            }
            if (geometry.boundingSphere !== null) {
                this.boundingSphere = geometry.boundingSphere.clone();
            }
            if (geometry.boundingBox !== null) {
                this.boundingBox = geometry.boundingBox.clone();
            }
            return this;
        };
        BufferGeometry.prototype.computeBoundingBox = function () {
            if (this.boundingBox === null) {
                this.boundingBox = new THREE.Box3();
            }
            var positions = this.attributes.position.array;
            if (positions !== undefined) {
                this.boundingBox.setFromArray(positions);
            }
            else {
                this.boundingBox.makeEmpty();
            }
            if (isNaN(this.boundingBox.min.x)
                || isNaN(this.boundingBox.min.y)
                || isNaN(this.boundingBox.min.z)) {
                console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
            }
        };
        BufferGeometry.prototype.computeBoundingSphere = function () {
            var box = new THREE.Box3();
            var vector = new THREE.Vector3();
            var func = BufferGeometry.prototype.computeBoundingSphere = function () {
                if (this.boundingSphere === null) {
                    this.boundingSphere = new THREE.Sphere();
                }
                var positions = this.attributes.position;
                if (positions) {
                    var array = positions.array;
                    var center = this.boundingSphere.center;
                    box.setFromArray(array);
                    box.center(center);
                    var maxRadiusSq = 0;
                    for (var i = 0, il = array.length; i < il; i += 3) {
                        vector.fromArray(array, i);
                        maxRadiusSq = THREE.Math.max(maxRadiusSq, center.distanceToSquared(vector));
                    }
                    this.boundingSphere.radius = THREE.Math.sqrt(maxRadiusSq);
                    if (isNaN(this.boundingSphere.radius)) {
                        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                    }
                }
            };
            func.call(this);
        };
        BufferGeometry.prototype.computeFaceNormals = function () {
        };
        BufferGeometry.prototype.computeVertexNormals = function () {
            var index = this.index;
            var attributes = this.attributes;
            var groups = this.groups;
            if (attributes.position) {
                var positions = attributes.position.array;
                if (attributes.normal === undefined) {
                    this.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(positions.length), 3));
                }
                else {
                    var array = attributes.normal.array;
                    for (var i = 0, il = array.length; i < il; i++) {
                        array[i] = 0;
                    }
                }
                var normals = attributes.normal.array;
                var vA, vB, vC, pA = new THREE.Vector3(), pB = new THREE.Vector3(), pC = new THREE.Vector3(), cb = new THREE.Vector3(), ab = new THREE.Vector3();
                if (index) {
                    var indices = index.array;
                    if (groups.length === 0) {
                        this.addGroup(0, indices.length);
                    }
                    for (var j = 0, jl = groups.length; j < jl; ++j) {
                        var group = groups[j];
                        var start = group.start;
                        var count = group.count;
                        for (var i_2 = start, il_2 = start + count; i_2 < il_2; i_2 += 3) {
                            vA = indices[i_2 + 0] * 3;
                            vB = indices[i_2 + 1] * 3;
                            vC = indices[i_2 + 2] * 3;
                            pA.fromArray(positions, vA);
                            pB.fromArray(positions, vB);
                            pC.fromArray(positions, vC);
                            cb.subVectors(pC, pB);
                            ab.subVectors(pA, pB);
                            cb.cross(ab);
                            normals[vA] += cb.x;
                            normals[vA + 1] += cb.y;
                            normals[vA + 2] += cb.z;
                            normals[vB] += cb.x;
                            normals[vB + 1] += cb.y;
                            normals[vB + 2] += cb.z;
                            normals[vC] += cb.x;
                            normals[vC + 1] += cb.y;
                            normals[vC + 2] += cb.z;
                        }
                    }
                }
                else {
                    for (var i = 0, il = positions.length; i < il; i += 9) {
                        pA.fromArray(positions, i);
                        pB.fromArray(positions, i + 3);
                        pC.fromArray(positions, i + 6);
                        cb.subVectors(pC, pB);
                        ab.subVectors(pA, pB);
                        cb.cross(ab);
                        normals[i] = cb.x;
                        normals[i + 1] = cb.y;
                        normals[i + 2] = cb.z;
                        normals[i + 3] = cb.x;
                        normals[i + 4] = cb.y;
                        normals[i + 5] = cb.z;
                        normals[i + 6] = cb.x;
                        normals[i + 7] = cb.y;
                        normals[i + 8] = cb.z;
                    }
                }
                this.normalizeNormals();
                attributes.normal.needsUpdate = true;
            }
        };
        BufferGeometry.prototype.merge = function (geometry, offset) {
            if (offset === void 0) { offset = 0; }
            var attributes = this.attributes;
            for (var key in attributes) {
                if (geometry.attributes[key] === undefined)
                    continue;
                var attribute1 = attributes[key];
                var attributeArray1 = attribute1.array;
                var attribute2 = geometry.attributes[key];
                var attributeArray2 = attribute2.array;
                var attributeSize = attribute2.itemSize;
                for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
                    attributeArray1[j] = attributeArray2[i];
                }
            }
            return this;
        };
        BufferGeometry.prototype.normalizeNormals = function () {
            var normals = this.attributes.normal.array;
            var x, y, z, n;
            for (var i = 0, il = normals.length; i < il; i += 3) {
                x = normals[i];
                y = normals[i + 1];
                z = normals[i + 2];
                n = 1.0 / THREE.Math.sqrt(x * x + y * y + z * z);
                normals[i] *= n;
                normals[i + 1] *= n;
                normals[i + 2] *= n;
            }
        };
        BufferGeometry.prototype.toNonIndexed = function () {
            if (this.index === null) {
                console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
                return this;
            }
            var geometry2 = new BufferGeometry();
            var indices = this.index.array;
            var attributes = this.attributes;
            for (var name in attributes) {
                var attribute = attributes[name];
                var array = attribute.array;
                var itemSize = attribute.itemSize;
                var array2 = new array.constructor(indices.length * itemSize);
                var index = 0, index2 = 0;
                for (var i = 0, l = indices.length; i < l; i++) {
                    index = indices[i] * itemSize;
                    for (var j = 0; j < itemSize; j++) {
                        array2[index2++] = array[index++];
                    }
                }
                geometry2.addAttribute(name, new THREE.BufferAttribute(array2, itemSize));
            }
            return geometry2;
        };
        BufferGeometry.prototype.toJSON = function () {
            var data = {
                metadata: {
                    version: 4.4,
                    type: 'BufferGeometry',
                    generator: 'BufferGeometry.toJSON'
                }
            };
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '')
                data.name = this.name;
            if (this.parameters !== undefined) {
                var parameters = this.parameters;
                for (var key in parameters) {
                    if (parameters[key] !== undefined)
                        data[key] = parameters[key];
                }
                return data;
            }
            data.data = { attributes: {} };
            var index = this.index;
            if (index !== null) {
                var array = Array.prototype.slice.call(index.array);
                data.data.index = {
                    type: index.array.constructor.name,
                    array: array
                };
            }
            var attributes = this.attributes;
            for (var key in attributes) {
                var attribute = attributes[key];
                var array = Array.prototype.slice.call(attribute.array);
                data.data.attributes[key] = {
                    itemSize: attribute.itemSize,
                    type: attribute.array.constructor.name,
                    array: array,
                    normalized: attribute.normalized
                };
            }
            var groups = this.groups;
            if (groups.length > 0) {
                data.data.groups = JSON.parse(JSON.stringify(groups));
            }
            var boundingSphere = this.boundingSphere;
            if (boundingSphere !== null) {
                data.data.boundingSphere = {
                    center: boundingSphere.center.toArray(),
                    radius: boundingSphere.radius
                };
            }
            return data;
        };
        BufferGeometry.prototype.clone = function () {
            return new BufferGeometry().copy(this);
        };
        BufferGeometry.prototype.copy = function (source) {
            var index = source.index;
            if (index !== null) {
                this.setIndex(index.clone());
            }
            var attributes = source.attributes;
            for (var name in attributes) {
                var attribute = attributes[name];
                this.addAttribute(name, attribute.clone());
            }
            var groups = source.groups;
            for (var i = 0, l = groups.length; i < l; i++) {
                var group = groups[i];
                this.addGroup(group.start, group.count, group.materialIndex);
            }
            return this;
        };
        BufferGeometry.prototype.dispose = function () {
            this.dispatchEvent({ type: 'dispose' });
        };
        BufferGeometry.MaxIndex = 65535;
        return BufferGeometry;
    }(THREE.EventDispatcher));
    THREE.BufferGeometry = BufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Clock = (function () {
        function Clock(autoStart) {
            if (autoStart === void 0) { autoStart = true; }
            this.autoStart = autoStart;
            this.startTime = 0;
            this.oldTime = 0;
            this.elapsedTime = 0;
            this.running = false;
        }
        ;
        Clock.prototype.start = function () {
            this.startTime = (performance || Date).now();
            this.oldTime = this.startTime;
            this.running = true;
        };
        Clock.prototype.stop = function () {
            this.getElapsedTime();
            this.running = false;
        };
        Clock.prototype.getElapsedTime = function () {
            this.getDelta();
            return this.elapsedTime;
        };
        Clock.prototype.getDelta = function () {
            var diff = 0;
            if (this.autoStart && !this.running) {
                this.start();
            }
            if (this.running) {
                var newTime = (performance || Date).now();
                diff = (newTime - this.oldTime) / 1000;
                this.oldTime = newTime;
                this.elapsedTime += diff;
            }
            return diff;
        };
        return Clock;
    }());
    THREE.Clock = Clock;
    ;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var DirectGeometry = (function (_super) {
        __extends(DirectGeometry, _super);
        function DirectGeometry() {
            _super.call(this);
            this._id = THREE.GeometryIdCount++;
            this.uuid = THREE.Math.generateUUID();
            this.name = '';
            this.type = 'DirectGeometry';
            this.indices = [];
            this.vertices = [];
            this.normals = [];
            this.colors = [];
            this.uvs = [];
            this.uvs2 = [];
            this.groups = [];
            this.morphTargets = {};
            this.skinWeights = [];
            this.skinIndices = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            this.verticesNeedUpdate = false;
            this.normalsNeedUpdate = false;
            this.colorsNeedUpdate = false;
            this.uvsNeedUpdate = false;
            this.groupsNeedUpdate = false;
        }
        Object.defineProperty(DirectGeometry.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        DirectGeometry.prototype.computeBoundingBox = function () {
            if (this.boundingBox === null) {
                this.boundingBox = new THREE.Box3();
            }
            this.boundingBox.setFromPoints(this.vertices);
        };
        DirectGeometry.prototype.computeBoundingSphere = function () {
            if (this.boundingSphere === null) {
                this.boundingSphere = new THREE.Sphere();
            }
            this.boundingSphere.setFromPoints(this.vertices);
        };
        DirectGeometry.prototype.computeGroups = function (geometry) {
            var group;
            var groups = [];
            var materialIndex;
            var faces = geometry.faces;
            for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                if (face.materialIndex !== materialIndex) {
                    materialIndex = face.materialIndex;
                    if (group !== undefined) {
                        group.count = (i * 3) - group.start;
                        groups.push(group);
                    }
                    group = {
                        start: i * 3,
                        materialIndex: materialIndex
                    };
                }
            }
            if (group !== undefined) {
                group.count = (i * 3) - group.start;
                groups.push(group);
            }
            this.groups = groups;
        };
        DirectGeometry.prototype.fromGeometry = function (geometry) {
            var faces = geometry.faces;
            var vertices = geometry.vertices;
            var faceVertexUvs = geometry.faceVertexUvs;
            var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
            var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
            var morphTargets = geometry.morphTargets;
            var morphTargetsLength = morphTargets.length;
            var morphTargetsPosition;
            if (morphTargetsLength > 0) {
                morphTargetsPosition = [];
                for (var i = 0; i < morphTargetsLength; i++) {
                    morphTargetsPosition[i] = [];
                }
                this.morphTargets.position = morphTargetsPosition;
            }
            var morphNormals = geometry.morphNormals;
            var morphNormalsLength = morphNormals.length;
            var morphTargetsNormal;
            if (morphNormalsLength > 0) {
                morphTargetsNormal = [];
                for (var i = 0; i < morphNormalsLength; i++) {
                    morphTargetsNormal[i] = [];
                }
                this.morphTargets.normal = morphTargetsNormal;
            }
            var skinIndices = geometry.skinIndices;
            var skinWeights = geometry.skinWeights;
            var hasSkinIndices = skinIndices.length === vertices.length;
            var hasSkinWeights = skinWeights.length === vertices.length;
            for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
                var vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                    this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
                }
                else {
                    var normal = face.normal;
                    this.normals.push(normal, normal, normal);
                }
                var vertexColors = face.vertexColors;
                if (vertexColors.length === 3) {
                    this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
                }
                else {
                    var color = face.color;
                    this.colors.push(color, color, color);
                }
                if (hasFaceVertexUv === true) {
                    var vertexUvs = faceVertexUvs[0][i];
                    if (vertexUvs !== undefined) {
                        this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                    }
                    else {
                        console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
                        this.uvs.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());
                    }
                }
                if (hasFaceVertexUv2 === true) {
                    var vertexUvs = faceVertexUvs[1][i];
                    if (vertexUvs !== undefined) {
                        this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                    }
                    else {
                        console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
                        this.uvs2.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());
                    }
                }
                for (var j = 0; j < morphTargetsLength; j++) {
                    var morphTarget = morphTargets[j].vertices;
                    morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
                }
                for (var j = 0; j < morphNormalsLength; j++) {
                    var morphNormal = morphNormals[j].vertexNormals[i];
                    morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);
                }
                if (hasSkinIndices) {
                    this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
                }
                if (hasSkinWeights) {
                    this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
                }
            }
            this.computeGroups(geometry);
            this.verticesNeedUpdate = geometry.verticesNeedUpdate;
            this.normalsNeedUpdate = geometry.normalsNeedUpdate;
            this.colorsNeedUpdate = geometry.colorsNeedUpdate;
            this.uvsNeedUpdate = geometry.uvsNeedUpdate;
            this.groupsNeedUpdate = geometry.groupsNeedUpdate;
            return this;
        };
        DirectGeometry.prototype.dispose = function () {
            this.dispatchEvent({ type: 'dispose' });
        };
        return DirectGeometry;
    }(THREE.EventDispatcher));
    THREE.DirectGeometry = DirectGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Face3 = (function () {
        function Face3(a, b, c, normal, color, materialIndex) {
            if (materialIndex === void 0) { materialIndex = 0; }
            this.a = a;
            this.b = b;
            this.c = c;
            this.materialIndex = materialIndex;
            this.a = a;
            this.b = b;
            this.c = c;
            this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
            this.vertexNormals = Array.isArray(normal) ? normal : [];
            this.color = color instanceof THREE.Color ? color : new THREE.Color();
            this.vertexColors = Array.isArray(color) ? color : [];
        }
        ;
        Face3.prototype.clone = function () {
            return new Face3().copy(this);
        };
        Face3.prototype.copy = function (source) {
            this.a = source.a;
            this.b = source.b;
            this.c = source.c;
            this.normal.copy(source.normal);
            this.color.copy(source.color);
            this.materialIndex = source.materialIndex;
            for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
                this.vertexNormals[i] = source.vertexNormals[i].clone();
            }
            for (var i = 0, il = source.vertexColors.length; i < il; i++) {
                this.vertexColors[i] = source.vertexColors[i].clone();
            }
            return this;
        };
        return Face3;
    }());
    THREE.Face3 = Face3;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var InstancedBufferAttribute = (function (_super) {
        __extends(InstancedBufferAttribute, _super);
        function InstancedBufferAttribute(array, itemSize, meshPerAttribute) {
            if (meshPerAttribute === void 0) { meshPerAttribute = 1; }
            _super.call(this, array, itemSize);
            this.meshPerAttribute = meshPerAttribute;
        }
        InstancedBufferAttribute.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.meshPerAttribute = source.meshPerAttribute;
            return this;
        };
        ;
        return InstancedBufferAttribute;
    }(THREE.BufferAttribute));
    THREE.InstancedBufferAttribute = InstancedBufferAttribute;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var InstancedBufferGeometry = (function (_super) {
        __extends(InstancedBufferGeometry, _super);
        function InstancedBufferGeometry() {
            _super.call(this);
            this.type = 'InstancedBufferGeometry';
        }
        InstancedBufferGeometry.prototype.addGroup = function (start, count, instances) {
            this.groups.push({
                start: start,
                count: count,
                instances: instances
            });
        };
        InstancedBufferGeometry.prototype.copy = function (source) {
            var index = source.index;
            if (index !== null) {
                this.setIndex(index.clone());
            }
            var attributes = source.attributes;
            for (var name in attributes) {
                var attribute = attributes[name];
                this.addAttribute(name, attribute.clone());
            }
            var groups = source.groups;
            for (var i = 0, l = groups.length; i < l; i++) {
                var group = groups[i];
                this.addGroup(group.start, group.count, group.instances);
            }
            return this;
        };
        ;
        return InstancedBufferGeometry;
    }(THREE.BufferGeometry));
    THREE.InstancedBufferGeometry = InstancedBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var InterleavedBuffer = (function () {
        function InterleavedBuffer(array, stride) {
            this.uuid = THREE.Math.generateUUID();
            this.dynamic = false;
            this.updateRange = { offset: 0, count: -1 };
            this.version = 0;
            this.array = array;
            this.stride = stride;
        }
        ;
        Object.defineProperty(InterleavedBuffer.prototype, "length", {
            get: function () {
                return this.array.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InterleavedBuffer.prototype, "count", {
            get: function () {
                return this.array.length / this.stride;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
            set: function (value) {
                if (value === true)
                    this.version++;
            },
            enumerable: true,
            configurable: true
        });
        InterleavedBuffer.prototype.setDynamic = function (value) {
            this.dynamic = value;
            return this;
        };
        InterleavedBuffer.prototype.copy = function (source) {
            this.array = new source.array.constructor(source.array);
            this.stride = source.stride;
            this.dynamic = source.dynamic;
            return this;
        };
        InterleavedBuffer.prototype.copyAt = function (index1, attribute, index2) {
            index1 *= this.stride;
            index2 *= attribute.stride;
            for (var i = 0, l = this.stride; i < l; i++) {
                this.array[index1 + i] = attribute.array[index2 + i];
            }
            return this;
        };
        InterleavedBuffer.prototype.set = function (value, offset) {
            if (offset === undefined)
                offset = 0;
            this.array.set(value, offset);
            return this;
        };
        InterleavedBuffer.prototype.clone = function () {
            return new InterleavedBuffer().copy(this);
        };
        return InterleavedBuffer;
    }());
    THREE.InterleavedBuffer = InterleavedBuffer;
    ;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var InstancedInterleavedBuffer = (function (_super) {
        __extends(InstancedInterleavedBuffer, _super);
        function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
            _super.call(this, array, stride);
            this.meshPerAttribute = meshPerAttribute || 1;
        }
        ;
        InstancedInterleavedBuffer.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.meshPerAttribute = source.meshPerAttribute;
            return this;
        };
        ;
        return InstancedInterleavedBuffer;
    }(THREE.InterleavedBuffer));
    THREE.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var InterleavedBufferAttribute = (function (_super) {
        __extends(InterleavedBufferAttribute, _super);
        function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
            _super.call(this, null, itemSize);
            this.data = interleavedBuffer;
            this.offset = offset;
            this.normalized = normalized === true;
        }
        Object.defineProperty(InterleavedBufferAttribute.prototype, "count", {
            get: function () {
                return this.data.count;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InterleavedBufferAttribute.prototype, "array", {
            get: function () {
                return this.data.array;
            },
            enumerable: true,
            configurable: true
        });
        InterleavedBufferAttribute.prototype.setX = function (index, x) {
            this.data.array[index * this.data.stride + this.offset] = x;
            return this;
        };
        InterleavedBufferAttribute.prototype.setY = function (index, y) {
            this.data.array[index * this.data.stride + this.offset + 1] = y;
            return this;
        };
        InterleavedBufferAttribute.prototype.setZ = function (index, z) {
            this.data.array[index * this.data.stride + this.offset + 2] = z;
            return this;
        };
        InterleavedBufferAttribute.prototype.setW = function (index, w) {
            this.data.array[index * this.data.stride + this.offset + 3] = w;
            return this;
        };
        InterleavedBufferAttribute.prototype.getX = function (index) {
            return this.data.array[index * this.data.stride + this.offset];
        };
        InterleavedBufferAttribute.prototype.getY = function (index) {
            return this.data.array[index * this.data.stride + this.offset + 1];
        };
        InterleavedBufferAttribute.prototype.getZ = function (index) {
            return this.data.array[index * this.data.stride + this.offset + 2];
        };
        InterleavedBufferAttribute.prototype.getW = function (index) {
            return this.data.array[index * this.data.stride + this.offset + 3];
        };
        InterleavedBufferAttribute.prototype.setXY = function (index, x, y) {
            index = index * this.data.stride + this.offset;
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            return this;
        };
        InterleavedBufferAttribute.prototype.setXYZ = function (index, x, y, z) {
            index = index * this.data.stride + this.offset;
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            this.data.array[index + 2] = z;
            return this;
        };
        InterleavedBufferAttribute.prototype.setXYZW = function (index, x, y, z, w) {
            index = index * this.data.stride + this.offset;
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            this.data.array[index + 2] = z;
            this.data.array[index + 3] = w;
            return this;
        };
        return InterleavedBufferAttribute;
    }(THREE.BufferAttribute));
    THREE.InterleavedBufferAttribute = InterleavedBufferAttribute;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Layers = (function () {
        function Layers() {
            this.mask = 1;
        }
        Layers.prototype.set = function (channel) {
            this.mask = 1 << channel;
        };
        Layers.prototype.enable = function (channel) {
            this.mask |= 1 << channel;
        };
        Layers.prototype.toggle = function (channel) {
            this.mask ^= 1 << channel;
        };
        Layers.prototype.disable = function (channel) {
            this.mask &= ~(1 << channel);
        };
        Layers.prototype.test = function (layers) {
            return (this.mask & layers.mask) !== 0;
        };
        return Layers;
    }());
    THREE.Layers = Layers;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Raycaster = (function () {
        function Raycaster(origin, direction, near, far) {
            if (near === void 0) { near = 0; }
            if (far === void 0) { far = Infinity; }
            this.params = {
                Mesh: {},
                Line: {},
                LOD: {},
                Points: { threshold: 1 },
                Sprite: {}
            };
            this.linePrecision = 1;
            this.ray = new THREE.Ray(origin, direction);
            this.near = near || 0;
            this.far = far || Infinity;
        }
        Raycaster.ascSort = function (a, b) {
            return a.distance - b.distance;
        };
        Raycaster.intersectObject = function (object, raycaster, intersects, recursive) {
            if (object.visible === false)
                return;
            object.raycast(raycaster, intersects);
            if (recursive === true) {
                var children = object.children;
                for (var i = 0, l = children.length; i < l; i++) {
                    Raycaster.intersectObject(children[i], raycaster, intersects, true);
                }
            }
        };
        Raycaster.prototype.set = function (origin, direction) {
            this.ray.set(origin, direction);
        };
        Raycaster.prototype.setFromCamera = function (coords, camera) {
            if (camera instanceof THREE.PerspectiveCamera) {
                this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
                this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
            }
            else if (camera instanceof THREE.OrthographicCamera) {
                this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
                this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            }
            else {
                console.error('THREE.Raycaster: Unsupported camera type.');
            }
        };
        Raycaster.prototype.intersectObject = function (object, recursive) {
            var intersects = [];
            Raycaster.intersectObject(object, this, intersects, recursive);
            intersects.sort(Raycaster.ascSort);
            return intersects;
        };
        Raycaster.prototype.intersectObjects = function (objects, recursive) {
            var intersects = [];
            if (Array.isArray(objects) === false) {
                console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
                return intersects;
            }
            for (var i = 0, l = objects.length; i < l; i++) {
                Raycaster.intersectObject(objects[i], this, intersects, recursive);
            }
            intersects.sort(Raycaster.ascSort);
            return intersects;
        };
        return Raycaster;
    }());
    THREE.Raycaster = Raycaster;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Uniform = (function () {
        function Uniform(value) {
            this.value = value;
        }
        Uniform.prototype.onUpdate = function (callback) {
            this.dynamic = true;
            this.onUpdateCallback = callback;
            return this;
        };
        return Uniform;
    }());
    THREE.Uniform = Uniform;
    ;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Curve = (function () {
        function Curve() {
        }
        ;
        Curve.prototype.getPoint = function (t) {
            console.warn("THREE.Curve: Warning, getPoint() not implemented!");
            return null;
        };
        Curve.prototype.getPointAt = function (u) {
            var t = this.getUtoTmapping(u);
            return this.getPoint(t);
        };
        Curve.prototype.getPoints = function (divisions) {
            if (!divisions)
                divisions = 5;
            var points = [];
            for (var d = 0; d <= divisions; d++) {
                points.push(this.getPoint(d / divisions));
            }
            return points;
        };
        Curve.prototype.getSpacedPoints = function (divisions) {
            if (!divisions)
                divisions = 5;
            var points = [];
            for (var d = 0; d <= divisions; d++) {
                points.push(this.getPointAt(d / divisions));
            }
            return points;
        };
        Curve.prototype.getLength = function () {
            var lengths = this.getLengths();
            return lengths[lengths.length - 1];
        };
        Curve.prototype.getLengths = function (divisions) {
            if (!divisions)
                divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;
            if (this.cacheArcLengths
                && (this.cacheArcLengths.length === divisions + 1)
                && !this.needsUpdate) {
                return this.cacheArcLengths;
            }
            this.needsUpdate = false;
            var cache = [];
            var current, last = this.getPoint(0);
            var p, sum = 0;
            cache.push(0);
            for (p = 1; p <= divisions; p++) {
                current = this.getPoint(p / divisions);
                sum += current.distanceTo(last);
                cache.push(sum);
                last = current;
            }
            this.cacheArcLengths = cache;
            return cache;
        };
        Curve.prototype.updateArcLengths = function () {
            this.needsUpdate = true;
            this.getLengths();
        };
        Curve.prototype.getUtoTmapping = function (u, distance) {
            var arcLengths = this.getLengths();
            var i = 0, il = arcLengths.length;
            var targetArcLength;
            if (distance) {
                targetArcLength = distance;
            }
            else {
                targetArcLength = u * arcLengths[il - 1];
            }
            var low = 0, high = il - 1, comparison;
            while (low <= high) {
                i = THREE.Math.floor(low + (high - low) / 2);
                comparison = arcLengths[i] - targetArcLength;
                if (comparison < 0) {
                    low = i + 1;
                }
                else if (comparison > 0) {
                    high = i - 1;
                }
                else {
                    high = i;
                    break;
                }
            }
            i = high;
            if (arcLengths[i] === targetArcLength) {
                var t = i / (il - 1);
                return t;
            }
            var lengthBefore = arcLengths[i];
            var lengthAfter = arcLengths[i + 1];
            var segmentLength = lengthAfter - lengthBefore;
            var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
            var t = (i + segmentFraction) / (il - 1);
            return t;
        };
        Curve.prototype.getTangent = function (t) {
            var delta = 0.0001;
            var t1 = t - delta;
            var t2 = t + delta;
            if (t1 < 0)
                t1 = 0;
            if (t2 > 1)
                t2 = 1;
            var pt1 = this.getPoint(t1);
            var pt2 = this.getPoint(t2);
            var vec = pt2.clone().sub(pt1);
            return vec.normalize();
        };
        Curve.prototype.getTangentAt = function (u) {
            var t = this.getUtoTmapping(u);
            return this.getTangent(t);
        };
        Curve.create = function (constructor, getPointFunc) {
            constructor.prototype = Object.create(Curve.prototype);
            constructor.prototype.constructor = constructor;
            constructor.prototype.getPoint = getPointFunc;
            return constructor;
        };
        return Curve;
    }());
    THREE.Curve = Curve;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var CurvePath = (function (_super) {
        __extends(CurvePath, _super);
        function CurvePath() {
            _super.call(this);
            this.curves = [];
            this.autoClose = false;
        }
        ;
        CurvePath.prototype.add = function (curve) {
            this.curves.push(curve);
        };
        CurvePath.prototype.closePath = function () {
            var startPoint = this.curves[0].getPoint(0);
            var endPoint = this.curves[this.curves.length - 1].getPoint(1);
            if (!startPoint.equals(endPoint)) {
                this.curves.push(new THREE.LineCurve(endPoint, startPoint));
            }
        };
        CurvePath.prototype.getPoint = function (t) {
            var d = t * this.getLength();
            var curveLengths = this.getCurveLengths();
            var i = 0;
            while (i < curveLengths.length) {
                if (curveLengths[i] >= d) {
                    var diff = curveLengths[i] - d;
                    var curve = this.curves[i];
                    var segmentLength = curve.getLength();
                    var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                    return curve.getPointAt(u);
                }
                i++;
            }
            return null;
        };
        CurvePath.prototype.getLength = function () {
            var lens = this.getCurveLengths();
            return lens[lens.length - 1];
        };
        CurvePath.prototype.updateArcLengths = function () {
            this.needsUpdate = true;
            this.cacheLengths = null;
            this.getLengths();
        };
        CurvePath.prototype.getCurveLengths = function () {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
                return this.cacheLengths;
            }
            var lengths = [], sums = 0;
            for (var i = 0, l = this.curves.length; i < l; i++) {
                sums += this.curves[i].getLength();
                lengths.push(sums);
            }
            this.cacheLengths = lengths;
            return lengths;
        };
        CurvePath.prototype.getSpacedPoints = function (divisions) {
            if (!divisions)
                divisions = 40;
            var points = [];
            for (var i = 0; i <= divisions; i++) {
                points.push(this.getPoint(i / divisions));
            }
            if (this.autoClose) {
                points.push(points[0]);
            }
            return points;
        };
        CurvePath.prototype.getPoints = function (divisions) {
            divisions = divisions || 12;
            var points = [], last;
            for (var i = 0, curves = this.curves; i < curves.length; i++) {
                var curve = curves[i];
                var resolution = curve instanceof THREE.EllipseCurve ? divisions * 2
                    : curve instanceof THREE.LineCurve ? 1
                        : curve instanceof THREE.SplineCurve ? divisions * curve.points.length
                            : divisions;
                var pts = curve.getPoints(resolution);
                for (var j = 0; j < pts.length; j++) {
                    var point = pts[j];
                    if (last && last.equals(point))
                        continue;
                    points.push(point);
                    last = point;
                }
            }
            if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
                points.push(points[0]);
            }
            return points;
        };
        CurvePath.prototype.createPointsGeometry = function (divisions) {
            var pts = this.getPoints(divisions);
            return this.createGeometry(pts);
        };
        CurvePath.prototype.createSpacedPointsGeometry = function (divisions) {
            var pts = this.getSpacedPoints(divisions);
            return this.createGeometry(pts);
        };
        CurvePath.prototype.createGeometry = function (points) {
            var geometry = new THREE.Geometry();
            for (var i = 0, l = points.length; i < l; i++) {
                var point = points[i];
                geometry.vertices.push(new THREE.Vector3(point.x, point.y, point.z || 0));
            }
            return geometry;
        };
        return CurvePath;
    }(THREE.Curve));
    THREE.CurvePath = CurvePath;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Font = (function () {
        function Font(data) {
            this.data = data;
        }
        ;
        Font.prototype.generateShapes = function (text, size, divisions) {
            function createPaths(text) {
                var chars = String(text).split('');
                var scale = size / data.resolution;
                var offset = 0;
                var paths = [];
                for (var i = 0; i < chars.length; i++) {
                    var ret = createPath(chars[i], scale, offset);
                    offset += ret.offset;
                    paths.push(ret.path);
                }
                return paths;
            }
            function createPath(c, scale, offset) {
                var glyph = data.glyphs[c] || data.glyphs['?'];
                if (!glyph)
                    return;
                var path = new THREE.ShapePath();
                var pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;
                var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;
                if (glyph.o) {
                    var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
                    for (var i = 0, l = outline.length; i < l;) {
                        var action = outline[i++];
                        switch (action) {
                            case 'm':
                                x = outline[i++] * scale + offset;
                                y = outline[i++] * scale;
                                path.moveTo(x, y);
                                break;
                            case 'l':
                                x = outline[i++] * scale + offset;
                                y = outline[i++] * scale;
                                path.lineTo(x, y);
                                break;
                            case 'q':
                                cpx = outline[i++] * scale + offset;
                                cpy = outline[i++] * scale;
                                cpx1 = outline[i++] * scale + offset;
                                cpy1 = outline[i++] * scale;
                                path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                                laste = pts[pts.length - 1];
                                if (laste) {
                                    cpx0 = laste.x;
                                    cpy0 = laste.y;
                                    for (var i2 = 1; i2 <= divisions; i2++) {
                                        var t = i2 / divisions;
                                        b2(t, cpx0, cpx1, cpx);
                                        b2(t, cpy0, cpy1, cpy);
                                    }
                                }
                                break;
                            case 'b':
                                cpx = outline[i++] * scale + offset;
                                cpy = outline[i++] * scale;
                                cpx1 = outline[i++] * scale + offset;
                                cpy1 = outline[i++] * scale;
                                cpx2 = outline[i++] * scale + offset;
                                cpy2 = outline[i++] * scale;
                                path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                                laste = pts[pts.length - 1];
                                if (laste) {
                                    cpx0 = laste.x;
                                    cpy0 = laste.y;
                                    for (var i2 = 1; i2 <= divisions; i2++) {
                                        var t = i2 / divisions;
                                        b3(t, cpx0, cpx1, cpx2, cpx);
                                        b3(t, cpy0, cpy1, cpy2, cpy);
                                    }
                                }
                                break;
                        }
                    }
                }
                return { offset: glyph.ha * scale, path: path };
            }
            if (size === undefined)
                size = 100;
            if (divisions === undefined)
                divisions = 4;
            var data = this.data;
            var paths = createPaths(text);
            var shapes = [];
            for (var p = 0, pl = paths.length; p < pl; p++) {
                Array.prototype.push.apply(shapes, paths[p].toShapes());
            }
            return shapes;
        };
        return Font;
    }());
    THREE.Font = Font;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Path = (function (_super) {
        __extends(Path, _super);
        function Path(points) {
            _super.call(this);
            this.currentPoint = new THREE.Vector2();
            if (points) {
                this.fromPoints(points);
            }
        }
        ;
        Path.prototype.fromPoints = function (vectors) {
            this.moveTo(vectors[0].x, vectors[0].y);
            for (var i = 1, l = vectors.length; i < l; i++) {
                this.lineTo(vectors[i].x, vectors[i].y);
            }
        };
        Path.prototype.moveTo = function (x, y) {
            this.currentPoint.set(x, y);
        };
        Path.prototype.lineTo = function (x, y) {
            var curve = new THREE.LineCurve(this.currentPoint.clone(), new THREE.Vector2(x, y));
            this.curves.push(curve);
            this.currentPoint.set(x, y);
        };
        Path.prototype.quadraticCurveTo = function (aCPx, aCPy, aX, aY) {
            var curve = new THREE.QuadraticBezierCurve(this.currentPoint.clone(), new THREE.Vector2(aCPx, aCPy), new THREE.Vector2(aX, aY));
            this.curves.push(curve);
            this.currentPoint.set(aX, aY);
        };
        Path.prototype.bezierCurveTo = function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            var curve = new THREE.CubicBezierCurve(this.currentPoint.clone(), new THREE.Vector2(aCP1x, aCP1y), new THREE.Vector2(aCP2x, aCP2y), new THREE.Vector2(aX, aY));
            this.curves.push(curve);
            this.currentPoint.set(aX, aY);
        };
        Path.prototype.splineThru = function (pts) {
            var npts = [this.currentPoint.clone()].concat(pts);
            var curve = new THREE.SplineCurve(npts);
            this.curves.push(curve);
            this.currentPoint.copy(pts[pts.length - 1]);
        };
        Path.prototype.arc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            var x0 = this.currentPoint.x;
            var y0 = this.currentPoint.y;
            this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        };
        Path.prototype.absarc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        };
        Path.prototype.ellipse = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            var x0 = this.currentPoint.x;
            var y0 = this.currentPoint.y;
            this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        };
        Path.prototype.absellipse = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            var curve = new THREE.EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
            if (this.curves.length > 0) {
                var firstPoint = curve.getPoint(0);
                if (!firstPoint.equals(this.currentPoint)) {
                    this.lineTo(firstPoint.x, firstPoint.y);
                }
            }
            this.curves.push(curve);
            var lastPoint = curve.getPoint(1);
            this.currentPoint.copy(lastPoint);
        };
        return Path;
    }(THREE.CurvePath));
    THREE.Path = Path;
    var ShapePath = (function () {
        function ShapePath() {
            this.subPaths = [];
            this.currentPath = null;
        }
        ShapePath.prototype.moveTo = function (x, y) {
            this.currentPath = new THREE.Path();
            this.subPaths.push(this.currentPath);
            this.currentPath.moveTo(x, y);
        };
        ShapePath.prototype.lineTo = function (x, y) {
            this.currentPath.lineTo(x, y);
        };
        ShapePath.prototype.quadraticCurveTo = function (aCPx, aCPy, aX, aY) {
            this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        };
        ShapePath.prototype.bezierCurveTo = function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        };
        ShapePath.prototype.splineThru = function (pts) {
            this.currentPath.splineThru(pts);
        };
        ShapePath.prototype.toShapes = function (isCCW, noHoles) {
            function toShapesNoHoles(inSubpaths) {
                var shapes = [];
                for (var i = 0, l = inSubpaths.length; i < l; i++) {
                    var tmpPath = inSubpaths[i];
                    var tmpShape = new THREE.Shape();
                    tmpShape.curves = tmpPath.curves;
                    shapes.push(tmpShape);
                }
                return shapes;
            }
            function isPointInsidePolygon(inPt, inPolygon) {
                var polyLen = inPolygon.length;
                var inside = false;
                for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                    var edgeLowPt = inPolygon[p];
                    var edgeHighPt = inPolygon[q];
                    var edgeDx = edgeHighPt.x - edgeLowPt.x;
                    var edgeDy = edgeHighPt.y - edgeLowPt.y;
                    if (THREE.Math.abs(edgeDy) > Number.EPSILON) {
                        if (edgeDy < 0) {
                            edgeLowPt = inPolygon[q];
                            edgeDx = -edgeDx;
                            edgeHighPt = inPolygon[p];
                            edgeDy = -edgeDy;
                        }
                        if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y))
                            continue;
                        if (inPt.y === edgeLowPt.y) {
                            if (inPt.x === edgeLowPt.x)
                                return true;
                        }
                        else {
                            var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                            if (perpEdge === 0)
                                return true;
                            if (perpEdge < 0)
                                continue;
                            inside = !inside;
                        }
                    }
                    else {
                        if (inPt.y !== edgeLowPt.y)
                            continue;
                        if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) ||
                            ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x)))
                            return true;
                    }
                }
                return inside;
            }
            var isClockWise = THREE.ShapeUtils.isClockWise;
            var subPaths = this.subPaths;
            if (subPaths.length === 0)
                return [];
            if (noHoles === true)
                return toShapesNoHoles(subPaths);
            var solid, tmpPath, tmpShape, shapes = [];
            if (subPaths.length === 1) {
                tmpPath = subPaths[0];
                tmpShape = new THREE.Shape();
                tmpShape.curves = tmpPath.curves;
                shapes.push(tmpShape);
                return shapes;
            }
            var holesFirst = !isClockWise(subPaths[0].getPoints());
            holesFirst = isCCW ? !holesFirst : holesFirst;
            var betterShapeHoles = [];
            var newShapes = [];
            var newShapeHoles = [];
            var mainIdx = 0;
            var tmpPoints;
            newShapes[mainIdx] = undefined;
            newShapeHoles[mainIdx] = [];
            for (var i = 0, l = subPaths.length; i < l; i++) {
                tmpPath = subPaths[i];
                tmpPoints = tmpPath.getPoints();
                solid = isClockWise(tmpPoints);
                solid = isCCW ? !solid : solid;
                if (solid) {
                    if ((!holesFirst) && (newShapes[mainIdx]))
                        mainIdx++;
                    newShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };
                    newShapes[mainIdx].s.curves = tmpPath.curves;
                    if (holesFirst)
                        mainIdx++;
                    newShapeHoles[mainIdx] = [];
                }
                else {
                    newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
                }
            }
            if (!newShapes[0])
                return toShapesNoHoles(subPaths);
            if (newShapes.length > 1) {
                var ambiguous = false;
                var toChange = [];
                for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                    betterShapeHoles[sIdx] = [];
                }
                for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                    var sho = newShapeHoles[sIdx];
                    for (var hIdx = 0; hIdx < sho.length; hIdx++) {
                        var ho = sho[hIdx];
                        var hole_unassigned = true;
                        for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                                if (sIdx !== s2Idx)
                                    toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
                                if (hole_unassigned) {
                                    hole_unassigned = false;
                                    betterShapeHoles[s2Idx].push(ho);
                                }
                                else {
                                    ambiguous = true;
                                }
                            }
                        }
                        if (hole_unassigned) {
                            betterShapeHoles[sIdx].push(ho);
                        }
                    }
                }
                if (toChange.length > 0) {
                    if (!ambiguous)
                        newShapeHoles = betterShapeHoles;
                }
            }
            var tmpHoles;
            for (var i = 0, il = newShapes.length; i < il; i++) {
                tmpShape = newShapes[i].s;
                shapes.push(tmpShape);
                tmpHoles = newShapeHoles[i];
                for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
                    tmpShape.holes.push(tmpHoles[j].h);
                }
            }
            return shapes;
        };
        return ShapePath;
    }());
    THREE.ShapePath = ShapePath;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Shape = (function (_super) {
        __extends(Shape, _super);
        function Shape(points) {
            _super.call(this, points);
            this.holes = [];
        }
        ;
        Shape.prototype.extrude = function (options) {
            return new THREE.ExtrudeGeometry(this, options);
        };
        Shape.prototype.makeGeometry = function (options) {
            return new THREE.ShapeGeometry(this, options);
        };
        Shape.prototype.getPointsHoles = function (divisions) {
            var holesPts = [];
            for (var i = 0, l = this.holes.length; i < l; i++) {
                holesPts[i] = this.holes[i].getPoints(divisions);
            }
            return holesPts;
        };
        Shape.prototype.extractAllPoints = function (divisions) {
            return {
                shape: this.getPoints(divisions),
                holes: this.getPointsHoles(divisions)
            };
        };
        Shape.prototype.extractPoints = function (divisions) {
            return this.extractAllPoints(divisions);
        };
        return Shape;
    }(THREE.Path));
    THREE.Shape = Shape;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var EllipseCurve = (function (_super) {
        __extends(EllipseCurve, _super);
        function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            _super.call(this);
            this.aX = aX;
            this.aY = aY;
            this.xRadius = xRadius;
            this.yRadius = yRadius;
            this.aStartAngle = aStartAngle;
            this.aEndAngle = aEndAngle;
            this.aClockwise = aClockwise;
            this.aRotation = aRotation || 0;
        }
        ;
        EllipseCurve.prototype.getPoint = function (t) {
            var deltaAngle = this.aEndAngle - this.aStartAngle;
            if (deltaAngle < 0)
                deltaAngle += THREE.Math.PI * 2;
            if (deltaAngle > THREE.Math.PI * 2)
                deltaAngle -= THREE.Math.PI * 2;
            var angle;
            if (this.aClockwise === true) {
                angle = this.aEndAngle + (1 - t) * (THREE.Math.PI * 2 - deltaAngle);
            }
            else {
                angle = this.aStartAngle + t * deltaAngle;
            }
            var x = this.aX + this.xRadius * THREE.Math.cos(angle);
            var y = this.aY + this.yRadius * THREE.Math.sin(angle);
            if (this.aRotation !== 0) {
                var cos = THREE.Math.cos(this.aRotation);
                var sin = THREE.Math.sin(this.aRotation);
                var tx = x, ty = y;
                x = (tx - this.aX) * cos - (ty - this.aY) * sin + this.aX;
                y = (tx - this.aX) * sin + (ty - this.aY) * cos + this.aY;
            }
            return new THREE.Vector2(x, y);
        };
        ;
        return EllipseCurve;
    }(THREE.Curve));
    THREE.EllipseCurve = EllipseCurve;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var ArcCurve = (function (_super) {
        __extends(ArcCurve, _super);
        function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            _super.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        }
        ;
        return ArcCurve;
    }(THREE.EllipseCurve));
    THREE.ArcCurve = ArcCurve;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var CubicPoly = (function () {
        function CubicPoly() {
            this.calc = function (t) {
                var t2 = t * t;
                var t3 = t2 * t;
                return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;
            };
        }
        CubicPoly.prototype.init = function (x0, x1, t0, t1) {
            this.c0 = x0;
            this.c1 = t0;
            this.c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
            this.c3 = 2 * x0 - 2 * x1 + t0 + t1;
        };
        ;
        CubicPoly.prototype.initNonuniformCatmullRom = function (x0, x1, x2, x3, dt0, dt1, dt2) {
            var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
            var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
            t1 *= dt1;
            t2 *= dt1;
            this.init(x1, x2, t1, t2);
        };
        ;
        CubicPoly.prototype.initCatmullRom = function (x0, x1, x2, x3, tension) {
            this.init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
        };
        ;
        return CubicPoly;
    }());
    var CatmullRomCurve3 = (function (_super) {
        __extends(CatmullRomCurve3, _super);
        function CatmullRomCurve3(p) {
            _super.call(this);
            this.points = p || [];
            this.closed = false;
        }
        CatmullRomCurve3.prototype.getPoint = function (t) {
            var tmp = CatmullRomCurve3.tmp;
            var px = CatmullRomCurve3.px;
            var py = CatmullRomCurve3.py;
            var pz = CatmullRomCurve3.pz;
            if (tmp == undefined) {
                tmp = CatmullRomCurve3.tmp = new THREE.Vector3();
                px = CatmullRomCurve3.px = new CubicPoly();
                py = CatmullRomCurve3.py = new CubicPoly();
                pz = CatmullRomCurve3.pz = new CubicPoly();
            }
            var points = this.points, point, intPoint, weight, l;
            l = points.length;
            if (l < 2)
                console.log('duh, you need at least 2 points');
            point = (l - (this.closed ? 0 : 1)) * t;
            intPoint = THREE.Math.floor(point);
            weight = point - intPoint;
            if (this.closed) {
                intPoint += intPoint > 0 ? 0 : (THREE.Math.floor(THREE.Math.abs(intPoint) / points.length) + 1) * points.length;
            }
            else if (weight === 0 && intPoint === l - 1) {
                intPoint = l - 2;
                weight = 1;
            }
            var p0, p1, p2, p3;
            if (this.closed || intPoint > 0) {
                p0 = points[(intPoint - 1) % l];
            }
            else {
                tmp.subVectors(points[0], points[1]).add(points[0]);
                p0 = tmp;
            }
            p1 = points[intPoint % l];
            p2 = points[(intPoint + 1) % l];
            if (this.closed || intPoint + 2 < l) {
                p3 = points[(intPoint + 2) % l];
            }
            else {
                tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
                p3 = tmp;
            }
            if (this.type === undefined || this.type === 'centripetal' || this.type === 'chordal') {
                var pow = this.type === 'chordal' ? 0.5 : 0.25;
                var dt0 = THREE.Math.pow(p0.distanceToSquared(p1), pow);
                var dt1 = THREE.Math.pow(p1.distanceToSquared(p2), pow);
                var dt2 = THREE.Math.pow(p2.distanceToSquared(p3), pow);
                if (dt1 < 1e-4)
                    dt1 = 1.0;
                if (dt0 < 1e-4)
                    dt0 = dt1;
                if (dt2 < 1e-4)
                    dt2 = dt1;
                px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
                py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
                pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
            }
            else if (this.type === 'catmullrom') {
                var tension = this.tension !== undefined ? this.tension : 0.5;
                px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension);
                py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension);
                pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);
            }
            var v = new THREE.Vector3(px.calc(weight), py.calc(weight), pz.calc(weight));
            return v;
        };
        return CatmullRomCurve3;
    }(THREE.Curve));
    THREE.CatmullRomCurve3 = CatmullRomCurve3;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var CubicBezierCurve = (function (_super) {
        __extends(CubicBezierCurve, _super);
        function CubicBezierCurve(v0, v1, v2, v3) {
            _super.call(this);
            this.v0 = v0;
            this.v1 = v1;
            this.v2 = v2;
            this.v3 = v3;
        }
        ;
        CubicBezierCurve.prototype.getPoint = function (t) {
            var b3 = THREE.ShapeUtils.b3;
            return new THREE.Vector2(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y));
        };
        ;
        CubicBezierCurve.prototype.getTangent = function (t) {
            var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;
            return new THREE.Vector2(tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize();
        };
        ;
        return CubicBezierCurve;
    }(THREE.Curve));
    THREE.CubicBezierCurve = CubicBezierCurve;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var CubicBezierCurve3 = (function (_super) {
        __extends(CubicBezierCurve3, _super);
        function CubicBezierCurve3(v0, v1, v2, v3) {
            _super.call(this);
            this.v0 = v0;
            this.v1 = v1;
            this.v2 = v2;
            this.v3 = v3;
        }
        CubicBezierCurve3.prototype.getPoint = function (t) {
            var b3 = THREE.ShapeUtils.b3;
            return new THREE.Vector3(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y), b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z));
        };
        return CubicBezierCurve3;
    }(THREE.Curve));
    THREE.CubicBezierCurve3 = CubicBezierCurve3;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var LineCurve = (function (_super) {
        __extends(LineCurve, _super);
        function LineCurve(v1, v2) {
            _super.call(this);
            this.v1 = v1;
            this.v2 = v2;
        }
        ;
        LineCurve.prototype.getPoint = function (t) {
            var point = this.v2.clone().sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
            return point;
        };
        ;
        LineCurve.prototype.getPointAt = function (u) {
            return this.getPoint(u);
        };
        ;
        LineCurve.prototype.getTangent = function (t) {
            var tangent = this.v2.clone().sub(this.v1);
            return tangent.normalize();
        };
        ;
        return LineCurve;
    }(THREE.Curve));
    THREE.LineCurve = LineCurve;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var LineCurve3 = (function (_super) {
        __extends(LineCurve3, _super);
        function LineCurve3(v1, v2) {
            _super.call(this);
            this.v1 = v1;
            this.v2 = v2;
        }
        LineCurve3.prototype.getPoint = function (t) {
            var vector = new THREE.Vector3();
            vector.subVectors(this.v2, this.v1);
            vector.multiplyScalar(t);
            vector.add(this.v1);
            return vector;
        };
        return LineCurve3;
    }(THREE.Curve));
    THREE.LineCurve3 = LineCurve3;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var QuadraticBezierCurve = (function (_super) {
        __extends(QuadraticBezierCurve, _super);
        function QuadraticBezierCurve(v0, v1, v2) {
            _super.call(this);
            this.v0 = v0;
            this.v1 = v1;
            this.v2 = v2;
        }
        ;
        QuadraticBezierCurve.prototype.getPoint = function (t) {
            var b2 = THREE.ShapeUtils.b2;
            return new THREE.Vector2(b2(t, this.v0.x, this.v1.x, this.v2.x), b2(t, this.v0.y, this.v1.y, this.v2.y));
        };
        ;
        QuadraticBezierCurve.prototype.getTangent = function (t) {
            var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;
            return new THREE.Vector2(tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x), tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y)).normalize();
        };
        ;
        return QuadraticBezierCurve;
    }(THREE.Curve));
    THREE.QuadraticBezierCurve = QuadraticBezierCurve;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var QuadraticBezierCurve3 = (function (_super) {
        __extends(QuadraticBezierCurve3, _super);
        function QuadraticBezierCurve3(v0, v1, v2) {
            _super.call(this);
            this.v0 = v0;
            this.v1 = v1;
            this.v2 = v2;
        }
        QuadraticBezierCurve3.prototype.getPoint = function (t) {
            var b2 = THREE.ShapeUtils.b2;
            return new THREE.Vector3(b2(t, this.v0.x, this.v1.x, this.v2.x), b2(t, this.v0.y, this.v1.y, this.v2.y), b2(t, this.v0.z, this.v1.z, this.v2.z));
        };
        return QuadraticBezierCurve3;
    }(THREE.Curve));
    THREE.QuadraticBezierCurve3 = QuadraticBezierCurve3;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var SplineCurve = (function (_super) {
        __extends(SplineCurve, _super);
        function SplineCurve(points) {
            _super.call(this);
            this.points = (points == undefined) ? [] : points;
        }
        ;
        SplineCurve.prototype.getPoint = function (t) {
            var points = this.points;
            var point = (points.length - 1) * t;
            var intPoint = THREE.Math.floor(point);
            var weight = point - intPoint;
            var point0 = points[intPoint === 0 ? intPoint : intPoint - 1];
            var point1 = points[intPoint];
            var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
            var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
            var interpolate = THREE.CurveUtils.interpolate;
            return new THREE.Vector2(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight));
        };
        ;
        return SplineCurve;
    }(THREE.Curve));
    THREE.SplineCurve = SplineCurve;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    THREE.CurveUtils = {
        tangentQuadraticBezier: function (t, p0, p1, p2) {
            return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
        },
        tangentCubicBezier: function (t, p0, p1, p2, p3) {
            return -3 * p0 * (1 - t) * (1 - t) +
                3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +
                6 * t * p2 * (1 - t) - 3 * t * t * p2 +
                3 * t * t * p3;
        },
        tangentSpline: function (t, p0, p1, p2, p3) {
            var h00 = 6 * t * t - 6 * t;
            var h10 = 3 * t * t - 4 * t + 1;
            var h01 = -6 * t * t + 6 * t;
            var h11 = 3 * t * t - 2 * t;
            return h00 + h10 + h01 + h11;
        },
        interpolate: function (p0, p1, p2, p3, t) {
            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            var t2 = t * t;
            var t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        }
    };
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var BoxBufferGeometry = (function (_super) {
        __extends(BoxBufferGeometry, _super);
        function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
            _super.call(this);
            this.type = 'BoxBufferGeometry';
            this.parameters = {
                width: width,
                height: height,
                depth: depth,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                depthSegments: depthSegments
            };
            var scope = this;
            widthSegments = THREE.Math.floor(widthSegments) || 1;
            heightSegments = THREE.Math.floor(heightSegments) || 1;
            depthSegments = THREE.Math.floor(depthSegments) || 1;
            var vertexCount = BoxBufferGeometry.calculateVertexCount(widthSegments, heightSegments, depthSegments);
            var indexCount = BoxBufferGeometry.calculateIndexCount(widthSegments, heightSegments, depthSegments);
            var indices = new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount);
            var vertices = new Float32Array(vertexCount * 3);
            var normals = new Float32Array(vertexCount * 3);
            var uvs = new Float32Array(vertexCount * 2);
            var vertexBufferOffset = 0;
            var uvBufferOffset = 0;
            var indexBufferOffset = 0;
            var numberOfVertices = 0;
            var groupStart = 0;
            buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0);
            buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
            buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2);
            buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
            buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4);
            buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
            this.setIndex(new THREE.BufferAttribute(indices, 1));
            this.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
            this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
            this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
            function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
                var segmentWidth = width / gridX;
                var segmentHeight = height / gridY;
                var widthHalf = width / 2;
                var heightHalf = height / 2;
                var depthHalf = depth / 2;
                var gridX1 = gridX + 1;
                var gridY1 = gridY + 1;
                var vertexCounter = 0;
                var groupCount = 0;
                var vector = new THREE.Vector3();
                for (var iy = 0; iy < gridY1; iy++) {
                    var y = iy * segmentHeight - heightHalf;
                    for (var ix = 0; ix < gridX1; ix++) {
                        var x = ix * segmentWidth - widthHalf;
                        vector[u] = x * udir;
                        vector[v] = y * vdir;
                        vector[w] = depthHalf;
                        vertices[vertexBufferOffset] = vector.x;
                        vertices[vertexBufferOffset + 1] = vector.y;
                        vertices[vertexBufferOffset + 2] = vector.z;
                        vector[u] = 0;
                        vector[v] = 0;
                        vector[w] = depth > 0 ? 1 : -1;
                        normals[vertexBufferOffset] = vector.x;
                        normals[vertexBufferOffset + 1] = vector.y;
                        normals[vertexBufferOffset + 2] = vector.z;
                        uvs[uvBufferOffset] = ix / gridX;
                        uvs[uvBufferOffset + 1] = 1 - (iy / gridY);
                        vertexBufferOffset += 3;
                        uvBufferOffset += 2;
                        vertexCounter += 1;
                    }
                }
                for (iy = 0; iy < gridY; iy++) {
                    for (ix = 0; ix < gridX; ix++) {
                        var a = numberOfVertices + ix + gridX1 * iy;
                        var b = numberOfVertices + ix + gridX1 * (iy + 1);
                        var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                        var d = numberOfVertices + (ix + 1) + gridX1 * iy;
                        indices[indexBufferOffset] = a;
                        indices[indexBufferOffset + 1] = b;
                        indices[indexBufferOffset + 2] = d;
                        indices[indexBufferOffset + 3] = b;
                        indices[indexBufferOffset + 4] = c;
                        indices[indexBufferOffset + 5] = d;
                        indexBufferOffset += 6;
                        groupCount += 6;
                    }
                }
                scope.addGroup(groupStart, groupCount, materialIndex);
                groupStart += groupCount;
                numberOfVertices += vertexCounter;
            }
        }
        ;
        BoxBufferGeometry.calculateVertexCount = function (w, h, d) {
            var vertices = 0;
            vertices += (w + 1) * (h + 1) * 2;
            vertices += (w + 1) * (d + 1) * 2;
            vertices += (d + 1) * (h + 1) * 2;
            return vertices;
        };
        BoxBufferGeometry.calculateIndexCount = function (w, h, d) {
            var index = 0;
            index += w * h * 2;
            index += w * d * 2;
            index += d * h * 2;
            return index * 6;
        };
        return BoxBufferGeometry;
    }(THREE.BufferGeometry));
    THREE.BoxBufferGeometry = BoxBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var BoxGeometry = (function (_super) {
        __extends(BoxGeometry, _super);
        function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
            _super.call(this);
            this.type = 'BoxGeometry';
            this.parameters = {
                width: width,
                height: height,
                depth: depth,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                depthSegments: depthSegments
            };
            this.fromBufferGeometry(new THREE.BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
            this.mergeVertices();
        }
        ;
        return BoxGeometry;
    }(THREE.Geometry));
    THREE.BoxGeometry = BoxGeometry;
    THREE.CubeGeometry = BoxGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var CircleBufferGeometry = (function (_super) {
        __extends(CircleBufferGeometry, _super);
        function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
            _super.call(this);
            this.type = 'CircleBufferGeometry';
            this.parameters = {
                radius: radius,
                segments: segments,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            radius = radius || 50;
            segments = segments !== undefined ? THREE.Math.max(3, segments) : 8;
            thetaStart = thetaStart !== undefined ? thetaStart : 0;
            thetaLength = thetaLength !== undefined ? thetaLength : THREE.Math.PI * 2;
            var vertices = segments + 2;
            var positions = new Float32Array(vertices * 3);
            var normals = new Float32Array(vertices * 3);
            var uvs = new Float32Array(vertices * 2);
            normals[2] = 1.0;
            uvs[0] = 0.5;
            uvs[1] = 0.5;
            for (var s = 0, i = 3, ii = 2; s <= segments; s++, i += 3, ii += 2) {
                var segment = thetaStart + s / segments * thetaLength;
                positions[i] = radius * THREE.Math.cos(segment);
                positions[i + 1] = radius * THREE.Math.sin(segment);
                normals[i + 2] = 1;
                uvs[ii] = (positions[i] / radius + 1) / 2;
                uvs[ii + 1] = (positions[i + 1] / radius + 1) / 2;
            }
            var indices = [];
            for (var i = 1; i <= segments; i++) {
                indices.push(i, i + 1, 0);
            }
            this.setIndex(new THREE.BufferAttribute(new Uint16Array(indices), 1));
            this.addAttribute('position', new THREE.BufferAttribute(positions, 3));
            this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
            this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
            this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
        }
        ;
        return CircleBufferGeometry;
    }(THREE.BufferGeometry));
    THREE.CircleBufferGeometry = CircleBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var CircleGeometry = (function (_super) {
        __extends(CircleGeometry, _super);
        function CircleGeometry(radius, segments, thetaStart, thetaLength) {
            _super.call(this);
            this.type = 'CircleGeometry';
            this.parameters = {
                radius: radius,
                segments: segments,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            this.fromBufferGeometry(new THREE.CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
        }
        ;
        return CircleGeometry;
    }(THREE.Geometry));
    THREE.CircleGeometry = CircleGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var CylinderBufferGeometry = (function (_super) {
        __extends(CylinderBufferGeometry, _super);
        function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
            _super.call(this);
            this.type = 'CylinderBufferGeometry';
            this.parameters = {
                radiusTop: radiusTop,
                radiusBottom: radiusBottom,
                height: height,
                radialSegments: radialSegments,
                heightSegments: heightSegments,
                openEnded: openEnded,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            var scope = this;
            radiusTop = radiusTop !== undefined ? radiusTop : 20;
            radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
            height = height !== undefined ? height : 100;
            radialSegments = THREE.Math.floor(radialSegments) || 8;
            heightSegments = THREE.Math.floor(heightSegments) || 1;
            openEnded = openEnded !== undefined ? openEnded : false;
            thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
            thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * THREE.Math.PI;
            var nbCap = 0;
            if (openEnded === false) {
                if (radiusTop > 0)
                    nbCap++;
                if (radiusBottom > 0)
                    nbCap++;
            }
            var vertexCount = calculateVertexCount();
            var indexCount = calculateIndexCount();
            var indices = new THREE.BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
            var vertices = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
            var normals = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
            var uvs = new THREE.BufferAttribute(new Float32Array(vertexCount * 2), 2);
            var index = 0, indexOffset = 0, indexArray = [], halfHeight = height / 2;
            var groupStart = 0;
            generateTorso();
            if (openEnded === false) {
                if (radiusTop > 0)
                    generateCap(true);
                if (radiusBottom > 0)
                    generateCap(false);
            }
            this.setIndex(indices);
            this.addAttribute('position', vertices);
            this.addAttribute('normal', normals);
            this.addAttribute('uv', uvs);
            function calculateVertexCount() {
                var count = (radialSegments + 1) * (heightSegments + 1);
                if (openEnded === false) {
                    count += ((radialSegments + 1) * nbCap) + (radialSegments * nbCap);
                }
                return count;
            }
            function calculateIndexCount() {
                var count = radialSegments * heightSegments * 2 * 3;
                if (openEnded === false) {
                    count += radialSegments * nbCap * 3;
                }
                return count;
            }
            function generateTorso() {
                var x, y;
                var normal = new THREE.Vector3();
                var vertex = new THREE.Vector3();
                var groupCount = 0;
                var tanTheta = (radiusBottom - radiusTop) / height;
                for (y = 0; y <= heightSegments; y++) {
                    var indexRow = [];
                    var v = y / heightSegments;
                    var radius = v * (radiusBottom - radiusTop) + radiusTop;
                    for (x = 0; x <= radialSegments; x++) {
                        var u = x / radialSegments;
                        vertex.x = radius * THREE.Math.sin(u * thetaLength + thetaStart);
                        vertex.y = -v * height + halfHeight;
                        vertex.z = radius * THREE.Math.cos(u * thetaLength + thetaStart);
                        vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
                        normal.copy(vertex);
                        if ((radiusTop === 0 && y === 0) || (radiusBottom === 0 && y === heightSegments)) {
                            normal.x = THREE.Math.sin(u * thetaLength + thetaStart);
                            normal.z = THREE.Math.cos(u * thetaLength + thetaStart);
                        }
                        normal.setY(THREE.Math.sqrt(normal.x * normal.x + normal.z * normal.z) * tanTheta).normalize();
                        normals.setXYZ(index, normal.x, normal.y, normal.z);
                        uvs.setXY(index, u, 1 - v);
                        indexRow.push(index);
                        index++;
                    }
                    indexArray.push(indexRow);
                }
                for (x = 0; x < radialSegments; x++) {
                    for (y = 0; y < heightSegments; y++) {
                        var i1 = indexArray[y][x];
                        var i2 = indexArray[y + 1][x];
                        var i3 = indexArray[y + 1][x + 1];
                        var i4 = indexArray[y][x + 1];
                        indices.setX(indexOffset, i1);
                        indexOffset++;
                        indices.setX(indexOffset, i2);
                        indexOffset++;
                        indices.setX(indexOffset, i4);
                        indexOffset++;
                        indices.setX(indexOffset, i2);
                        indexOffset++;
                        indices.setX(indexOffset, i3);
                        indexOffset++;
                        indices.setX(indexOffset, i4);
                        indexOffset++;
                        groupCount += 6;
                    }
                }
                scope.addGroup(groupStart, groupCount, 0);
                groupStart += groupCount;
            }
            function generateCap(top) {
                var x, centerIndexStart, centerIndexEnd;
                var uv = new THREE.Vector2();
                var vertex = new THREE.Vector3();
                var groupCount = 0;
                var radius = (top === true) ? radiusTop : radiusBottom;
                var sign = (top === true) ? 1 : -1;
                centerIndexStart = index;
                for (x = 1; x <= radialSegments; x++) {
                    vertices.setXYZ(index, 0, halfHeight * sign, 0);
                    normals.setXYZ(index, 0, sign, 0);
                    uv.x = 0.5;
                    uv.y = 0.5;
                    uvs.setXY(index, uv.x, uv.y);
                    index++;
                }
                centerIndexEnd = index;
                for (x = 0; x <= radialSegments; x++) {
                    var u = x / radialSegments;
                    var theta = u * thetaLength + thetaStart;
                    var cosTheta = THREE.Math.cos(theta);
                    var sinTheta = THREE.Math.sin(theta);
                    vertex.x = radius * sinTheta;
                    vertex.y = halfHeight * sign;
                    vertex.z = radius * cosTheta;
                    vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
                    normals.setXYZ(index, 0, sign, 0);
                    uv.x = (cosTheta * 0.5) + 0.5;
                    uv.y = (sinTheta * 0.5 * sign) + 0.5;
                    uvs.setXY(index, uv.x, uv.y);
                    index++;
                }
                for (x = 0; x < radialSegments; x++) {
                    var c = centerIndexStart + x;
                    var i = centerIndexEnd + x;
                    if (top === true) {
                        indices.setX(indexOffset, i);
                        indexOffset++;
                        indices.setX(indexOffset, i + 1);
                        indexOffset++;
                        indices.setX(indexOffset, c);
                        indexOffset++;
                    }
                    else {
                        indices.setX(indexOffset, i + 1);
                        indexOffset++;
                        indices.setX(indexOffset, i);
                        indexOffset++;
                        indices.setX(indexOffset, c);
                        indexOffset++;
                    }
                    groupCount += 3;
                }
                scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
                groupStart += groupCount;
            }
        }
        ;
        return CylinderBufferGeometry;
    }(THREE.BufferGeometry));
    THREE.CylinderBufferGeometry = CylinderBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var ConeBufferGeometry = (function (_super) {
        __extends(ConeBufferGeometry, _super);
        function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
            _super.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
            this.type = 'ConeBufferGeometry';
            this.parameters = {
                radius: radius,
                height: height,
                radialSegments: radialSegments,
                heightSegments: heightSegments,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
        }
        ;
        return ConeBufferGeometry;
    }(THREE.CylinderBufferGeometry));
    THREE.ConeBufferGeometry = ConeBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var CylinderGeometry = (function (_super) {
        __extends(CylinderGeometry, _super);
        function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
            _super.call(this);
            this.type = 'CylinderGeometry';
            this.parameters = {
                radiusTop: radiusTop,
                radiusBottom: radiusBottom,
                height: height,
                radialSegments: radialSegments,
                heightSegments: heightSegments,
                openEnded: openEnded,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            this.fromBufferGeometry(new THREE.CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
            this.mergeVertices();
        }
        ;
        return CylinderGeometry;
    }(THREE.Geometry));
    THREE.CylinderGeometry = CylinderGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var ConeGeometry = (function (_super) {
        __extends(ConeGeometry, _super);
        function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
            _super.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
            this.type = 'ConeGeometry';
            this.parameters = {
                radius: radius,
                height: height,
                radialSegments: radialSegments,
                heightSegments: heightSegments,
                openEnded: openEnded,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
        }
        ;
        return ConeGeometry;
    }(THREE.CylinderGeometry));
    THREE.ConeGeometry = ConeGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var PolyhedronGeometry = (function (_super) {
        __extends(PolyhedronGeometry, _super);
        function PolyhedronGeometry(vertices, indices, radius, detail) {
            _super.call(this);
            this.type = 'PolyhedronGeometry';
            this.parameters = {
                vertices: vertices,
                indices: indices,
                radius: radius,
                detail: detail
            };
            radius = radius || 1;
            detail = detail || 0;
            var that = this;
            for (var i = 0, l = vertices.length; i < l; i += 3) {
                prepare(new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));
            }
            var p = this.vertices;
            var faces = [];
            for (var i = 0, j = 0, l = indices.length; i < l; i += 3, j++) {
                var v1 = p[indices[i]];
                var v2 = p[indices[i + 1]];
                var v3 = p[indices[i + 2]];
                faces[j] = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()]);
            }
            var centroid = new THREE.Vector3();
            for (var i = 0, l = faces.length; i < l; i++) {
                subdivide(faces[i], detail);
            }
            for (var i = 0, l = this.faceVertexUvs[0].length; i < l; i++) {
                var uvs = this.faceVertexUvs[0][i];
                var x0 = uvs[0].x;
                var x1 = uvs[1].x;
                var x2 = uvs[2].x;
                var max = THREE.Math.max(x0, x1, x2);
                var min = THREE.Math.min(x0, x1, x2);
                if (max > 0.9 && min < 0.1) {
                    if (x0 < 0.2)
                        uvs[0].x += 1;
                    if (x1 < 0.2)
                        uvs[1].x += 1;
                    if (x2 < 0.2)
                        uvs[2].x += 1;
                }
            }
            for (var i = 0, l = this.vertices.length; i < l; i++) {
                this.vertices[i].multiplyScalar(radius);
            }
            this.mergeVertices();
            this.computeFaceNormals();
            this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
            function prepare(vector) {
                var vertex = vector.normalize().clone();
                vertex.index = that.vertices.push(vertex) - 1;
                var u = azimuth(vector) / 2 / THREE.Math.PI + 0.5;
                var v = inclination(vector) / THREE.Math.PI + 0.5;
                vertex.uv = new THREE.Vector2(u, 1 - v);
                return vertex;
            }
            function make(v1, v2, v3) {
                var face = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()]);
                that.faces.push(face);
                centroid.copy(v1).add(v2).add(v3).divideScalar(3);
                var azi = azimuth(centroid);
                that.faceVertexUvs[0].push([
                    correctUV(v1.uv, v1, azi),
                    correctUV(v2.uv, v2, azi),
                    correctUV(v3.uv, v3, azi)
                ]);
            }
            function subdivide(face, detail) {
                var cols = THREE.Math.pow(2, detail);
                var a = prepare(that.vertices[face.a]);
                var b = prepare(that.vertices[face.b]);
                var c = prepare(that.vertices[face.c]);
                var v = [];
                for (var i = 0; i <= cols; i++) {
                    v[i] = [];
                    var aj = prepare(a.clone().lerp(c, i / cols));
                    var bj = prepare(b.clone().lerp(c, i / cols));
                    var rows = cols - i;
                    for (var j = 0; j <= rows; j++) {
                        if (j === 0 && i === cols) {
                            v[i][j] = aj;
                        }
                        else {
                            v[i][j] = prepare(aj.clone().lerp(bj, j / rows));
                        }
                    }
                }
                for (var i = 0; i < cols; i++) {
                    for (var j = 0; j < 2 * (cols - i) - 1; j++) {
                        var k = THREE.Math.floor(j / 2);
                        if (j % 2 === 0) {
                            make(v[i][k + 1], v[i + 1][k], v[i][k]);
                        }
                        else {
                            make(v[i][k + 1], v[i + 1][k + 1], v[i + 1][k]);
                        }
                    }
                }
            }
            function azimuth(vector) {
                return THREE.Math.atan2(vector.z, -vector.x);
            }
            function inclination(vector) {
                return THREE.Math.atan2(-vector.y, THREE.Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
            }
            function correctUV(uv, vector, azimuth) {
                if ((azimuth < 0) && (uv.x === 1))
                    uv = new THREE.Vector2(uv.x - 1, uv.y);
                if ((vector.x === 0) && (vector.z === 0))
                    uv = new THREE.Vector2(azimuth / 2 / THREE.Math.PI + 0.5, uv.y);
                return uv.clone();
            }
        }
        ;
        return PolyhedronGeometry;
    }(THREE.Geometry));
    THREE.PolyhedronGeometry = PolyhedronGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var DodecahedronGeometry = (function (_super) {
        __extends(DodecahedronGeometry, _super);
        function DodecahedronGeometry(radius, detail) {
            var t = (1 + THREE.Math.sqrt(5)) / 2;
            var r = 1 / t;
            var vertices = [
                -1, -1, -1, -1, -1, 1,
                -1, 1, -1, -1, 1, 1,
                1, -1, -1, 1, -1, 1,
                1, 1, -1, 1, 1, 1,
                0, -r, -t, 0, -r, t,
                0, r, -t, 0, r, t,
                -r, -t, 0, -r, t, 0,
                r, -t, 0, r, t, 0,
                -t, 0, -r, t, 0, -r,
                -t, 0, r, t, 0, r
            ];
            var indices = [
                3, 11, 7, 3, 7, 15, 3, 15, 13,
                7, 19, 17, 7, 17, 6, 7, 6, 15,
                17, 4, 8, 17, 8, 10, 17, 10, 6,
                8, 0, 16, 8, 16, 2, 8, 2, 10,
                0, 12, 1, 0, 1, 18, 0, 18, 16,
                6, 10, 2, 6, 2, 13, 6, 13, 15,
                2, 16, 18, 2, 18, 3, 2, 3, 13,
                18, 1, 9, 18, 9, 11, 18, 11, 3,
                4, 14, 12, 4, 12, 0, 4, 0, 8,
                11, 9, 5, 11, 5, 19, 11, 19, 7,
                19, 5, 14, 19, 14, 4, 19, 4, 17,
                1, 12, 14, 1, 14, 5, 1, 5, 9
            ];
            _super.call(this, vertices, indices, radius, detail);
            this.type = 'DodecahedronGeometry';
            this.parameters = {
                radius: radius,
                detail: detail
            };
        }
        ;
        return DodecahedronGeometry;
    }(THREE.PolyhedronGeometry));
    THREE.DodecahedronGeometry = DodecahedronGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var EdgesGeometry = (function (_super) {
        __extends(EdgesGeometry, _super);
        function EdgesGeometry(geometry, thresholdAngle) {
            _super.call(this);
            thresholdAngle = (thresholdAngle !== undefined) ? thresholdAngle : 1;
            var thresholdDot = THREE.Math.cos(THREE.Math.DEG2RAD * thresholdAngle);
            var edge = [0, 0], hash = {};
            function sortFunction(a, b) {
                return a - b;
            }
            var keys = ['a', 'b', 'c'];
            var geometry2;
            if (geometry instanceof THREE.BufferGeometry) {
                geometry2 = new THREE.Geometry();
                geometry2.fromBufferGeometry(geometry);
            }
            else {
                geometry2 = geometry.clone();
            }
            geometry2.mergeVertices();
            geometry2.computeFaceNormals();
            var vertices = geometry2.vertices;
            var faces = geometry2.faces;
            for (var i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                for (var j = 0; j < 3; j++) {
                    edge[0] = face[keys[j]];
                    edge[1] = face[keys[(j + 1) % 3]];
                    edge.sort(sortFunction);
                    var key = edge.toString();
                    if (hash[key] === undefined) {
                        hash[key] = { vert1: edge[0], vert2: edge[1], face1: i, face2: undefined };
                    }
                    else {
                        hash[key].face2 = i;
                    }
                }
            }
            var coords = [];
            for (var key in hash) {
                var h = hash[key];
                if (h.face2 === undefined || faces[h.face1].normal.dot(faces[h.face2].normal) <= thresholdDot) {
                    var vertex = vertices[h.vert1];
                    coords.push(vertex.x);
                    coords.push(vertex.y);
                    coords.push(vertex.z);
                    vertex = vertices[h.vert2];
                    coords.push(vertex.x);
                    coords.push(vertex.y);
                    coords.push(vertex.z);
                }
            }
            this.addAttribute('position', new THREE.BufferAttribute(new Float32Array(coords), 3));
        }
        ;
        return EdgesGeometry;
    }(THREE.BufferGeometry));
    THREE.EdgesGeometry = EdgesGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var ExtrudeGeometry = (function (_super) {
        __extends(ExtrudeGeometry, _super);
        function ExtrudeGeometry(ashapes, options) {
            _super.call(this);
            var shapes = ashapes;
            if (typeof (shapes) === "undefined") {
                shapes = [];
                return;
            }
            this.type = 'ExtrudeGeometry';
            shapes = Array.isArray(shapes) ? shapes : [shapes];
            this.addShapeList(shapes, options);
            this.computeFaceNormals();
        }
        ;
        ExtrudeGeometry.prototype.addShapeList = function (shapes, options) {
            var sl = shapes.length;
            for (var s = 0; s < sl; s++) {
                var shape = shapes[s];
                this.addShape(shape, options);
            }
        };
        ;
        ExtrudeGeometry.prototype.addShape = function (shape, options) {
            var amount = options.amount !== undefined ? options.amount : 100;
            var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
            var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
            var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
            var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
            var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
            var steps = options.steps !== undefined ? options.steps : 1;
            var extrudePath = options.extrudePath;
            var extrudePts, extrudeByPath = false;
            var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;
            var splineTube, binormal, normal, position2;
            if (extrudePath) {
                extrudePts = extrudePath.getSpacedPoints(steps);
                extrudeByPath = true;
                bevelEnabled = false;
                splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);
                binormal = new THREE.Vector3();
                normal = new THREE.Vector3();
                position2 = new THREE.Vector3();
            }
            if (!bevelEnabled) {
                bevelSegments = 0;
                bevelThickness = 0;
                bevelSize = 0;
            }
            var ahole, h, hl;
            var scope = this;
            var shapesOffset = this.vertices.length;
            var shapePoints = shape.extractPoints(curveSegments);
            var vertices = shapePoints.shape;
            var holes = shapePoints.holes;
            var reverse = !THREE.ShapeUtils.isClockWise(vertices);
            if (reverse) {
                vertices = vertices.reverse();
                for (h = 0, hl = holes.length; h < hl; h++) {
                    ahole = holes[h];
                    if (THREE.ShapeUtils.isClockWise(ahole)) {
                        holes[h] = ahole.reverse();
                    }
                }
                reverse = false;
            }
            var faces = THREE.ShapeUtils.triangulateShape(vertices, holes);
            var contour = vertices;
            for (h = 0, hl = holes.length; h < hl; h++) {
                ahole = holes[h];
                vertices = vertices.concat(ahole);
            }
            function scalePt2(pt, vec, size) {
                if (!vec)
                    console.error("THREE.ExtrudeGeometry: vec does not exist");
                return vec.clone().multiplyScalar(size).add(pt);
            }
            var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length;
            function getBevelVec(inPt, inPrev, inNext) {
                var v_trans_x, v_trans_y, shrink_by = 1;
                var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
                var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
                var v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);
                var collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);
                if (THREE.Math.abs(collinear0) > Number.EPSILON) {
                    var v_prev_len = THREE.Math.sqrt(v_prev_lensq);
                    var v_next_len = THREE.Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                    var ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
                    var ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);
                    var ptNextShift_x = (inNext.x - v_next_y / v_next_len);
                    var ptNextShift_y = (inNext.y + v_next_x / v_next_len);
                    var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y -
                        (ptNextShift_y - ptPrevShift_y) * v_next_x) /
                        (v_prev_x * v_next_y - v_prev_y * v_next_x);
                    v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
                    v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);
                    var v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
                    if (v_trans_lensq <= 2) {
                        return new THREE.Vector2(v_trans_x, v_trans_y);
                    }
                    else {
                        shrink_by = THREE.Math.sqrt(v_trans_lensq / 2);
                    }
                }
                else {
                    var direction_eq = false;
                    if (v_prev_x > Number.EPSILON) {
                        if (v_next_x > Number.EPSILON) {
                            direction_eq = true;
                        }
                    }
                    else {
                        if (v_prev_x < -Number.EPSILON) {
                            if (v_next_x < -Number.EPSILON) {
                                direction_eq = true;
                            }
                        }
                        else {
                            if (THREE.Math.sign(v_prev_y) === THREE.Math.sign(v_next_y)) {
                                direction_eq = true;
                            }
                        }
                    }
                    if (direction_eq) {
                        v_trans_x = -v_prev_y;
                        v_trans_y = v_prev_x;
                        shrink_by = THREE.Math.sqrt(v_prev_lensq);
                    }
                    else {
                        v_trans_x = v_prev_x;
                        v_trans_y = v_prev_y;
                        shrink_by = THREE.Math.sqrt(v_prev_lensq / 2);
                    }
                }
                return new THREE.Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
            }
            var contourMovements = [];
            for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                if (j === il)
                    j = 0;
                if (k === il)
                    k = 0;
                contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
            }
            var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
            for (h = 0, hl = holes.length; h < hl; h++) {
                ahole = holes[h];
                oneHoleMovements = [];
                for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                    if (j === il)
                        j = 0;
                    if (k === il)
                        k = 0;
                    oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
                }
                holesMovements.push(oneHoleMovements);
                verticesMovements = verticesMovements.concat(oneHoleMovements);
            }
            for (b = 0; b < bevelSegments; b++) {
                t = b / bevelSegments;
                z = bevelThickness * (1 - t);
                bs = bevelSize * (THREE.Math.sin(t * THREE.Math.PI / 2));
                for (i = 0, il = contour.length; i < il; i++) {
                    vert = scalePt2(contour[i], contourMovements[i], bs);
                    v(vert.x, vert.y, -z);
                }
                for (h = 0, hl = holes.length; h < hl; h++) {
                    ahole = holes[h];
                    oneHoleMovements = holesMovements[h];
                    for (i = 0, il = ahole.length; i < il; i++) {
                        vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                        v(vert.x, vert.y, -z);
                    }
                }
            }
            bs = bevelSize;
            for (i = 0; i < vlen; i++) {
                vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                if (!extrudeByPath) {
                    v(vert.x, vert.y, 0);
                }
                else {
                    normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                    binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                    position2.copy(extrudePts[0]).add(normal).add(binormal);
                    v(position2.x, position2.y, position2.z);
                }
            }
            var s;
            for (s = 1; s <= steps; s++) {
                for (i = 0; i < vlen; i++) {
                    vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                    if (!extrudeByPath) {
                        v(vert.x, vert.y, amount / steps * s);
                    }
                    else {
                        normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                        binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                        position2.copy(extrudePts[s]).add(normal).add(binormal);
                        v(position2.x, position2.y, position2.z);
                    }
                }
            }
            for (b = bevelSegments - 1; b >= 0; b--) {
                t = b / bevelSegments;
                z = bevelThickness * (1 - t);
                bs = bevelSize * THREE.Math.sin(t * THREE.Math.PI / 2);
                for (i = 0, il = contour.length; i < il; i++) {
                    vert = scalePt2(contour[i], contourMovements[i], bs);
                    v(vert.x, vert.y, amount + z);
                }
                for (h = 0, hl = holes.length; h < hl; h++) {
                    ahole = holes[h];
                    oneHoleMovements = holesMovements[h];
                    for (i = 0, il = ahole.length; i < il; i++) {
                        vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                        if (!extrudeByPath) {
                            v(vert.x, vert.y, amount + z);
                        }
                        else {
                            v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                        }
                    }
                }
            }
            buildLidFaces();
            buildSideFaces();
            function buildLidFaces() {
                if (bevelEnabled) {
                    var layer = 0;
                    var offset = vlen * layer;
                    for (i = 0; i < flen; i++) {
                        face = faces[i];
                        f3(face[2] + offset, face[1] + offset, face[0] + offset);
                    }
                    layer = steps + bevelSegments * 2;
                    offset = vlen * layer;
                    for (i = 0; i < flen; i++) {
                        face = faces[i];
                        f3(face[0] + offset, face[1] + offset, face[2] + offset);
                    }
                }
                else {
                    for (i = 0; i < flen; i++) {
                        face = faces[i];
                        f3(face[2], face[1], face[0]);
                    }
                    for (i = 0; i < flen; i++) {
                        face = faces[i];
                        f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                    }
                }
            }
            function buildSideFaces() {
                var layeroffset = 0;
                sidewalls(contour, layeroffset);
                layeroffset += contour.length;
                for (h = 0, hl = holes.length; h < hl; h++) {
                    ahole = holes[h];
                    sidewalls(ahole, layeroffset);
                    layeroffset += ahole.length;
                }
            }
            function sidewalls(contour, layeroffset) {
                var j, k;
                i = contour.length;
                while (--i >= 0) {
                    j = i;
                    k = i - 1;
                    if (k < 0)
                        k = contour.length - 1;
                    var s = 0, sl = steps + bevelSegments * 2;
                    for (s = 0; s < sl; s++) {
                        var slen1 = vlen * s;
                        var slen2 = vlen * (s + 1);
                        var a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                        f4(a, b, c, d, contour, s, sl, j, k);
                    }
                }
            }
            function v(x, y, z) {
                scope.vertices.push(new THREE.Vector3(x, y, z));
            }
            function f3(a, b, c) {
                a += shapesOffset;
                b += shapesOffset;
                c += shapesOffset;
                scope.faces.push(new THREE.Face3(a, b, c, null, null, 0));
                var uvs = uvgen.generateTopUV(scope, a, b, c);
                scope.faceVertexUvs[0].push(uvs);
            }
            function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
                a += shapesOffset;
                b += shapesOffset;
                c += shapesOffset;
                d += shapesOffset;
                scope.faces.push(new THREE.Face3(a, b, d, null, null, 1));
                scope.faces.push(new THREE.Face3(b, c, d, null, null, 1));
                var uvs = uvgen.generateSideWallUV(scope, a, b, c, d);
                scope.faceVertexUvs[0].push([uvs[0], uvs[1], uvs[3]]);
                scope.faceVertexUvs[0].push([uvs[1], uvs[2], uvs[3]]);
            }
        };
        ;
        ExtrudeGeometry.WorldUVGenerator = {
            generateTopUV: function (geometry, indexA, indexB, indexC) {
                var vertices = geometry.vertices;
                var a = vertices[indexA];
                var b = vertices[indexB];
                var c = vertices[indexC];
                return [
                    new THREE.Vector2(a.x, a.y),
                    new THREE.Vector2(b.x, b.y),
                    new THREE.Vector2(c.x, c.y)
                ];
            },
            generateSideWallUV: function (geometry, indexA, indexB, indexC, indexD) {
                var vertices = geometry.vertices;
                var a = vertices[indexA];
                var b = vertices[indexB];
                var c = vertices[indexC];
                var d = vertices[indexD];
                if (THREE.Math.abs(a.y - b.y) < 0.01) {
                    return [
                        new THREE.Vector2(a.x, 1 - a.z),
                        new THREE.Vector2(b.x, 1 - b.z),
                        new THREE.Vector2(c.x, 1 - c.z),
                        new THREE.Vector2(d.x, 1 - d.z)
                    ];
                }
                else {
                    return [
                        new THREE.Vector2(a.y, 1 - a.z),
                        new THREE.Vector2(b.y, 1 - b.z),
                        new THREE.Vector2(c.y, 1 - c.z),
                        new THREE.Vector2(d.y, 1 - d.z)
                    ];
                }
            }
        };
        return ExtrudeGeometry;
    }(THREE.Geometry));
    THREE.ExtrudeGeometry = ExtrudeGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var IcosahedronGeometry = (function (_super) {
        __extends(IcosahedronGeometry, _super);
        function IcosahedronGeometry(radius, detail) {
            var t = (1 + THREE.Math.sqrt(5)) / 2;
            var vertices = [
                -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0,
                0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t,
                t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1
            ];
            var indices = [
                0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11,
                1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8,
                3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
                4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
            ];
            _super.call(this, vertices, indices, radius, detail);
            this.type = 'IcosahedronGeometry';
            this.parameters = {
                radius: radius,
                detail: detail
            };
        }
        ;
        return IcosahedronGeometry;
    }(THREE.PolyhedronGeometry));
    THREE.IcosahedronGeometry = IcosahedronGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var LatheBufferGeometry = (function (_super) {
        __extends(LatheBufferGeometry, _super);
        function LatheBufferGeometry(points, segments, phiStart, phiLength) {
            _super.call(this);
            this.type = 'LatheBufferGeometry';
            this.parameters = {
                points: points,
                segments: segments,
                phiStart: phiStart,
                phiLength: phiLength
            };
            segments = THREE.Math.floor(segments) || 12;
            phiStart = phiStart || 0;
            phiLength = phiLength || THREE.Math.PI * 2;
            phiLength = THREE.Math.clamp(phiLength, 0, THREE.Math.PI * 2);
            var vertexCount = (segments + 1) * points.length;
            var indexCount = segments * points.length * 2 * 3;
            var indices = new THREE.BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
            var vertices = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
            var uvs = new THREE.BufferAttribute(new Float32Array(vertexCount * 2), 2);
            var index = 0, indexOffset = 0, base;
            var inversePointLength = 1.0 / (points.length - 1);
            var inverseSegments = 1.0 / segments;
            var vertex = new THREE.Vector3();
            var uv = new THREE.Vector2();
            var i, j;
            for (i = 0; i <= segments; i++) {
                var phi = phiStart + i * inverseSegments * phiLength;
                var sin = THREE.Math.sin(phi);
                var cos = THREE.Math.cos(phi);
                for (j = 0; j <= (points.length - 1); j++) {
                    vertex.x = points[j].x * sin;
                    vertex.y = points[j].y;
                    vertex.z = points[j].x * cos;
                    vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
                    uv.x = i / segments;
                    uv.y = j / (points.length - 1);
                    uvs.setXY(index, uv.x, uv.y);
                    index++;
                }
            }
            for (i = 0; i < segments; i++) {
                for (j = 0; j < (points.length - 1); j++) {
                    base = j + i * points.length;
                    var a = base;
                    var b = base + points.length;
                    var c = base + points.length + 1;
                    var d = base + 1;
                    indices.setX(indexOffset, a);
                    indexOffset++;
                    indices.setX(indexOffset, b);
                    indexOffset++;
                    indices.setX(indexOffset, d);
                    indexOffset++;
                    indices.setX(indexOffset, b);
                    indexOffset++;
                    indices.setX(indexOffset, c);
                    indexOffset++;
                    indices.setX(indexOffset, d);
                    indexOffset++;
                }
            }
            this.setIndex(indices);
            this.addAttribute('position', vertices);
            this.addAttribute('uv', uvs);
            this.computeVertexNormals();
            if (phiLength === THREE.Math.PI * 2) {
                var normals = this.attributes.normal.array;
                var n1 = new THREE.Vector3();
                var n2 = new THREE.Vector3();
                var n = new THREE.Vector3();
                base = segments * points.length * 3;
                for (i = 0, j = 0; i < points.length; i++, j += 3) {
                    n1.x = normals[j + 0];
                    n1.y = normals[j + 1];
                    n1.z = normals[j + 2];
                    n2.x = normals[base + j + 0];
                    n2.y = normals[base + j + 1];
                    n2.z = normals[base + j + 2];
                    n.addVectors(n1, n2).normalize();
                    normals[j + 0] = normals[base + j + 0] = n.x;
                    normals[j + 1] = normals[base + j + 1] = n.y;
                    normals[j + 2] = normals[base + j + 2] = n.z;
                }
            }
        }
        ;
        return LatheBufferGeometry;
    }(THREE.BufferGeometry));
    THREE.LatheBufferGeometry = LatheBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var LatheGeometry = (function (_super) {
        __extends(LatheGeometry, _super);
        function LatheGeometry(points, segments, phiStart, phiLength) {
            _super.call(this);
            this.type = 'LatheGeometry';
            this.parameters = {
                points: points,
                segments: segments,
                phiStart: phiStart,
                phiLength: phiLength
            };
            this.fromBufferGeometry(new THREE.LatheBufferGeometry(points, segments, phiStart, phiLength));
            this.mergeVertices();
        }
        return LatheGeometry;
    }(THREE.Geometry));
    THREE.LatheGeometry = LatheGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var OctahedronGeometry = (function (_super) {
        __extends(OctahedronGeometry, _super);
        function OctahedronGeometry(radius, detail) {
            var vertices = [
                1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1
            ];
            var indices = [
                0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2
            ];
            _super.call(this, vertices, indices, radius, detail);
            this.type = 'OctahedronGeometry';
            this.parameters = {
                radius: radius,
                detail: detail
            };
        }
        ;
        return OctahedronGeometry;
    }(THREE.PolyhedronGeometry));
    THREE.OctahedronGeometry = OctahedronGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var ParametricGeometry = (function (_super) {
        __extends(ParametricGeometry, _super);
        function ParametricGeometry(func, slices, stacks) {
            _super.call(this);
            this.type = 'ParametricGeometry';
            this.parameters = {
                func: func,
                slices: slices,
                stacks: stacks
            };
            var verts = this.vertices;
            var faces = this.faces;
            var uvs = this.faceVertexUvs[0];
            var i, j, p;
            var u, v;
            var sliceCount = slices + 1;
            for (i = 0; i <= stacks; i++) {
                v = i / stacks;
                for (j = 0; j <= slices; j++) {
                    u = j / slices;
                    p = func(u, v);
                    verts.push(p);
                }
            }
            var a, b, c, d;
            var uva, uvb, uvc, uvd;
            for (i = 0; i < stacks; i++) {
                for (j = 0; j < slices; j++) {
                    a = i * sliceCount + j;
                    b = i * sliceCount + j + 1;
                    c = (i + 1) * sliceCount + j + 1;
                    d = (i + 1) * sliceCount + j;
                    uva = new THREE.Vector2(j / slices, i / stacks);
                    uvb = new THREE.Vector2((j + 1) / slices, i / stacks);
                    uvc = new THREE.Vector2((j + 1) / slices, (i + 1) / stacks);
                    uvd = new THREE.Vector2(j / slices, (i + 1) / stacks);
                    faces.push(new THREE.Face3(a, b, d));
                    uvs.push([uva, uvb, uvd]);
                    faces.push(new THREE.Face3(b, c, d));
                    uvs.push([uvb.clone(), uvc, uvd.clone()]);
                }
            }
            this.computeFaceNormals();
            this.computeVertexNormals();
        }
        ;
        return ParametricGeometry;
    }(THREE.Geometry));
    THREE.ParametricGeometry = ParametricGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var PlaneBufferGeometry = (function (_super) {
        __extends(PlaneBufferGeometry, _super);
        function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
            _super.call(this);
            this.type = 'PlaneBufferGeometry';
            this.parameters = {
                width: width,
                height: height,
                widthSegments: widthSegments,
                heightSegments: heightSegments
            };
            var width_half = width / 2;
            var height_half = height / 2;
            var gridX = THREE.Math.floor(widthSegments) || 1;
            var gridY = THREE.Math.floor(heightSegments) || 1;
            var gridX1 = gridX + 1;
            var gridY1 = gridY + 1;
            var segment_width = width / gridX;
            var segment_height = height / gridY;
            var vertices = new Float32Array(gridX1 * gridY1 * 3);
            var normals = new Float32Array(gridX1 * gridY1 * 3);
            var uvs = new Float32Array(gridX1 * gridY1 * 2);
            var offset = 0;
            var offset2 = 0;
            for (var iy = 0; iy < gridY1; iy++) {
                var y = iy * segment_height - height_half;
                for (var ix = 0; ix < gridX1; ix++) {
                    var x = ix * segment_width - width_half;
                    vertices[offset] = x;
                    vertices[offset + 1] = -y;
                    normals[offset + 2] = 1;
                    uvs[offset2] = ix / gridX;
                    uvs[offset2 + 1] = 1 - (iy / gridY);
                    offset += 3;
                    offset2 += 2;
                }
            }
            offset = 0;
            var indices = new ((vertices.length / 3) > 65535 ? Uint32Array : Uint16Array)(gridX * gridY * 6);
            for (var iy = 0; iy < gridY; iy++) {
                for (var ix = 0; ix < gridX; ix++) {
                    var a = ix + gridX1 * iy;
                    var b = ix + gridX1 * (iy + 1);
                    var c = (ix + 1) + gridX1 * (iy + 1);
                    var d = (ix + 1) + gridX1 * iy;
                    indices[offset] = a;
                    indices[offset + 1] = b;
                    indices[offset + 2] = d;
                    indices[offset + 3] = b;
                    indices[offset + 4] = c;
                    indices[offset + 5] = d;
                    offset += 6;
                }
            }
            this.setIndex(new THREE.BufferAttribute(indices, 1));
            this.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
            this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
            this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
        }
        ;
        return PlaneBufferGeometry;
    }(THREE.BufferGeometry));
    THREE.PlaneBufferGeometry = PlaneBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var PlaneGeometry = (function (_super) {
        __extends(PlaneGeometry, _super);
        function PlaneGeometry(width, height, widthSegments, heightSegments) {
            _super.call(this);
            this.type = 'PlaneGeometry';
            this.parameters = {
                width: width,
                height: height,
                widthSegments: widthSegments,
                heightSegments: heightSegments
            };
            this.fromBufferGeometry(new THREE.PlaneBufferGeometry(width, height, widthSegments, heightSegments));
        }
        ;
        return PlaneGeometry;
    }(THREE.Geometry));
    THREE.PlaneGeometry = PlaneGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var RingBufferGeometry = (function (_super) {
        __extends(RingBufferGeometry, _super);
        function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
            _super.call(this);
            this.type = 'RingBufferGeometry';
            this.parameters = {
                innerRadius: innerRadius,
                outerRadius: outerRadius,
                thetaSegments: thetaSegments,
                phiSegments: phiSegments,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            innerRadius = innerRadius || 20;
            outerRadius = outerRadius || 50;
            thetaStart = thetaStart !== undefined ? thetaStart : 0;
            thetaLength = thetaLength !== undefined ? thetaLength : THREE.Math.PI * 2;
            thetaSegments = thetaSegments !== undefined ? THREE.Math.max(3, thetaSegments) : 8;
            phiSegments = phiSegments !== undefined ? THREE.Math.max(1, phiSegments) : 1;
            var vertexCount = (thetaSegments + 1) * (phiSegments + 1);
            var indexCount = thetaSegments * phiSegments * 2 * 3;
            var indices = new THREE.BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
            var vertices = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
            var normals = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
            var uvs = new THREE.BufferAttribute(new Float32Array(vertexCount * 2), 2);
            var index = 0, indexOffset = 0, segment;
            var radius = innerRadius;
            var radiusStep = ((outerRadius - innerRadius) / phiSegments);
            var vertex = new THREE.Vector3();
            var uv = new THREE.Vector2();
            var j, i;
            for (j = 0; j <= phiSegments; j++) {
                for (i = 0; i <= thetaSegments; i++) {
                    segment = thetaStart + i / thetaSegments * thetaLength;
                    vertex.x = radius * THREE.Math.cos(segment);
                    vertex.y = radius * THREE.Math.sin(segment);
                    vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
                    normals.setXYZ(index, 0, 0, 1);
                    uv.x = (vertex.x / outerRadius + 1) / 2;
                    uv.y = (vertex.y / outerRadius + 1) / 2;
                    uvs.setXY(index, uv.x, uv.y);
                    index++;
                }
                radius += radiusStep;
            }
            for (j = 0; j < phiSegments; j++) {
                var thetaSegmentLevel = j * (thetaSegments + 1);
                for (i = 0; i < thetaSegments; i++) {
                    segment = i + thetaSegmentLevel;
                    var a = segment;
                    var b = segment + thetaSegments + 1;
                    var c = segment + thetaSegments + 2;
                    var d = segment + 1;
                    indices.setX(indexOffset, a);
                    indexOffset++;
                    indices.setX(indexOffset, b);
                    indexOffset++;
                    indices.setX(indexOffset, c);
                    indexOffset++;
                    indices.setX(indexOffset, a);
                    indexOffset++;
                    indices.setX(indexOffset, c);
                    indexOffset++;
                    indices.setX(indexOffset, d);
                    indexOffset++;
                }
            }
            this.setIndex(indices);
            this.addAttribute('position', vertices);
            this.addAttribute('normal', normals);
            this.addAttribute('uv', uvs);
        }
        ;
        return RingBufferGeometry;
    }(THREE.BufferGeometry));
    THREE.RingBufferGeometry = RingBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var RingGeometry = (function (_super) {
        __extends(RingGeometry, _super);
        function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
            _super.call(this);
            this.type = 'RingGeometry';
            this.parameters = {
                innerRadius: innerRadius,
                outerRadius: outerRadius,
                thetaSegments: thetaSegments,
                phiSegments: phiSegments,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            this.fromBufferGeometry(new THREE.RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
        }
        ;
        return RingGeometry;
    }(THREE.Geometry));
    THREE.RingGeometry = RingGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var ShapeGeometry = (function (_super) {
        __extends(ShapeGeometry, _super);
        function ShapeGeometry(ashapes, options) {
            _super.call(this);
            this.type = 'ShapeGeometry';
            var shapes = ashapes;
            if (Array.isArray(ashapes) === false)
                shapes = [ashapes];
            this.addShapeList(shapes, options);
            this.computeFaceNormals();
        }
        ;
        ShapeGeometry.prototype.addShapeList = function (shapes, options) {
            for (var i = 0, l = shapes.length; i < l; i++) {
                this.addShape(shapes[i], options);
            }
            return this;
        };
        ;
        ShapeGeometry.prototype.addShape = function (shape, options) {
            if (options === undefined)
                options = {};
            var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
            var material = options.material;
            var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
            var i, l, hole;
            var shapesOffset = this.vertices.length;
            var shapePoints = shape.extractPoints(curveSegments);
            var vertices = shapePoints.shape;
            var holes = shapePoints.holes;
            var reverse = !THREE.ShapeUtils.isClockWise(vertices);
            if (reverse) {
                vertices = vertices.reverse();
                for (i = 0, l = holes.length; i < l; i++) {
                    hole = holes[i];
                    if (THREE.ShapeUtils.isClockWise(hole)) {
                        holes[i] = hole.reverse();
                    }
                }
                reverse = false;
            }
            var faces = THREE.ShapeUtils.triangulateShape(vertices, holes);
            for (i = 0, l = holes.length; i < l; i++) {
                hole = holes[i];
                vertices = vertices.concat(hole);
            }
            var vert, vlen = vertices.length;
            var face, flen = faces.length;
            for (i = 0; i < vlen; i++) {
                vert = vertices[i];
                this.vertices.push(new THREE.Vector3(vert.x, vert.y, 0));
            }
            for (i = 0; i < flen; i++) {
                face = faces[i];
                var a = face[0] + shapesOffset;
                var b = face[1] + shapesOffset;
                var c = face[2] + shapesOffset;
                this.faces.push(new THREE.Face3(a, b, c, null, null, material));
                this.faceVertexUvs[0].push(uvgen.generateTopUV(this, a, b, c));
            }
        };
        ;
        return ShapeGeometry;
    }(THREE.Geometry));
    THREE.ShapeGeometry = ShapeGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var SphereBufferGeometry = (function (_super) {
        __extends(SphereBufferGeometry, _super);
        function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
            _super.call(this);
            this.type = 'SphereBufferGeometry';
            this.parameters = {
                radius: radius,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                phiStart: phiStart,
                phiLength: phiLength,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            radius = radius || 50;
            widthSegments = THREE.Math.max(3, THREE.Math.floor(widthSegments) || 8);
            heightSegments = THREE.Math.max(2, THREE.Math.floor(heightSegments) || 6);
            phiStart = phiStart !== undefined ? phiStart : 0;
            phiLength = phiLength !== undefined ? phiLength : THREE.Math.PI * 2;
            thetaStart = thetaStart !== undefined ? thetaStart : 0;
            thetaLength = thetaLength !== undefined ? thetaLength : THREE.Math.PI;
            var thetaEnd = thetaStart + thetaLength;
            var vertexCount = ((widthSegments + 1) * (heightSegments + 1));
            var positions = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
            var normals = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
            var uvs = new THREE.BufferAttribute(new Float32Array(vertexCount * 2), 2);
            var index = 0, vertices = [], normal = new THREE.Vector3();
            for (var y = 0; y <= heightSegments; y++) {
                var verticesRow = [];
                var v = y / heightSegments;
                for (var x = 0; x <= widthSegments; x++) {
                    var u = x / widthSegments;
                    var px = -radius * THREE.Math.cos(phiStart + u * phiLength) * THREE.Math.sin(thetaStart + v * thetaLength);
                    var py = radius * THREE.Math.cos(thetaStart + v * thetaLength);
                    var pz = radius * THREE.Math.sin(phiStart + u * phiLength) * THREE.Math.sin(thetaStart + v * thetaLength);
                    normal.set(px, py, pz).normalize();
                    positions.setXYZ(index, px, py, pz);
                    normals.setXYZ(index, normal.x, normal.y, normal.z);
                    uvs.setXY(index, u, 1 - v);
                    verticesRow.push(index);
                    index++;
                }
                vertices.push(verticesRow);
            }
            var indices = [];
            for (var y = 0; y < heightSegments; y++) {
                for (var x = 0; x < widthSegments; x++) {
                    var v1 = vertices[y][x + 1];
                    var v2 = vertices[y][x];
                    var v3 = vertices[y + 1][x];
                    var v4 = vertices[y + 1][x + 1];
                    if (y !== 0 || thetaStart > 0)
                        indices.push(v1, v2, v4);
                    if (y !== heightSegments - 1 || thetaEnd < THREE.Math.PI)
                        indices.push(v2, v3, v4);
                }
            }
            this.setIndex(new (positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute)(indices, 1));
            this.addAttribute('position', positions);
            this.addAttribute('normal', normals);
            this.addAttribute('uv', uvs);
            this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
        }
        ;
        return SphereBufferGeometry;
    }(THREE.BufferGeometry));
    THREE.SphereBufferGeometry = SphereBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var SphereGeometry = (function (_super) {
        __extends(SphereGeometry, _super);
        function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
            _super.call(this);
            this.type = 'SphereGeometry';
            this.parameters = {
                radius: radius,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                phiStart: phiStart,
                phiLength: phiLength,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            this.fromBufferGeometry(new THREE.SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
        }
        ;
        return SphereGeometry;
    }(THREE.Geometry));
    THREE.SphereGeometry = SphereGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var TetrahedronGeometry = (function (_super) {
        __extends(TetrahedronGeometry, _super);
        function TetrahedronGeometry(radius, detail) {
            var vertices = [
                1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1
            ];
            var indices = [
                2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1
            ];
            _super.call(this, vertices, indices, radius, detail);
            this.type = 'TetrahedronGeometry';
            this.parameters = {
                radius: radius,
                detail: detail
            };
        }
        ;
        return TetrahedronGeometry;
    }(THREE.PolyhedronGeometry));
    THREE.TetrahedronGeometry = TetrahedronGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var TextGeometry = (function (_super) {
        __extends(TextGeometry, _super);
        function TextGeometry(text, parameters) {
            parameters = parameters || {};
            var font = parameters.font;
            if (font instanceof THREE.Font === false) {
                console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
                throw new Error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
            }
            var shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);
            parameters.amount = parameters.height !== undefined ? parameters.height : 50;
            if (parameters.bevelThickness === undefined)
                parameters.bevelThickness = 10;
            if (parameters.bevelSize === undefined)
                parameters.bevelSize = 8;
            if (parameters.bevelEnabled === undefined)
                parameters.bevelEnabled = false;
            _super.call(this, shapes, parameters);
            this.type = 'TextGeometry';
        }
        ;
        return TextGeometry;
    }(THREE.ExtrudeGeometry));
    THREE.TextGeometry = TextGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var TorusBufferGeometry = (function (_super) {
        __extends(TorusBufferGeometry, _super);
        function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
            _super.call(this);
            this.type = 'TorusBufferGeometry';
            this.parameters = {
                radius: radius,
                tube: tube,
                radialSegments: radialSegments,
                tubularSegments: tubularSegments,
                arc: arc
            };
            radius = radius || 100;
            tube = tube || 40;
            radialSegments = THREE.Math.floor(radialSegments) || 8;
            tubularSegments = THREE.Math.floor(tubularSegments) || 6;
            arc = arc || THREE.Math.PI * 2;
            var vertexCount = ((radialSegments + 1) * (tubularSegments + 1));
            var indexCount = radialSegments * tubularSegments * 2 * 3;
            var indices = new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount);
            var vertices = new Float32Array(vertexCount * 3);
            var normals = new Float32Array(vertexCount * 3);
            var uvs = new Float32Array(vertexCount * 2);
            var vertexBufferOffset = 0;
            var uvBufferOffset = 0;
            var indexBufferOffset = 0;
            var center = new THREE.Vector3();
            var vertex = new THREE.Vector3();
            var normal = new THREE.Vector3();
            var j, i;
            for (j = 0; j <= radialSegments; j++) {
                for (i = 0; i <= tubularSegments; i++) {
                    var u = i / tubularSegments * arc;
                    var v = j / radialSegments * THREE.Math.PI * 2;
                    vertex.x = (radius + tube * THREE.Math.cos(v)) * THREE.Math.cos(u);
                    vertex.y = (radius + tube * THREE.Math.cos(v)) * THREE.Math.sin(u);
                    vertex.z = tube * THREE.Math.sin(v);
                    vertices[vertexBufferOffset] = vertex.x;
                    vertices[vertexBufferOffset + 1] = vertex.y;
                    vertices[vertexBufferOffset + 2] = vertex.z;
                    center.x = radius * THREE.Math.cos(u);
                    center.y = radius * THREE.Math.sin(u);
                    normal.subVectors(vertex, center).normalize();
                    normals[vertexBufferOffset] = normal.x;
                    normals[vertexBufferOffset + 1] = normal.y;
                    normals[vertexBufferOffset + 2] = normal.z;
                    uvs[uvBufferOffset] = i / tubularSegments;
                    uvs[uvBufferOffset + 1] = j / radialSegments;
                    vertexBufferOffset += 3;
                    uvBufferOffset += 2;
                }
            }
            for (j = 1; j <= radialSegments; j++) {
                for (i = 1; i <= tubularSegments; i++) {
                    var a = (tubularSegments + 1) * j + i - 1;
                    var b = (tubularSegments + 1) * (j - 1) + i - 1;
                    var c = (tubularSegments + 1) * (j - 1) + i;
                    var d = (tubularSegments + 1) * j + i;
                    indices[indexBufferOffset] = a;
                    indices[indexBufferOffset + 1] = b;
                    indices[indexBufferOffset + 2] = d;
                    indices[indexBufferOffset + 3] = b;
                    indices[indexBufferOffset + 4] = c;
                    indices[indexBufferOffset + 5] = d;
                    indexBufferOffset += 6;
                }
            }
            this.setIndex(new THREE.BufferAttribute(indices, 1));
            this.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
            this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
            this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
        }
        ;
        return TorusBufferGeometry;
    }(THREE.BufferGeometry));
    THREE.TorusBufferGeometry = TorusBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var TorusGeometry = (function (_super) {
        __extends(TorusGeometry, _super);
        function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
            _super.call(this);
            this.type = 'TorusGeometry';
            this.parameters = {
                radius: radius,
                tube: tube,
                radialSegments: radialSegments,
                tubularSegments: tubularSegments,
                arc: arc
            };
            this.fromBufferGeometry(new THREE.TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
        }
        ;
        return TorusGeometry;
    }(THREE.Geometry));
    THREE.TorusGeometry = TorusGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var TorusKnotBufferGeometry = (function (_super) {
        __extends(TorusKnotBufferGeometry, _super);
        function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
            _super.call(this);
            this.type = 'TorusKnotBufferGeometry';
            this.parameters = {
                radius: radius,
                tube: tube,
                tubularSegments: tubularSegments,
                radialSegments: radialSegments,
                p: p,
                q: q
            };
            radius = radius || 100;
            tube = tube || 40;
            tubularSegments = THREE.Math.floor(tubularSegments) || 64;
            radialSegments = THREE.Math.floor(radialSegments) || 8;
            p = p || 2;
            q = q || 3;
            var vertexCount = ((radialSegments + 1) * (tubularSegments + 1));
            var indexCount = radialSegments * tubularSegments * 2 * 3;
            var indices = new THREE.BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
            var vertices = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
            var normals = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
            var uvs = new THREE.BufferAttribute(new Float32Array(vertexCount * 2), 2);
            var i, j, index = 0, indexOffset = 0;
            var vertex = new THREE.Vector3();
            var normal = new THREE.Vector3();
            var uv = new THREE.Vector2();
            var P1 = new THREE.Vector3();
            var P2 = new THREE.Vector3();
            var B = new THREE.Vector3();
            var T = new THREE.Vector3();
            var N = new THREE.Vector3();
            for (i = 0; i <= tubularSegments; ++i) {
                var u = i / tubularSegments * p * THREE.Math.PI * 2;
                calculatePositionOnCurve(u, p, q, radius, P1);
                calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
                T.subVectors(P2, P1);
                N.addVectors(P2, P1);
                B.crossVectors(T, N);
                N.crossVectors(B, T);
                B.normalize();
                N.normalize();
                for (j = 0; j <= radialSegments; ++j) {
                    var v = j / radialSegments * THREE.Math.PI * 2;
                    var cx = -tube * THREE.Math.cos(v);
                    var cy = tube * THREE.Math.sin(v);
                    vertex.x = P1.x + (cx * N.x + cy * B.x);
                    vertex.y = P1.y + (cx * N.y + cy * B.y);
                    vertex.z = P1.z + (cx * N.z + cy * B.z);
                    vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
                    normal.subVectors(vertex, P1).normalize();
                    normals.setXYZ(index, normal.x, normal.y, normal.z);
                    uv.x = i / tubularSegments;
                    uv.y = j / radialSegments;
                    uvs.setXY(index, uv.x, uv.y);
                    index++;
                }
            }
            for (j = 1; j <= tubularSegments; j++) {
                for (i = 1; i <= radialSegments; i++) {
                    var a = (radialSegments + 1) * (j - 1) + (i - 1);
                    var b = (radialSegments + 1) * j + (i - 1);
                    var c = (radialSegments + 1) * j + i;
                    var d = (radialSegments + 1) * (j - 1) + i;
                    indices.setX(indexOffset, a);
                    indexOffset++;
                    indices.setX(indexOffset, b);
                    indexOffset++;
                    indices.setX(indexOffset, d);
                    indexOffset++;
                    indices.setX(indexOffset, b);
                    indexOffset++;
                    indices.setX(indexOffset, c);
                    indexOffset++;
                    indices.setX(indexOffset, d);
                    indexOffset++;
                }
            }
            this.setIndex(indices);
            this.addAttribute('position', vertices);
            this.addAttribute('normal', normals);
            this.addAttribute('uv', uvs);
            function calculatePositionOnCurve(u, p, q, radius, position) {
                var cu = THREE.Math.cos(u);
                var su = THREE.Math.sin(u);
                var quOverP = q / p * u;
                var cs = THREE.Math.cos(quOverP);
                position.x = radius * (2 + cs) * 0.5 * cu;
                position.y = radius * (2 + cs) * su * 0.5;
                position.z = radius * THREE.Math.sin(quOverP) * 0.5;
            }
        }
        ;
        return TorusKnotBufferGeometry;
    }(THREE.BufferGeometry));
    THREE.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var TorusKnotGeometry = (function (_super) {
        __extends(TorusKnotGeometry, _super);
        function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
            _super.call(this);
            this.type = 'TorusKnotGeometry';
            this.parameters = {
                radius: radius,
                tube: tube,
                tubularSegments: tubularSegments,
                radialSegments: radialSegments,
                p: p,
                q: q
            };
            if (heightScale !== undefined)
                console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');
            this.fromBufferGeometry(new THREE.TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
            this.mergeVertices();
        }
        ;
        return TorusKnotGeometry;
    }(THREE.Geometry));
    THREE.TorusKnotGeometry = TorusKnotGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var TubeGeometry = (function (_super) {
        __extends(TubeGeometry, _super);
        function TubeGeometry(path, segments, radius, radialSegments, closed, taper) {
            _super.call(this);
            this.type = 'TubeGeometry';
            this.parameters = {
                path: path,
                segments: segments,
                radius: radius,
                radialSegments: radialSegments,
                closed: closed,
                taper: taper
            };
            segments = segments || 64;
            radius = radius || 1;
            radialSegments = radialSegments || 8;
            closed = closed || false;
            taper = taper || TubeGeometry.NoTaper;
            var grid = [];
            var scope = this, tangent, normal, binormal, numpoints = segments + 1, u, v, r, cx, cy, pos, pos2 = new THREE.Vector3(), i, j, ip, jp, a, b, c, d, uva, uvb, uvc, uvd;
            var frames = new TubeGeometry.FrenetFrames(path, segments, closed), tangents = frames.tangents, normals = frames.normals, binormals = frames.binormals;
            this.tangents = tangents;
            this.normals = normals;
            this.binormals = binormals;
            function vert(x, y, z) {
                return scope.vertices.push(new THREE.Vector3(x, y, z)) - 1;
            }
            for (i = 0; i < numpoints; i++) {
                grid[i] = [];
                u = i / (numpoints - 1);
                pos = path.getPointAt(u);
                tangent = tangents[i];
                normal = normals[i];
                binormal = binormals[i];
                r = radius * taper(u);
                for (j = 0; j < radialSegments; j++) {
                    v = j / radialSegments * 2 * THREE.Math.PI;
                    cx = -r * THREE.Math.cos(v);
                    cy = r * THREE.Math.sin(v);
                    pos2.copy(pos);
                    pos2.x += cx * normal.x + cy * binormal.x;
                    pos2.y += cx * normal.y + cy * binormal.y;
                    pos2.z += cx * normal.z + cy * binormal.z;
                    grid[i][j] = vert(pos2.x, pos2.y, pos2.z);
                }
            }
            for (i = 0; i < segments; i++) {
                for (j = 0; j < radialSegments; j++) {
                    ip = (closed) ? (i + 1) % segments : i + 1;
                    jp = (j + 1) % radialSegments;
                    a = grid[i][j];
                    b = grid[ip][j];
                    c = grid[ip][jp];
                    d = grid[i][jp];
                    uva = new THREE.Vector2(i / segments, j / radialSegments);
                    uvb = new THREE.Vector2((i + 1) / segments, j / radialSegments);
                    uvc = new THREE.Vector2((i + 1) / segments, (j + 1) / radialSegments);
                    uvd = new THREE.Vector2(i / segments, (j + 1) / radialSegments);
                    this.faces.push(new THREE.Face3(a, b, d));
                    this.faceVertexUvs[0].push([uva, uvb, uvd]);
                    this.faces.push(new THREE.Face3(b, c, d));
                    this.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);
                }
            }
            this.computeFaceNormals();
            this.computeVertexNormals();
        }
        ;
        TubeGeometry.NoTaper = function (u) {
            return 1;
        };
        TubeGeometry.SinusoidalTaper = function (u) {
            return THREE.Math.sin(THREE.Math.PI * u);
        };
        TubeGeometry.FrenetFrames = function (path, segments, closed) {
            var normal = new THREE.Vector3(), tangents = [], normals = [], binormals = [], vec = new THREE.Vector3(), mat = new THREE.Matrix4(), numpoints = segments + 1, theta, smallest, tx, ty, tz, i, u;
            this.tangents = tangents;
            this.normals = normals;
            this.binormals = binormals;
            for (i = 0; i < numpoints; i++) {
                u = i / (numpoints - 1);
                tangents[i] = path.getTangentAt(u);
                tangents[i].normalize();
            }
            initialNormal3();
            function initialNormal3() {
                normals[0] = new THREE.Vector3();
                binormals[0] = new THREE.Vector3();
                smallest = Number.MAX_VALUE;
                tx = THREE.Math.abs(tangents[0].x);
                ty = THREE.Math.abs(tangents[0].y);
                tz = THREE.Math.abs(tangents[0].z);
                if (tx <= smallest) {
                    smallest = tx;
                    normal.set(1, 0, 0);
                }
                if (ty <= smallest) {
                    smallest = ty;
                    normal.set(0, 1, 0);
                }
                if (tz <= smallest) {
                    normal.set(0, 0, 1);
                }
                vec.crossVectors(tangents[0], normal).normalize();
                normals[0].crossVectors(tangents[0], vec);
                binormals[0].crossVectors(tangents[0], normals[0]);
            }
            for (i = 1; i < numpoints; i++) {
                normals[i] = normals[i - 1].clone();
                binormals[i] = binormals[i - 1].clone();
                vec.crossVectors(tangents[i - 1], tangents[i]);
                if (vec.length() > Number.EPSILON) {
                    vec.normalize();
                    theta = THREE.Math.acos(THREE.Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
                    normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
                }
                binormals[i].crossVectors(tangents[i], normals[i]);
            }
            if (closed) {
                theta = THREE.Math.acos(THREE.Math.clamp(normals[0].dot(normals[numpoints - 1]), -1, 1));
                theta /= (numpoints - 1);
                if (tangents[0].dot(vec.crossVectors(normals[0], normals[numpoints - 1])) > 0) {
                    theta = -theta;
                }
                for (i = 1; i < numpoints; i++) {
                    normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
                    binormals[i].crossVectors(tangents[i], normals[i]);
                }
            }
        };
        return TubeGeometry;
    }(THREE.Geometry));
    THREE.TubeGeometry = TubeGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WireframeGeometry = (function (_super) {
        __extends(WireframeGeometry, _super);
        function WireframeGeometry(geometry) {
            _super.call(this);
            var edge = [0, 0], hash = {};
            function sortFunction(a, b) {
                return a - b;
            }
            var keys = ['a', 'b', 'c'];
            if (geometry instanceof THREE.Geometry) {
                var vertices_1 = geometry.vertices;
                var faces = geometry.faces;
                var numEdges_1 = 0;
                var edges = new Uint32Array(6 * faces.length);
                for (var i = 0, l = faces.length; i < l; i++) {
                    var face = faces[i];
                    for (var j = 0; j < 3; j++) {
                        edge[0] = face[keys[j]];
                        edge[1] = face[keys[(j + 1) % 3]];
                        edge.sort(sortFunction);
                        var key = edge.toString();
                        if (hash[key] === undefined) {
                            edges[2 * numEdges_1] = edge[0];
                            edges[2 * numEdges_1 + 1] = edge[1];
                            hash[key] = true;
                            numEdges_1++;
                        }
                    }
                }
                var coords = new Float32Array(numEdges_1 * 2 * 3);
                for (var i = 0, l = numEdges_1; i < l; i++) {
                    for (var j = 0; j < 2; j++) {
                        var vertex = vertices_1[edges[2 * i + j]];
                        var index = 6 * i + 3 * j;
                        coords[index + 0] = vertex.x;
                        coords[index + 1] = vertex.y;
                        coords[index + 2] = vertex.z;
                    }
                }
                this.addAttribute('position', new THREE.BufferAttribute(coords, 3));
            }
            else if (geometry instanceof THREE.BufferGeometry) {
                if (geometry.index !== null) {
                    var indices = geometry.index.array;
                    var vertices_2 = geometry.attributes.position;
                    var groups = geometry.groups;
                    var numEdges_2 = 0;
                    if (groups.length === 0) {
                        geometry.addGroup(0, indices.length);
                    }
                    var edges = new Uint32Array(2 * indices.length);
                    for (var o = 0, ol = groups.length; o < ol; ++o) {
                        var group = groups[o];
                        var start = group.start;
                        var count = group.count;
                        for (var i = start, il = start + count; i < il; i += 3) {
                            for (var j = 0; j < 3; j++) {
                                edge[0] = indices[i + j];
                                edge[1] = indices[i + (j + 1) % 3];
                                edge.sort(sortFunction);
                                var key = edge.toString();
                                if (hash[key] === undefined) {
                                    edges[2 * numEdges_2] = edge[0];
                                    edges[2 * numEdges_2 + 1] = edge[1];
                                    hash[key] = true;
                                    numEdges_2++;
                                }
                            }
                        }
                    }
                    var coords = new Float32Array(numEdges_2 * 2 * 3);
                    for (var i = 0, l = numEdges_2; i < l; i++) {
                        for (var j = 0; j < 2; j++) {
                            var index = 6 * i + 3 * j;
                            var index2 = edges[2 * i + j];
                            coords[index + 0] = vertices_2.getX(index2);
                            coords[index + 1] = vertices_2.getY(index2);
                            coords[index + 2] = vertices_2.getZ(index2);
                        }
                    }
                    this.addAttribute('position', new THREE.BufferAttribute(coords, 3));
                }
                else {
                    var vertices = geometry.attributes.position.array;
                    var numEdges = vertices.length / 3;
                    var numTris = numEdges / 3;
                    var coords = new Float32Array(numEdges * 2 * 3);
                    for (var i = 0, l = numTris; i < l; i++) {
                        for (var j = 0; j < 3; j++) {
                            var index = 18 * i + 6 * j;
                            var index1 = 9 * i + 3 * j;
                            coords[index + 0] = vertices[index1];
                            coords[index + 1] = vertices[index1 + 1];
                            coords[index + 2] = vertices[index1 + 2];
                            var index2 = 9 * i + 3 * ((j + 1) % 3);
                            coords[index + 3] = vertices[index2];
                            coords[index + 4] = vertices[index2 + 1];
                            coords[index + 5] = vertices[index2 + 2];
                        }
                    }
                    this.addAttribute('position', new THREE.BufferAttribute(coords, 3));
                }
            }
        }
        ;
        return WireframeGeometry;
    }(THREE.BufferGeometry));
    THREE.WireframeGeometry = WireframeGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var ArrowHelper = (function (_super) {
        __extends(ArrowHelper, _super);
        function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
            _super.call(this);
            var lineGeometry = ArrowHelper.lineGeometry;
            if (lineGeometry === undefined) {
                lineGeometry = ArrowHelper.lineGeometry = new THREE.BufferGeometry();
                lineGeometry.addAttribute('position', new THREE.Float32Attribute([0, 0, 0, 0, 1, 0], 3));
            }
            var coneGeometry = ArrowHelper.coneGeometry;
            if (coneGeometry === undefined) {
                coneGeometry = ArrowHelper.coneGeometry = new THREE.CylinderBufferGeometry(0, 0.5, 1, 5, 1);
                coneGeometry.translate(0, -0.5, 0);
            }
            if (color === undefined)
                color = 0xffff00;
            if (length === undefined)
                length = 1;
            if (headLength === undefined)
                headLength = 0.2 * length;
            if (headWidth === undefined)
                headWidth = 0.2 * headLength;
            this.position.copy(origin);
            this.line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({ color: color }));
            this.line.matrixAutoUpdate = false;
            this.add(this.line);
            this.cone = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({ color: color }));
            this.cone.matrixAutoUpdate = false;
            this.add(this.cone);
            this.setDirection(dir);
            this.setLength(length, headLength, headWidth);
        }
        ArrowHelper.prototype.setDirection = function (dir) {
            var axis = ArrowHelper["setDirection_axis"]
                || (ArrowHelper["setDirection_axis"] = new THREE.Vector3());
            var radians;
            if (dir.y > 0.99999) {
                this.quaternion.set(0, 0, 0, 1);
            }
            else if (dir.y < -0.99999) {
                this.quaternion.set(1, 0, 0, 0);
            }
            else {
                axis.set(dir.z, 0, -dir.x).normalize();
                radians = THREE.Math.acos(dir.y);
                this.quaternion.setFromAxisAngle(axis, radians);
            }
        };
        ArrowHelper.prototype.setLength = function (length, headLength, headWidth) {
            if (headLength === undefined)
                headLength = 0.2 * length;
            if (headWidth === undefined)
                headWidth = 0.2 * headLength;
            this.line.scale.set(1, THREE.Math.max(0, length - headLength), 1);
            this.line.updateMatrix();
            this.cone.scale.set(headWidth, headLength, headWidth);
            this.cone.position.y = length;
            this.cone.updateMatrix();
        };
        ArrowHelper.prototype.setColor = function (color) {
            this.line.material.color.copy(color);
            this.cone.material.color.copy(color);
        };
        return ArrowHelper;
    }(THREE.Object3D));
    THREE.ArrowHelper = ArrowHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Line = (function (_super) {
        __extends(Line, _super);
        function Line(geometry, material, mode) {
            _super.call(this);
            if (mode === 1) {
                console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');
                return new THREE.LineSegments(geometry, material);
            }
            this.type = 'Line';
            this.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();
            this.material = material !== undefined ? material : new THREE.LineBasicMaterial({ color: THREE.Math.random() * 0xffffff });
        }
        ;
        Line.prototype.raycast = function (raycaster, intersects) {
            var inverseMatrix = Line.raycast_inverseMatrix;
            var ray = Line.raycast_ray;
            var sphere = Line.raycast_sphere;
            if (inverseMatrix === undefined) {
                inverseMatrix = Line.raycast_inverseMatrix = new THREE.Matrix4();
                ray = Line.raycast_ray = new THREE.Ray();
                ;
                sphere = Line.raycast_sphere = new THREE.Sphere();
            }
            var precision = raycaster.linePrecision;
            var precisionSq = precision * precision;
            var geometry = this.geometry;
            var matrixWorld = this.matrixWorld;
            if (geometry.boundingSphere === null)
                geometry.computeBoundingSphere();
            sphere.copy(geometry.boundingSphere);
            sphere.applyMatrix4(matrixWorld);
            if (raycaster.ray.intersectsSphere(sphere) === false)
                return;
            inverseMatrix.getInverse(matrixWorld);
            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
            var vStart = new THREE.Vector3();
            var vEnd = new THREE.Vector3();
            var interSegment = new THREE.Vector3();
            var interRay = new THREE.Vector3();
            var step = this instanceof THREE.LineSegments ? 2 : 1;
            if (geometry instanceof THREE.BufferGeometry) {
                var index = geometry.index;
                var attributes = geometry.attributes;
                var positions = attributes.position.array;
                if (index !== null) {
                    var indices = index.array;
                    for (var i = 0, l = indices.length - 1; i < l; i += step) {
                        var a = indices[i];
                        var b = indices[i + 1];
                        vStart.fromArray(positions, a * 3);
                        vEnd.fromArray(positions, b * 3);
                        var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                        if (distSq > precisionSq)
                            continue;
                        interRay.applyMatrix4(this.matrixWorld);
                        var distance = raycaster.ray.origin.distanceTo(interRay);
                        if (distance < raycaster.near || distance > raycaster.far)
                            continue;
                        intersects.push({
                            distance: distance,
                            point: interSegment.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this
                        });
                    }
                }
                else {
                    for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
                        vStart.fromArray(positions, 3 * i);
                        vEnd.fromArray(positions, 3 * i + 3);
                        var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                        if (distSq > precisionSq)
                            continue;
                        interRay.applyMatrix4(this.matrixWorld);
                        var distance = raycaster.ray.origin.distanceTo(interRay);
                        if (distance < raycaster.near || distance > raycaster.far)
                            continue;
                        intersects.push({
                            distance: distance,
                            point: interSegment.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this
                        });
                    }
                }
            }
            else if (geometry instanceof THREE.Geometry) {
                var vertices = geometry.vertices;
                var nbVertices = vertices.length;
                for (var i = 0; i < nbVertices - 1; i += step) {
                    var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
                    if (distSq > precisionSq)
                        continue;
                    interRay.applyMatrix4(this.matrixWorld);
                    var distance = raycaster.ray.origin.distanceTo(interRay);
                    if (distance < raycaster.near || distance > raycaster.far)
                        continue;
                    intersects.push({
                        distance: distance,
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            }
        };
        Line.prototype.clone = function () {
            return new this.constructor(this.geometry, this.material).copy(this);
        };
        return Line;
    }(THREE.Object3D));
    THREE.Line = Line;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var LineSegments = (function (_super) {
        __extends(LineSegments, _super);
        function LineSegments(geometry, material) {
            _super.call(this, geometry, material);
            this.type = 'LineSegments';
        }
        ;
        return LineSegments;
    }(THREE.Line));
    THREE.LineSegments = LineSegments;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var AxisHelper = (function (_super) {
        __extends(AxisHelper, _super);
        function AxisHelper(size) {
            size = size || 1;
            var vertices = new Float32Array([
                0, 0, 0, size, 0, 0,
                0, 0, 0, 0, size, 0,
                0, 0, 0, 0, 0, size
            ]);
            var colors = new Float32Array([
                1, 0, 0, 1, 0.6, 0,
                0, 1, 0, 0.6, 1, 0,
                0, 0, 1, 0, 0.6, 1
            ]);
            var geometry = new THREE.BufferGeometry();
            geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
            var material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
            _super.call(this, geometry, material);
        }
        return AxisHelper;
    }(THREE.LineSegments));
    THREE.AxisHelper = AxisHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Mesh = (function (_super) {
        __extends(Mesh, _super);
        function Mesh(geometry, material) {
            _super.call(this);
            Mesh.initStatic();
            this.type = 'Mesh';
            this.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();
            this.material = material !== undefined ? material : new THREE.MeshBasicMaterial({ color: THREE.Math.random() * 0xffffff });
            this.drawMode = THREE.TrianglesDrawMode;
            this.updateMorphTargets();
        }
        ;
        Mesh.prototype.setDrawMode = function (value) {
            this.drawMode = value;
        };
        Mesh.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.drawMode = source.drawMode;
            return this;
        };
        Mesh.prototype.updateMorphTargets = function () {
            var geometry = this.geometry;
            if (geometry.morphTargets !== undefined && geometry.morphTargets.length > 0) {
                this.morphTargetBase = -1;
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (var m = 0, ml = geometry.morphTargets.length; m < ml; m++) {
                    this.morphTargetInfluences.push(0);
                    this.morphTargetDictionary[geometry.morphTargets[m].name] = m;
                }
            }
        };
        Mesh.prototype.getMorphTargetIndexByName = function (name) {
            if (this.morphTargetDictionary[name] !== undefined) {
                return this.morphTargetDictionary[name];
            }
            console.warn('THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.');
            return 0;
        };
        Mesh.initStatic = function () {
            if (Mesh.raycast_inverseMatrix !== undefined)
                return;
            Mesh.raycast_inverseMatrix = new THREE.Matrix4();
            Mesh.raycast_ray = new THREE.Ray();
            Mesh.raycast_sphere = new THREE.Sphere();
            Mesh.raycast_vA = new THREE.Vector3();
            Mesh.raycast_vB = new THREE.Vector3();
            Mesh.raycast_vC = new THREE.Vector3();
            Mesh.raycast_tempA = new THREE.Vector3();
            Mesh.raycast_tempB = new THREE.Vector3();
            Mesh.raycast_tempC = new THREE.Vector3();
            Mesh.raycast_uvA = new THREE.Vector2();
            Mesh.raycast_uvB = new THREE.Vector2();
            Mesh.raycast_uvC = new THREE.Vector2();
            Mesh.raycast_barycoord = new THREE.Vector3();
            Mesh.raycast_intersectionPoint = new THREE.Vector3();
            Mesh.raycast_intersectionPointWorld = new THREE.Vector3();
        };
        Mesh.uvIntersection = function (point, p1, p2, p3, uv1, uv2, uv3) {
            var barycoord = Mesh["raycast_barycoord"] || (Mesh["raycast_barycoord"] = new THREE.Vector3());
            THREE.Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);
            uv1.multiplyScalar(barycoord.x);
            uv2.multiplyScalar(barycoord.y);
            uv3.multiplyScalar(barycoord.z);
            uv1.add(uv2).add(uv3);
            return uv1.clone();
        };
        Mesh.checkIntersection = function (object, raycaster, ray, pA, pB, pC, point) {
            var intersectionPointWorld = Mesh["raycast_intersectionPointWorld"] || (Mesh["raycast_intersectionPointWorld"] = new THREE.Vector3());
            var intersect;
            var material = object.material;
            if (material.side === THREE.BackSide) {
                intersect = ray.intersectTriangle(pC, pB, pA, true, point);
            }
            else {
                intersect = ray.intersectTriangle(pA, pB, pC, material.side !== THREE.DoubleSide, point);
            }
            if (intersect === null)
                return null;
            intersectionPointWorld.copy(point);
            intersectionPointWorld.applyMatrix4(object.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
            if (distance < raycaster.near || distance > raycaster.far)
                return null;
            return {
                distance: distance,
                point: intersectionPointWorld.clone(),
                object: object
            };
        };
        Mesh.checkBufferGeometryIntersection = function (object, raycaster, ray, positions, uvs, a, b, c) {
            var vA = Mesh.raycast_vA;
            var vB = Mesh.raycast_vB;
            var vC = Mesh.raycast_vC;
            var uvA = Mesh.raycast_uvA;
            var uvB = Mesh.raycast_uvB;
            var uvC = Mesh.raycast_uvC;
            vA.fromArray(positions, a * 3);
            vB.fromArray(positions, b * 3);
            vC.fromArray(positions, c * 3);
            var intersectionPoint = Mesh.raycast_intersectionPoint;
            var intersection = Mesh.checkIntersection(object, raycaster, ray, vA, vB, vC, intersectionPoint);
            if (intersection) {
                if (uvs) {
                    uvA.fromArray(uvs, a * 2);
                    uvB.fromArray(uvs, b * 2);
                    uvC.fromArray(uvs, c * 2);
                    intersection.uv = Mesh.uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
                }
                intersection.face = new THREE.Face3(a, b, c, THREE.Triangle.normal(vA, vB, vC));
                intersection.faceIndex = a;
            }
            return intersection;
        };
        Mesh.prototype.raycast = function (raycaster, intersects) {
            var sphere = Mesh.raycast_sphere;
            var inverseMatrix = Mesh.raycast_inverseMatrix;
            var ray = Mesh.raycast_ray;
            var vA = Mesh.raycast_vA;
            var vB = Mesh.raycast_vB;
            var vC = Mesh.raycast_vC;
            var uvA = Mesh.raycast_uvA;
            var uvB = Mesh.raycast_uvB;
            var uvC = Mesh.raycast_uvC;
            var tempA = Mesh.raycast_tempA;
            var tempB = Mesh.raycast_tempB;
            var tempC = Mesh.raycast_tempC;
            var intersectionPoint = Mesh.raycast_intersectionPoint;
            var geometry = this.geometry;
            var material = this.material;
            var matrixWorld = this.matrixWorld;
            if (material === undefined)
                return;
            if (geometry.boundingSphere === null)
                geometry.computeBoundingSphere();
            sphere.copy(geometry.boundingSphere);
            sphere.applyMatrix4(matrixWorld);
            if (raycaster.ray.intersectsSphere(sphere) === false)
                return;
            inverseMatrix.getInverse(matrixWorld);
            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
            if (geometry.boundingBox !== null) {
                if (ray.intersectsBox(geometry.boundingBox) === false)
                    return;
            }
            var uvs;
            var intersection;
            if (geometry instanceof THREE.BufferGeometry) {
                var a, b, c;
                var index = geometry.index;
                var attributes = geometry.attributes;
                var positions = attributes.position.array;
                if (attributes.uv !== undefined) {
                    uvs = attributes.uv.array;
                }
                if (index !== null) {
                    var indices = index.array;
                    for (var i = 0, l = indices.length; i < l; i += 3) {
                        a = indices[i];
                        b = indices[i + 1];
                        c = indices[i + 2];
                        intersection = Mesh.checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
                        if (intersection) {
                            intersection.faceIndex = THREE.Math.floor(i / 3);
                            intersects.push(intersection);
                        }
                    }
                }
                else {
                    for (var i_3 = 0, l_1 = positions.length; i_3 < l_1; i_3 += 9) {
                        a = i_3 / 3;
                        b = a + 1;
                        c = a + 2;
                        intersection = Mesh.checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
                        if (intersection) {
                            intersection.index = a;
                            intersects.push(intersection);
                        }
                    }
                }
            }
            else if (geometry instanceof THREE.Geometry) {
                var fvA, fvB, fvC;
                var isFaceMaterial = material instanceof THREE.MultiMaterial;
                var materials = isFaceMaterial === true ? material.materials : null;
                var vertices = geometry.vertices;
                var faces = geometry.faces;
                var faceVertexUvs = geometry.faceVertexUvs[0];
                if (faceVertexUvs.length > 0)
                    uvs = faceVertexUvs;
                for (var f = 0, fl = faces.length; f < fl; f++) {
                    var face = faces[f];
                    var faceMaterial = isFaceMaterial === true ? materials[face.materialIndex] : material;
                    if (faceMaterial === undefined)
                        continue;
                    fvA = vertices[face.a];
                    fvB = vertices[face.b];
                    fvC = vertices[face.c];
                    if (faceMaterial.morphTargets === true) {
                        var morphTargets = geometry.morphTargets;
                        var morphInfluences = this.morphTargetInfluences;
                        vA.set(0, 0, 0);
                        vB.set(0, 0, 0);
                        vC.set(0, 0, 0);
                        for (var t = 0, tl = morphTargets.length; t < tl; t++) {
                            var influence = morphInfluences[t];
                            if (influence === 0)
                                continue;
                            var targets = morphTargets[t].vertices;
                            vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
                            vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
                            vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
                        }
                        vA.add(fvA);
                        vB.add(fvB);
                        vC.add(fvC);
                        fvA = vA;
                        fvB = vB;
                        fvC = vC;
                    }
                    intersection = Mesh.checkIntersection(this, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
                    if (intersection) {
                        if (uvs) {
                            var uvs_f = uvs[f];
                            uvA.copy(uvs_f[0]);
                            uvB.copy(uvs_f[1]);
                            uvC.copy(uvs_f[2]);
                            intersection.uv = Mesh.uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
                        }
                        intersection.face = face;
                        intersection.faceIndex = f;
                        intersects.push(intersection);
                    }
                }
            }
        };
        Mesh.prototype.clone = function () {
            return new this.constructor(this.geometry, this.material).copy(this);
        };
        return Mesh;
    }(THREE.Object3D));
    THREE.Mesh = Mesh;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var BoundingBoxHelper = (function (_super) {
        __extends(BoundingBoxHelper, _super);
        function BoundingBoxHelper(object, color) {
            if (color === void 0) { color = 0x888888; }
            _super.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: color, wireframe: true }));
            this.box = new THREE.Box3();
            this.object = object;
            this.box = new THREE.Box3();
        }
        ;
        BoundingBoxHelper.prototype.update = function () {
            this.box.setFromObject(this.object);
            this.box.size(this.scale);
            this.box.center(this.position);
        };
        ;
        return BoundingBoxHelper;
    }(THREE.Mesh));
    THREE.BoundingBoxHelper = BoundingBoxHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var BoxHelper = (function (_super) {
        __extends(BoxHelper, _super);
        function BoxHelper(object, color) {
            if (color === void 0) { color = 0xffff00; }
            _super.call(this);
            var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
            var positions = new Float32Array(8 * 3);
            var geometry = new THREE.BufferGeometry();
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
            this.geometry = geometry;
            this.material = new THREE.LineBasicMaterial({ color: color });
            if (object !== undefined) {
                this.update(object);
            }
        }
        ;
        BoxHelper.prototype.update = function (object) {
            var box = BoxHelper["update.box"]
                || (BoxHelper["update.box"] = new THREE.Box3());
            if (object instanceof THREE.Box3) {
                box.copy(object);
            }
            else {
                box.setFromObject(object);
            }
            if (box.isEmpty())
                return;
            var min = box.min;
            var max = box.max;
            var position = this.geometry.attributes.position;
            var array = position.array;
            array[0] = max.x;
            array[1] = max.y;
            array[2] = max.z;
            array[3] = min.x;
            array[4] = max.y;
            array[5] = max.z;
            array[6] = min.x;
            array[7] = min.y;
            array[8] = max.z;
            array[9] = max.x;
            array[10] = min.y;
            array[11] = max.z;
            array[12] = max.x;
            array[13] = max.y;
            array[14] = min.z;
            array[15] = min.x;
            array[16] = max.y;
            array[17] = min.z;
            array[18] = min.x;
            array[19] = min.y;
            array[20] = min.z;
            array[21] = max.x;
            array[22] = min.y;
            array[23] = min.z;
            position.needsUpdate = true;
            this.geometry.computeBoundingSphere();
        };
        return BoxHelper;
    }(THREE.LineSegments));
    THREE.BoxHelper = BoxHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var CameraHelper = (function (_super) {
        __extends(CameraHelper, _super);
        function CameraHelper(camera) {
            _super.call(this);
            var geometry = new THREE.Geometry();
            var material = new THREE.LineBasicMaterial({ color: 0xffffff, vertexColors: THREE.FaceColors });
            var pointMap = {};
            var hexFrustum = 0xffaa00;
            var hexCone = 0xff0000;
            var hexUp = 0x00aaff;
            var hexTarget = 0xffffff;
            var hexCross = 0x333333;
            addLine("n1", "n2", hexFrustum);
            addLine("n2", "n4", hexFrustum);
            addLine("n4", "n3", hexFrustum);
            addLine("n3", "n1", hexFrustum);
            addLine("f1", "f2", hexFrustum);
            addLine("f2", "f4", hexFrustum);
            addLine("f4", "f3", hexFrustum);
            addLine("f3", "f1", hexFrustum);
            addLine("n1", "f1", hexFrustum);
            addLine("n2", "f2", hexFrustum);
            addLine("n3", "f3", hexFrustum);
            addLine("n4", "f4", hexFrustum);
            addLine("p", "n1", hexCone);
            addLine("p", "n2", hexCone);
            addLine("p", "n3", hexCone);
            addLine("p", "n4", hexCone);
            addLine("u1", "u2", hexUp);
            addLine("u2", "u3", hexUp);
            addLine("u3", "u1", hexUp);
            addLine("c", "t", hexTarget);
            addLine("p", "c", hexCross);
            addLine("cn1", "cn2", hexCross);
            addLine("cn3", "cn4", hexCross);
            addLine("cf1", "cf2", hexCross);
            addLine("cf3", "cf4", hexCross);
            function addLine(a, b, hex) {
                addPoint(a, hex);
                addPoint(b, hex);
            }
            function addPoint(id, hex) {
                geometry.vertices.push(new THREE.Vector3());
                geometry.colors.push(new THREE.Color(hex));
                if (pointMap[id] === undefined) {
                    pointMap[id] = [];
                }
                pointMap[id].push(geometry.vertices.length - 1);
            }
            this.geometry = geometry;
            this.material = material;
            this.camera = camera;
            if (this.camera.updateProjectionMatrix)
                this.camera.updateProjectionMatrix();
            this.matrix = camera.matrixWorld;
            this.matrixAutoUpdate = false;
            this.pointMap = pointMap;
            this.update();
        }
        ;
        CameraHelper.prototype.update = function () {
            var geometry, pointMap;
            var vector = new THREE.Vector3();
            var camera = new THREE.Camera();
            function setPoint(point, x, y, z) {
                vector.set(x, y, z).unproject(camera);
                var points = pointMap[point];
                if (points !== undefined) {
                    for (var i = 0, il = points.length; i < il; i++) {
                        geometry.vertices[points[i]].copy(vector);
                    }
                }
            }
            var func = CameraHelper.prototype.update = function update() {
                geometry = this.geometry;
                pointMap = this.pointMap;
                var w = 1, h = 1;
                camera.projectionMatrix.copy(this.camera.projectionMatrix);
                setPoint("c", 0, 0, -1);
                setPoint("t", 0, 0, 1);
                setPoint("n1", -w, -h, -1);
                setPoint("n2", w, -h, -1);
                setPoint("n3", -w, h, -1);
                setPoint("n4", w, h, -1);
                setPoint("f1", -w, -h, 1);
                setPoint("f2", w, -h, 1);
                setPoint("f3", -w, h, 1);
                setPoint("f4", w, h, 1);
                setPoint("u1", w * 0.7, h * 1.1, -1);
                setPoint("u2", -w * 0.7, h * 1.1, -1);
                setPoint("u3", 0, h * 2, -1);
                setPoint("cf1", -w, 0, 1);
                setPoint("cf2", w, 0, 1);
                setPoint("cf3", 0, -h, 1);
                setPoint("cf4", 0, h, 1);
                setPoint("cn1", -w, 0, -1);
                setPoint("cn2", w, 0, -1);
                setPoint("cn3", 0, -h, -1);
                setPoint("cn4", 0, h, -1);
                geometry.verticesNeedUpdate = true;
            };
            return func.apply(this, arguments);
        };
        return CameraHelper;
    }(THREE.LineSegments));
    THREE.CameraHelper = CameraHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var DirectionalLightHelper = (function (_super) {
        __extends(DirectionalLightHelper, _super);
        function DirectionalLightHelper(light, size) {
            _super.call(this);
            this.light = light;
            this.light.updateMatrixWorld();
            this.matrix = light.matrixWorld;
            this.matrixAutoUpdate = false;
            if (size === undefined)
                size = 1;
            var geometry = new THREE.BufferGeometry();
            geometry.addAttribute('position', new THREE.Float32Attribute([
                -size, size, 0,
                size, size, 0,
                size, -size, 0,
                -size, -size, 0,
                -size, size, 0
            ], 3));
            var material = new THREE.LineBasicMaterial({ fog: false });
            this.add(new THREE.Line(geometry, material));
            geometry = new THREE.BufferGeometry();
            geometry.addAttribute('position', new THREE.Float32Attribute([0, 0, 0, 0, 0, 1], 3));
            this.add(new THREE.Line(geometry, material));
            this.update();
        }
        ;
        DirectionalLightHelper.prototype.dispose = function () {
            var lightPlane = this.children[0];
            var targetLine = this.children[1];
            lightPlane.geometry.dispose();
            lightPlane.material.dispose();
            targetLine.geometry.dispose();
            targetLine.material.dispose();
        };
        ;
        DirectionalLightHelper.prototype.update = function () {
            var v1 = DirectionalLightHelper["update_v1"];
            var v2 = DirectionalLightHelper["update_v2"];
            var v3 = DirectionalLightHelper["update_v3"];
            if (v1 === undefined) {
                v1 = DirectionalLightHelper["update_v1"] = new THREE.Vector3();
                v2 = DirectionalLightHelper["update_v2"] = new THREE.Vector3();
                v3 = DirectionalLightHelper["update_v3"] = new THREE.Vector3();
            }
            v1.setFromMatrixPosition(this.light.matrixWorld);
            v2.setFromMatrixPosition(this.light.target.matrixWorld);
            v3.subVectors(v2, v1);
            var lightPlane = this.children[0];
            var targetLine = this.children[1];
            lightPlane.lookAt(v3);
            lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            targetLine.lookAt(v3);
            targetLine.scale.z = v3.length();
        };
        return DirectionalLightHelper;
    }(THREE.Object3D));
    THREE.DirectionalLightHelper = DirectionalLightHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var EdgesHelper = (function (_super) {
        __extends(EdgesHelper, _super);
        function EdgesHelper(object, hex, thresholdAngle) {
            _super.call(this);
            var color = (hex !== undefined) ? hex : 0xffffff;
            this.geometry = new THREE.EdgesGeometry(object.geometry, thresholdAngle);
            this.material = new THREE.LineBasicMaterial({ color: color });
            this.matrix = object.matrixWorld;
            this.matrixAutoUpdate = false;
        }
        ;
        return EdgesHelper;
    }(THREE.LineSegments));
    THREE.EdgesHelper = EdgesHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var FaceNormalsHelper = (function (_super) {
        __extends(FaceNormalsHelper, _super);
        function FaceNormalsHelper(object, size, hex, linewidth) {
            _super.call(this);
            this.object = object;
            this.size = (size !== undefined) ? size : 1;
            var color = (hex !== undefined) ? hex : 0xffff00;
            var width = (linewidth !== undefined) ? linewidth : 1;
            var nNormals = 0;
            var objGeometry = this.object.geometry;
            if (objGeometry instanceof THREE.Geometry) {
                nNormals = objGeometry.faces.length;
            }
            else {
                console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');
                throw new Error('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');
            }
            var geometry = new THREE.BufferGeometry();
            var positions = new THREE.Float32Attribute(nNormals * 2 * 3, 3);
            geometry.addAttribute('position', positions);
            this.geometry = geometry;
            this.material = new THREE.LineBasicMaterial({ color: color, linewidth: width });
            this.matrixAutoUpdate = false;
            this.update();
        }
        FaceNormalsHelper.prototype.update = function () {
            var v1 = FaceNormalsHelper["update_v1"];
            var v2 = FaceNormalsHelper["update_v2"];
            var normalMatrix = FaceNormalsHelper["update_normalMatrix"];
            if (v1 === undefined) {
                v1 = FaceNormalsHelper["update_v1"] = new THREE.Vector3();
                v2 = FaceNormalsHelper["update_v2"] = new THREE.Vector3();
                normalMatrix = FaceNormalsHelper["update_normalMatrix"] = new THREE.Matrix3();
            }
            this.object.updateMatrixWorld(true);
            normalMatrix.getNormalMatrix(this.object.matrixWorld);
            var matrixWorld = this.object.matrixWorld;
            var position = this.geometry.attributes.position;
            var objGeometry = this.object.geometry;
            var vertices = objGeometry.vertices;
            var faces = objGeometry.faces;
            var idx = 0;
            for (var i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                var normal = face.normal;
                v1.copy(vertices[face.a])
                    .add(vertices[face.b])
                    .add(vertices[face.c])
                    .divideScalar(3)
                    .applyMatrix4(matrixWorld);
                v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                position.setXYZ(idx, v1.x, v1.y, v1.z);
                idx = idx + 1;
                position.setXYZ(idx, v2.x, v2.y, v2.z);
                idx = idx + 1;
            }
            position.needsUpdate = true;
            return this;
        };
        return FaceNormalsHelper;
    }(THREE.LineSegments));
    THREE.FaceNormalsHelper = FaceNormalsHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var GridHelper = (function (_super) {
        __extends(GridHelper, _super);
        function GridHelper(size, divisions, acolor1, acolor2) {
            _super.call(this);
            divisions = divisions || 1;
            var color1 = new THREE.Color(acolor1 !== undefined ? acolor1 : 0x444444);
            var color2 = new THREE.Color(acolor2 !== undefined ? acolor2 : 0x888888);
            var center = divisions / 2;
            var step = (size * 2) / divisions;
            var vertices = [], colors = [];
            for (var i = 0, j = 0, k = -size; i <= divisions; i++, k += step) {
                vertices.push(-size, 0, k, size, 0, k);
                vertices.push(k, 0, -size, k, 0, size);
                var color = i === center ? color1 : color2;
                color.toArray(colors, j);
                j += 3;
                color.toArray(colors, j);
                j += 3;
                color.toArray(colors, j);
                j += 3;
                color.toArray(colors, j);
                j += 3;
            }
            var geometry = new THREE.BufferGeometry();
            geometry.addAttribute('position', new THREE.Float32Attribute(vertices, 3));
            geometry.addAttribute('color', new THREE.Float32Attribute(colors, 3));
            var material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
            this.geometry = geometry;
            this.material = material;
        }
        ;
        return GridHelper;
    }(THREE.LineSegments));
    THREE.GridHelper = GridHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var HemisphereLightHelper = (function (_super) {
        __extends(HemisphereLightHelper, _super);
        function HemisphereLightHelper(light, sphereSize) {
            _super.call(this);
            this.light = light;
            this.light.updateMatrixWorld();
            this.matrix = light.matrixWorld;
            this.matrixAutoUpdate = false;
            this.colors = [new THREE.Color(), new THREE.Color()];
            var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);
            geometry.rotateX(-THREE.Math.PI / 2);
            for (var i = 0, il = 8; i < il; i++) {
                geometry.faces[i].color = this.colors[i < 4 ? 0 : 1];
            }
            var material = new THREE.MeshBasicMaterial({ vertexColors: THREE.FaceColors, wireframe: true });
            this.lightSphere = new THREE.Mesh(geometry, material);
            this.add(this.lightSphere);
            this.update();
        }
        ;
        HemisphereLightHelper.prototype.dispose = function () {
            this.lightSphere.geometry.dispose();
            this.lightSphere.material.dispose();
        };
        ;
        HemisphereLightHelper.prototype.update = function () {
            var vector = HemisphereLightHelper["upeate_v1"] ||
                (HemisphereLightHelper["upeate_v1"] = new THREE.Vector3());
            this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
            this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
            this.lightSphere.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
            this.lightSphere.geometry.colorsNeedUpdate = true;
        };
        return HemisphereLightHelper;
    }(THREE.Object3D));
    THREE.HemisphereLightHelper = HemisphereLightHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var PointLightHelper = (function (_super) {
        __extends(PointLightHelper, _super);
        function PointLightHelper(light, sphereSize) {
            _super.call(this);
            this.light = light;
            this.light.updateMatrixWorld();
            var geometry = new THREE.SphereBufferGeometry(sphereSize, 4, 2);
            var material = new THREE.MeshBasicMaterial({ wireframe: true, fog: false });
            material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            this.geometry = geometry;
            this.material = material;
            this.matrix = this.light.matrixWorld;
            this.matrixAutoUpdate = false;
        }
        ;
        PointLightHelper.prototype.dispose = function () {
            this.geometry.dispose();
            this.material.dispose();
        };
        ;
        PointLightHelper.prototype.update = function () {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        };
        return PointLightHelper;
    }(THREE.Mesh));
    THREE.PointLightHelper = PointLightHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var SkeletonHelper = (function (_super) {
        __extends(SkeletonHelper, _super);
        function SkeletonHelper(object) {
            _super.call(this);
            this.bones = this.getBoneList(object);
            var geometry = new THREE.Geometry();
            for (var i = 0; i < this.bones.length; i++) {
                var bone = this.bones[i];
                if (bone.parent instanceof THREE.Bone) {
                    geometry.vertices.push(new THREE.Vector3());
                    geometry.vertices.push(new THREE.Vector3());
                    geometry.colors.push(new THREE.Color(0, 0, 1));
                    geometry.colors.push(new THREE.Color(0, 1, 0));
                }
            }
            geometry.dynamic = true;
            var material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true });
            this.geometry = geometry;
            this.material = material;
            this.root = object;
            this.matrix = object.matrixWorld;
            this.matrixAutoUpdate = false;
            this.update();
        }
        SkeletonHelper.prototype.getBoneList = function (object) {
            var boneList = [];
            if (object instanceof THREE.Bone) {
                boneList.push(object);
            }
            for (var i = 0; i < object.children.length; i++) {
                boneList.push.apply(boneList, this.getBoneList(object.children[i]));
            }
            return boneList;
        };
        SkeletonHelper.prototype.update = function () {
            var geometry = this.geometry;
            var matrixWorldInv = new THREE.Matrix4().getInverse(this.root.matrixWorld);
            var boneMatrix = new THREE.Matrix4();
            var j = 0;
            for (var i = 0; i < this.bones.length; i++) {
                var bone = this.bones[i];
                if (bone.parent instanceof THREE.Bone) {
                    boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
                    geometry.vertices[j].setFromMatrixPosition(boneMatrix);
                    boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
                    geometry.vertices[j + 1].setFromMatrixPosition(boneMatrix);
                    j += 2;
                }
            }
            geometry.verticesNeedUpdate = true;
            geometry.computeBoundingSphere();
        };
        return SkeletonHelper;
    }(THREE.LineSegments));
    THREE.SkeletonHelper = SkeletonHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var SpotLightHelper = (function (_super) {
        __extends(SpotLightHelper, _super);
        function SpotLightHelper(light) {
            _super.call(this);
            this.light = light;
            this.light.updateMatrixWorld();
            this.matrix = light.matrixWorld;
            this.matrixAutoUpdate = false;
            var geometry = new THREE.BufferGeometry();
            var positions = [
                0, 0, 0, 0, 0, 1,
                0, 0, 0, 1, 0, 1,
                0, 0, 0, -1, 0, 1,
                0, 0, 0, 0, 1, 1,
                0, 0, 0, 0, -1, 1
            ];
            for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
                var p1 = (i / l) * THREE.Math.PI * 2;
                var p2 = (j / l) * THREE.Math.PI * 2;
                positions.push(THREE.Math.cos(p1), THREE.Math.sin(p1), 1, THREE.Math.cos(p2), THREE.Math.sin(p2), 1);
            }
            geometry.addAttribute('position', new THREE.Float32Attribute(positions, 3));
            var material = new THREE.LineBasicMaterial({ fog: false });
            this.cone = new THREE.LineSegments(geometry, material);
            this.add(this.cone);
            this.update();
        }
        SpotLightHelper.prototype.dispose = function () {
            this.cone.geometry.dispose();
            this.cone.material.dispose();
        };
        SpotLightHelper.prototype.update = function () {
            var vector = SpotLightHelper["update_vector"] || (SpotLightHelper["update_vector"] = new THREE.Vector3());
            var vector2 = SpotLightHelper["update_vector2"] || (SpotLightHelper["update_vector2"] = new THREE.Vector3());
            var coneLength = this.light.distance ? this.light.distance : 1000;
            var coneWidth = coneLength * THREE.Math.tan(this.light.angle);
            this.cone.scale.set(coneWidth, coneWidth, coneLength);
            vector.setFromMatrixPosition(this.light.matrixWorld);
            vector2.setFromMatrixPosition(this.light.target.matrixWorld);
            this.cone.lookAt(vector2.sub(vector));
            this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        };
        return SpotLightHelper;
    }(THREE.Object3D));
    THREE.SpotLightHelper = SpotLightHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var VertexNormalsHelper = (function (_super) {
        __extends(VertexNormalsHelper, _super);
        function VertexNormalsHelper(object, size, hex, linewidth) {
            _super.call(this);
            this.object = object;
            this.size = (size !== undefined) ? size : 1;
            var color = (hex !== undefined) ? hex : 0xff0000;
            var width = (linewidth !== undefined) ? linewidth : 1;
            var nNormals = 0;
            var objGeometry = this.object.geometry;
            if (objGeometry instanceof THREE.Geometry) {
                nNormals = objGeometry.faces.length * 3;
            }
            else if (objGeometry instanceof THREE.BufferGeometry) {
                nNormals = objGeometry.attributes.normal.count;
            }
            var geometry = new THREE.BufferGeometry();
            var positions = new THREE.Float32Attribute(nNormals * 2 * 3, 3);
            geometry.addAttribute('position', positions);
            this.geometry = geometry;
            this.material = new THREE.LineBasicMaterial({ color: color, linewidth: width });
            this.matrixAutoUpdate = false;
            this.update();
        }
        VertexNormalsHelper.prototype.update = function () {
            var v1 = VertexNormalsHelper["__update_v1"] || (VertexNormalsHelper["__update_v1"] = new THREE.Vector3());
            var v2 = VertexNormalsHelper["__update_v2"] || (VertexNormalsHelper["__update_v2"] = new THREE.Vector3());
            var normalMatrix = VertexNormalsHelper["__update_normalMatrix"] || (VertexNormalsHelper["__update_normalMatrix"] = new THREE.Matrix3());
            var keys = ['a', 'b', 'c'];
            this.object.updateMatrixWorld(true);
            normalMatrix.getNormalMatrix(this.object.matrixWorld);
            var matrixWorld = this.object.matrixWorld;
            var position = this.geometry.attributes.position;
            var objGeometry = this.object.geometry;
            if (objGeometry instanceof THREE.Geometry) {
                var vertices = objGeometry.vertices;
                var faces = objGeometry.faces;
                var idx = 0;
                for (var i = 0, l = faces.length; i < l; i++) {
                    var face = faces[i];
                    for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                        var vertex = vertices[face[keys[j]]];
                        var normal = face.vertexNormals[j];
                        v1.copy(vertex).applyMatrix4(matrixWorld);
                        v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                        position.setXYZ(idx, v1.x, v1.y, v1.z);
                        idx = idx + 1;
                        position.setXYZ(idx, v2.x, v2.y, v2.z);
                        idx = idx + 1;
                    }
                }
            }
            else if (objGeometry instanceof THREE.BufferGeometry) {
                var objPos = objGeometry.attributes.position;
                var objNorm = objGeometry.attributes.normal;
                var idx = 0;
                for (var j_1 = 0, jl_1 = objPos.count; j_1 < jl_1; j_1++) {
                    v1.set(objPos.getX(j_1), objPos.getY(j_1), objPos.getZ(j_1)).applyMatrix4(matrixWorld);
                    v2.set(objNorm.getX(j_1), objNorm.getY(j_1), objNorm.getZ(j_1));
                    v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                    position.setXYZ(idx, v1.x, v1.y, v1.z);
                    idx = idx + 1;
                    position.setXYZ(idx, v2.x, v2.y, v2.z);
                    idx = idx + 1;
                }
            }
            position.needsUpdate = true;
            return this;
        };
        return VertexNormalsHelper;
    }(THREE.LineSegments));
    THREE.VertexNormalsHelper = VertexNormalsHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WireframeHelper = (function (_super) {
        __extends(WireframeHelper, _super);
        function WireframeHelper(object, hex) {
            _super.call(this);
            var color = (hex !== undefined) ? hex : 0xffffff;
            this.geometry = new THREE.WireframeGeometry(object.geometry);
            this.material = new THREE.LineBasicMaterial({ color: color });
            this.matrix = object.matrixWorld;
            this.matrixAutoUpdate = false;
        }
        ;
        return WireframeHelper;
    }(THREE.LineSegments));
    THREE.WireframeHelper = WireframeHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var ImmediateRenderObject = (function (_super) {
        __extends(ImmediateRenderObject, _super);
        function ImmediateRenderObject(material) {
            _super.call(this);
            this.material = material;
            this.render = function (renderCallback) { };
        }
        ;
        return ImmediateRenderObject;
    }(THREE.Object3D));
    THREE.ImmediateRenderObject = ImmediateRenderObject;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var MorphBlendMesh = (function (_super) {
        __extends(MorphBlendMesh, _super);
        function MorphBlendMesh(geometry, material) {
            _super.call(this, geometry, material);
            this.setAnimationWeight = function (name, weight) {
                var animation = this.animationsMap[name];
                if (animation) {
                    animation.weight = weight;
                }
            };
            this.setAnimationTime = function (name, time) {
                var animation = this.animationsMap[name];
                if (animation) {
                    animation.time = time;
                }
            };
            this.getAnimationTime = function (name) {
                var time = 0;
                var animation = this.animationsMap[name];
                if (animation) {
                    time = animation.time;
                }
                return time;
            };
            this.animationsMap = {};
            this.animationsList = [];
            var numFrames = this.geometry.morphTargets.length;
            var name = "__default";
            var startFrame = 0;
            var endFrame = numFrames - 1;
            var fps = numFrames / 1;
            this.createAnimation(name, startFrame, endFrame, fps);
            this.setAnimationWeight(name, 1);
        }
        ;
        MorphBlendMesh.prototype.createAnimation = function (name, start, end, fps) {
            var animation = {
                start: start,
                end: end,
                length: end - start + 1,
                fps: fps,
                duration: (end - start) / fps,
                lastFrame: 0,
                currentFrame: 0,
                active: false,
                time: 0,
                direction: 1,
                weight: 1,
                directionBackwards: false,
                mirroredLoop: false
            };
            this.animationsMap[name] = animation;
            this.animationsList.push(animation);
        };
        ;
        MorphBlendMesh.prototype.autoCreateAnimations = function (fps) {
            var pattern = /([a-z]+)_?(\d+)/i;
            var firstAnimation, frameRanges = {};
            var geometry = this.geometry;
            for (var i = 0, il = geometry.morphTargets.length; i < il; i++) {
                var morph = geometry.morphTargets[i];
                var chunks = morph.name.match(pattern);
                if (chunks && chunks.length > 1) {
                    var name = chunks[1];
                    if (!frameRanges[name])
                        frameRanges[name] = { start: Infinity, end: -Infinity };
                    var range = frameRanges[name];
                    if (i < range.start)
                        range.start = i;
                    if (i > range.end)
                        range.end = i;
                    if (!firstAnimation)
                        firstAnimation = name;
                }
            }
            for (var name_3 in frameRanges) {
                var range = frameRanges[name_3];
                this.createAnimation(name_3, range.start, range.end, fps);
            }
            this.firstAnimation = firstAnimation;
        };
        MorphBlendMesh.prototype.setAnimationDirectionForward = function (name) {
            var animation = this.animationsMap[name];
            if (animation) {
                animation.direction = 1;
                animation.directionBackwards = false;
            }
        };
        MorphBlendMesh.prototype.setAnimationDirectionBackward = function (name) {
            var animation = this.animationsMap[name];
            if (animation) {
                animation.direction = -1;
                animation.directionBackwards = true;
            }
        };
        ;
        MorphBlendMesh.prototype.setAnimationFPS = function (name, fps) {
            var animation = this.animationsMap[name];
            if (animation) {
                animation.fps = fps;
                animation.duration = (animation.end - animation.start) / animation.fps;
            }
        };
        ;
        MorphBlendMesh.prototype.setAnimationDuration = function (name, duration) {
            var animation = this.animationsMap[name];
            if (animation) {
                animation.duration = duration;
                animation.fps = (animation.end - animation.start) / animation.duration;
            }
        };
        MorphBlendMesh.prototype.getAnimationDuration = function (name) {
            var duration = -1;
            var animation = this.animationsMap[name];
            if (animation) {
                duration = animation.duration;
            }
            return duration;
        };
        ;
        MorphBlendMesh.prototype.playAnimation = function (name) {
            var animation = this.animationsMap[name];
            if (animation) {
                animation.time = 0;
                animation.active = true;
            }
            else {
                console.warn("THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()");
            }
        };
        ;
        MorphBlendMesh.prototype.stopAnimation = function (name) {
            var animation = this.animationsMap[name];
            if (animation) {
                animation.active = false;
            }
        };
        ;
        MorphBlendMesh.prototype.update = function (delta) {
            for (var i = 0, il = this.animationsList.length; i < il; i++) {
                var animation = this.animationsList[i];
                if (!animation.active)
                    continue;
                var frameTime = animation.duration / animation.length;
                animation.time += animation.direction * delta;
                if (animation.mirroredLoop) {
                    if (animation.time > animation.duration || animation.time < 0) {
                        animation.direction *= -1;
                        if (animation.time > animation.duration) {
                            animation.time = animation.duration;
                            animation.directionBackwards = true;
                        }
                        if (animation.time < 0) {
                            animation.time = 0;
                            animation.directionBackwards = false;
                        }
                    }
                }
                else {
                    animation.time = animation.time % animation.duration;
                    if (animation.time < 0)
                        animation.time += animation.duration;
                }
                var keyframe = animation.start + THREE.Math.clamp(THREE.Math.floor(animation.time / frameTime), 0, animation.length - 1);
                var weight = animation.weight;
                if (keyframe !== animation.currentFrame) {
                    this.morphTargetInfluences[animation.lastFrame] = 0;
                    this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
                    this.morphTargetInfluences[keyframe] = 0;
                    animation.lastFrame = animation.currentFrame;
                    animation.currentFrame = keyframe;
                }
                var mix = (animation.time % frameTime) / frameTime;
                if (animation.directionBackwards)
                    mix = 1 - mix;
                if (animation.currentFrame !== animation.lastFrame) {
                    this.morphTargetInfluences[animation.currentFrame] = mix * weight;
                    this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;
                }
                else {
                    this.morphTargetInfluences[animation.currentFrame] = weight;
                }
            }
        };
        ;
        return MorphBlendMesh;
    }(THREE.Mesh));
    THREE.MorphBlendMesh = MorphBlendMesh;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    THREE.SceneUtils = {
        createMultiMaterialObject: function (geometry, materials) {
            var group = new THREE.Group();
            for (var i = 0, l = materials.length; i < l; i++) {
                group.add(new THREE.Mesh(geometry, materials[i]));
            }
            return group;
        },
        detach: function (child, parent, scene) {
            child.applyMatrix(parent.matrixWorld);
            parent.remove(child);
            scene.add(child);
        },
        attach: function (child, scene, parent) {
            var matrixWorldInverse = new THREE.Matrix4();
            matrixWorldInverse.getInverse(parent.matrixWorld);
            child.applyMatrix(matrixWorldInverse);
            scene.remove(child);
            parent.add(child);
        }
    };
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    THREE.ShapeUtils = {
        area: function (contour) {
            var n = contour.length;
            var a = 0.0;
            for (var p = n - 1, q = 0; q < n; p = q++) {
                a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
            }
            return a * 0.5;
        },
        triangulate: (function () {
            function snip(contour, u, v, w, n, verts) {
                var p;
                var ax, ay, bx, by;
                var cx, cy, px, py;
                ax = contour[verts[u]].x;
                ay = contour[verts[u]].y;
                bx = contour[verts[v]].x;
                by = contour[verts[v]].y;
                cx = contour[verts[w]].x;
                cy = contour[verts[w]].y;
                if (Number.EPSILON > (((bx - ax) * (cy - ay)) - ((by - ay) * (cx - ax))))
                    return false;
                var aX, aY, bX, bY, cX, cY;
                var apx, apy, bpx, bpy, cpx, cpy;
                var cCROSSap, bCROSScp, aCROSSbp;
                aX = cx - bx;
                aY = cy - by;
                bX = ax - cx;
                bY = ay - cy;
                cX = bx - ax;
                cY = by - ay;
                for (p = 0; p < n; p++) {
                    px = contour[verts[p]].x;
                    py = contour[verts[p]].y;
                    if (((px === ax) && (py === ay)) ||
                        ((px === bx) && (py === by)) ||
                        ((px === cx) && (py === cy)))
                        continue;
                    apx = px - ax;
                    apy = py - ay;
                    bpx = px - bx;
                    bpy = py - by;
                    cpx = px - cx;
                    cpy = py - cy;
                    aCROSSbp = aX * bpy - aY * bpx;
                    cCROSSap = cX * apy - cY * apx;
                    bCROSScp = bX * cpy - bY * cpx;
                    if ((aCROSSbp >= -Number.EPSILON) && (bCROSScp >= -Number.EPSILON) && (cCROSSap >= -Number.EPSILON))
                        return false;
                }
                return true;
            }
            return function triangulate(contour, indices) {
                var n = contour.length;
                if (n < 3)
                    return null;
                var result = [], verts = [], vertIndices = [];
                var u, v, w;
                if (THREE.ShapeUtils.area(contour) > 0.0) {
                    for (v = 0; v < n; v++)
                        verts[v] = v;
                }
                else {
                    for (v = 0; v < n; v++)
                        verts[v] = (n - 1) - v;
                }
                var nv = n;
                var count = 2 * nv;
                for (v = nv - 1; nv > 2;) {
                    if ((count--) <= 0) {
                        console.warn('THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()');
                        if (indices)
                            return vertIndices;
                        return result;
                    }
                    u = v;
                    if (nv <= u)
                        u = 0;
                    v = u + 1;
                    if (nv <= v)
                        v = 0;
                    w = v + 1;
                    if (nv <= w)
                        w = 0;
                    if (snip(contour, u, v, w, nv, verts)) {
                        var a, b, c, s, t;
                        a = verts[u];
                        b = verts[v];
                        c = verts[w];
                        result.push([contour[a],
                            contour[b],
                            contour[c]]);
                        vertIndices.push([verts[u], verts[v], verts[w]]);
                        for (s = v, t = v + 1; t < nv; s++, t++) {
                            verts[s] = verts[t];
                        }
                        nv--;
                        count = 2 * nv;
                    }
                }
                if (indices)
                    return vertIndices;
                return result;
            };
        })(),
        triangulateShape: function (contour, holes) {
            function removeDupEndPts(points) {
                var l = points.length;
                if (l > 2 && points[l - 1].equals(points[0])) {
                    points.pop();
                }
            }
            removeDupEndPts(contour);
            holes.forEach(removeDupEndPts);
            function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {
                if (inSegPt1.x !== inSegPt2.x) {
                    if (inSegPt1.x < inSegPt2.x) {
                        return ((inSegPt1.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt2.x));
                    }
                    else {
                        return ((inSegPt2.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt1.x));
                    }
                }
                else {
                    if (inSegPt1.y < inSegPt2.y) {
                        return ((inSegPt1.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt2.y));
                    }
                    else {
                        return ((inSegPt2.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt1.y));
                    }
                }
            }
            function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {
                var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x, seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
                var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x, seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
                var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
                var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
                var limit = seg1dy * seg2dx - seg1dx * seg2dy;
                var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
                if (THREE.Math.abs(limit) > Number.EPSILON) {
                    var perpSeg2;
                    if (limit > 0) {
                        if ((perpSeg1 < 0) || (perpSeg1 > limit))
                            return [];
                        perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                        if ((perpSeg2 < 0) || (perpSeg2 > limit))
                            return [];
                    }
                    else {
                        if ((perpSeg1 > 0) || (perpSeg1 < limit))
                            return [];
                        perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                        if ((perpSeg2 > 0) || (perpSeg2 < limit))
                            return [];
                    }
                    if (perpSeg2 === 0) {
                        if ((inExcludeAdjacentSegs) &&
                            ((perpSeg1 === 0) || (perpSeg1 === limit)))
                            return [];
                        return [inSeg1Pt1];
                    }
                    if (perpSeg2 === limit) {
                        if ((inExcludeAdjacentSegs) &&
                            ((perpSeg1 === 0) || (perpSeg1 === limit)))
                            return [];
                        return [inSeg1Pt2];
                    }
                    if (perpSeg1 === 0)
                        return [inSeg2Pt1];
                    if (perpSeg1 === limit)
                        return [inSeg2Pt2];
                    var factorSeg1 = perpSeg2 / limit;
                    return [{
                            x: inSeg1Pt1.x + factorSeg1 * seg1dx,
                            y: inSeg1Pt1.y + factorSeg1 * seg1dy
                        }];
                }
                else {
                    if ((perpSeg1 !== 0) ||
                        (seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy))
                        return [];
                    var seg1Pt = ((seg1dx === 0) && (seg1dy === 0));
                    var seg2Pt = ((seg2dx === 0) && (seg2dy === 0));
                    if (seg1Pt && seg2Pt) {
                        if ((inSeg1Pt1.x !== inSeg2Pt1.x) ||
                            (inSeg1Pt1.y !== inSeg2Pt1.y))
                            return [];
                        return [inSeg1Pt1];
                    }
                    if (seg1Pt) {
                        if (!point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1))
                            return [];
                        return [inSeg1Pt1];
                    }
                    if (seg2Pt) {
                        if (!point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1))
                            return [];
                        return [inSeg2Pt1];
                    }
                    var seg1min, seg1max, seg1minVal, seg1maxVal;
                    var seg2min, seg2max, seg2minVal, seg2maxVal;
                    if (seg1dx !== 0) {
                        if (inSeg1Pt1.x < inSeg1Pt2.x) {
                            seg1min = inSeg1Pt1;
                            seg1minVal = inSeg1Pt1.x;
                            seg1max = inSeg1Pt2;
                            seg1maxVal = inSeg1Pt2.x;
                        }
                        else {
                            seg1min = inSeg1Pt2;
                            seg1minVal = inSeg1Pt2.x;
                            seg1max = inSeg1Pt1;
                            seg1maxVal = inSeg1Pt1.x;
                        }
                        if (inSeg2Pt1.x < inSeg2Pt2.x) {
                            seg2min = inSeg2Pt1;
                            seg2minVal = inSeg2Pt1.x;
                            seg2max = inSeg2Pt2;
                            seg2maxVal = inSeg2Pt2.x;
                        }
                        else {
                            seg2min = inSeg2Pt2;
                            seg2minVal = inSeg2Pt2.x;
                            seg2max = inSeg2Pt1;
                            seg2maxVal = inSeg2Pt1.x;
                        }
                    }
                    else {
                        if (inSeg1Pt1.y < inSeg1Pt2.y) {
                            seg1min = inSeg1Pt1;
                            seg1minVal = inSeg1Pt1.y;
                            seg1max = inSeg1Pt2;
                            seg1maxVal = inSeg1Pt2.y;
                        }
                        else {
                            seg1min = inSeg1Pt2;
                            seg1minVal = inSeg1Pt2.y;
                            seg1max = inSeg1Pt1;
                            seg1maxVal = inSeg1Pt1.y;
                        }
                        if (inSeg2Pt1.y < inSeg2Pt2.y) {
                            seg2min = inSeg2Pt1;
                            seg2minVal = inSeg2Pt1.y;
                            seg2max = inSeg2Pt2;
                            seg2maxVal = inSeg2Pt2.y;
                        }
                        else {
                            seg2min = inSeg2Pt2;
                            seg2minVal = inSeg2Pt2.y;
                            seg2max = inSeg2Pt1;
                            seg2maxVal = inSeg2Pt1.y;
                        }
                    }
                    if (seg1minVal <= seg2minVal) {
                        if (seg1maxVal < seg2minVal)
                            return [];
                        if (seg1maxVal === seg2minVal) {
                            if (inExcludeAdjacentSegs)
                                return [];
                            return [seg2min];
                        }
                        if (seg1maxVal <= seg2maxVal)
                            return [seg2min, seg1max];
                        return [seg2min, seg2max];
                    }
                    else {
                        if (seg1minVal > seg2maxVal)
                            return [];
                        if (seg1minVal === seg2maxVal) {
                            if (inExcludeAdjacentSegs)
                                return [];
                            return [seg1min];
                        }
                        if (seg1maxVal <= seg2maxVal)
                            return [seg1min, seg1max];
                        return [seg1min, seg2max];
                    }
                }
            }
            function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {
                var legFromPtX = inLegFromPt.x - inVertex.x, legFromPtY = inLegFromPt.y - inVertex.y;
                var legToPtX = inLegToPt.x - inVertex.x, legToPtY = inLegToPt.y - inVertex.y;
                var otherPtX = inOtherPt.x - inVertex.x, otherPtY = inOtherPt.y - inVertex.y;
                var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
                var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;
                if (THREE.Math.abs(from2toAngle) > Number.EPSILON) {
                    var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
                    if (from2toAngle > 0) {
                        return ((from2otherAngle >= 0) && (other2toAngle >= 0));
                    }
                    else {
                        return ((from2otherAngle >= 0) || (other2toAngle >= 0));
                    }
                }
                else {
                    return (from2otherAngle > 0);
                }
            }
            function removeHoles(contour, holes) {
                var shape = contour.concat();
                var hole;
                function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {
                    var lastShapeIdx = shape.length - 1;
                    var prevShapeIdx = inShapeIdx - 1;
                    if (prevShapeIdx < 0)
                        prevShapeIdx = lastShapeIdx;
                    var nextShapeIdx = inShapeIdx + 1;
                    if (nextShapeIdx > lastShapeIdx)
                        nextShapeIdx = 0;
                    var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
                    if (!insideAngle) {
                        return false;
                    }
                    var lastHoleIdx = hole.length - 1;
                    var prevHoleIdx = inHoleIdx - 1;
                    if (prevHoleIdx < 0)
                        prevHoleIdx = lastHoleIdx;
                    var nextHoleIdx = inHoleIdx + 1;
                    if (nextHoleIdx > lastHoleIdx)
                        nextHoleIdx = 0;
                    insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]);
                    if (!insideAngle) {
                        return false;
                    }
                    return true;
                }
                function intersectsShapeEdge(inShapePt, inHolePt) {
                    var sIdx, nextIdx, intersection;
                    for (sIdx = 0; sIdx < shape.length; sIdx++) {
                        nextIdx = sIdx + 1;
                        nextIdx %= shape.length;
                        intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true);
                        if (intersection.length > 0)
                            return true;
                    }
                    return false;
                }
                var indepHoles = [];
                function intersectsHoleEdge(inShapePt, inHolePt) {
                    var ihIdx, chkHole, hIdx, nextIdx, intersection;
                    for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) {
                        chkHole = holes[indepHoles[ihIdx]];
                        for (hIdx = 0; hIdx < chkHole.length; hIdx++) {
                            nextIdx = hIdx + 1;
                            nextIdx %= chkHole.length;
                            intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true);
                            if (intersection.length > 0)
                                return true;
                        }
                    }
                    return false;
                }
                var holeIndex, shapeIndex, shapePt, holePt, holeIdx, cutKey, failedCuts = [], tmpShape1, tmpShape2, tmpHole1, tmpHole2;
                for (var h = 0, hl = holes.length; h < hl; h++) {
                    indepHoles.push(h);
                }
                var minShapeIndex = 0;
                var counter = indepHoles.length * 2;
                while (indepHoles.length > 0) {
                    counter--;
                    if (counter < 0) {
                        console.log("Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!");
                        break;
                    }
                    for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {
                        shapePt = shape[shapeIndex];
                        holeIndex = -1;
                        for (var h = 0; h < indepHoles.length; h++) {
                            holeIdx = indepHoles[h];
                            cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
                            if (failedCuts[cutKey] !== undefined)
                                continue;
                            hole = holes[holeIdx];
                            for (var h2 = 0; h2 < hole.length; h2++) {
                                holePt = hole[h2];
                                if (!isCutLineInsideAngles(shapeIndex, h2))
                                    continue;
                                if (intersectsShapeEdge(shapePt, holePt))
                                    continue;
                                if (intersectsHoleEdge(shapePt, holePt))
                                    continue;
                                holeIndex = h2;
                                indepHoles.splice(h, 1);
                                tmpShape1 = shape.slice(0, shapeIndex + 1);
                                tmpShape2 = shape.slice(shapeIndex);
                                tmpHole1 = hole.slice(holeIndex);
                                tmpHole2 = hole.slice(0, holeIndex + 1);
                                shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);
                                minShapeIndex = shapeIndex;
                                break;
                            }
                            if (holeIndex >= 0)
                                break;
                            failedCuts[cutKey] = true;
                        }
                        if (holeIndex >= 0)
                            break;
                    }
                }
                return shape;
            }
            var i, il, f, face, key, index, allPointsMap = {};
            var allpoints = contour.concat();
            for (var h = 0, hl = holes.length; h < hl; h++) {
                Array.prototype.push.apply(allpoints, holes[h]);
            }
            for (i = 0, il = allpoints.length; i < il; i++) {
                key = allpoints[i].x + ":" + allpoints[i].y;
                if (allPointsMap[key] !== undefined) {
                    console.warn("THREE.Shape: Duplicate point", key, i);
                }
                allPointsMap[key] = i;
            }
            var shapeWithoutHoles = removeHoles(contour, holes);
            var triangles = THREE.ShapeUtils.triangulate(shapeWithoutHoles, false);
            for (i = 0, il = triangles.length; i < il; i++) {
                face = triangles[i];
                for (f = 0; f < 3; f++) {
                    key = face[f].x + ":" + face[f].y;
                    index = allPointsMap[key];
                    if (index !== undefined) {
                        face[f] = index;
                    }
                }
            }
            return triangles.concat();
        },
        isClockWise: function (pts) {
            return THREE.ShapeUtils.area(pts) < 0;
        },
        b2: (function () {
            function b2p0(t, p) {
                var k = 1 - t;
                return k * k * p;
            }
            function b2p1(t, p) {
                return 2 * (1 - t) * t * p;
            }
            function b2p2(t, p) {
                return t * t * p;
            }
            return function b2(t, p0, p1, p2) {
                return b2p0(t, p0) + b2p1(t, p1) + b2p2(t, p2);
            };
        })(),
        b3: (function () {
            function b3p0(t, p) {
                var k = 1 - t;
                return k * k * k * p;
            }
            function b3p1(t, p) {
                var k = 1 - t;
                return 3 * k * k * t * p;
            }
            function b3p2(t, p) {
                var k = 1 - t;
                return 3 * k * t * t * p;
            }
            function b3p3(t, p) {
                return t * t * t * p;
            }
            return function b3(t, p0, p1, p2, p3) {
                return b3p0(t, p0) + b3p1(t, p1) + b3p2(t, p2) + b3p3(t, p3);
            };
        })()
    };
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Light = (function (_super) {
        __extends(Light, _super);
        function Light(color, intensity) {
            _super.call(this);
            this.type = 'Light';
            this.color = new THREE.Color(color);
            this.intensity = intensity !== undefined ? intensity : 1;
            this.receiveShadow = undefined;
        }
        ;
        Light.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.intensity = source.intensity;
            return this;
        };
        Light.prototype.toJSON = function (meta) {
            var data = _super.prototype.toJSON.call(this, meta);
            data.object.color = this.color.getHex();
            data.object.intensity = this.intensity;
            if (this.groundColor !== undefined)
                data.object.groundColor = this.groundColor.getHex();
            if (this.distance !== undefined)
                data.object.distance = this.distance;
            if (this.angle !== undefined)
                data.object.angle = this.angle;
            if (this.decay !== undefined)
                data.object.decay = this.decay;
            if (this.penumbra !== undefined)
                data.object.penumbra = this.penumbra;
            return data;
        };
        return Light;
    }(THREE.Object3D));
    THREE.Light = Light;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var AmbientLight = (function (_super) {
        __extends(AmbientLight, _super);
        function AmbientLight(color, intensity) {
            _super.call(this, color, intensity);
            this.type = 'AmbientLight';
            this.castShadow = undefined;
        }
        ;
        return AmbientLight;
    }(THREE.Light));
    THREE.AmbientLight = AmbientLight;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var DirectionalLight = (function (_super) {
        __extends(DirectionalLight, _super);
        function DirectionalLight(color, intensity) {
            _super.call(this, color, intensity);
            this.type = 'DirectionalLight';
            this.position.copy(THREE.Object3D.DefaultUp);
            this.updateMatrix();
            this.target = new THREE.Object3D();
            this.shadow = new THREE.DirectionalLightShadow(this);
        }
        ;
        DirectionalLight.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.target = source.target.clone();
            this.shadow = source.shadow.clone();
            return this;
        };
        return DirectionalLight;
    }(THREE.Light));
    THREE.DirectionalLight = DirectionalLight;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var LightShadow = (function () {
        function LightShadow(camera) {
            this.camera = camera;
            this.bias = 0;
            this.radius = 1;
            this.mapSize = new THREE.Vector2(512, 512);
            this.map = null;
            this.matrix = new THREE.Matrix4();
        }
        LightShadow.prototype.copy = function (source) {
            this.camera = source.camera.clone();
            this.bias = source.bias;
            this.radius = source.radius;
            this.mapSize.copy(source.mapSize);
            return this;
        };
        LightShadow.prototype.clone = function () {
            return new this.constructor().copy(this);
        };
        return LightShadow;
    }());
    THREE.LightShadow = LightShadow;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var DirectionalLightShadow = (function (_super) {
        __extends(DirectionalLightShadow, _super);
        function DirectionalLightShadow(light) {
            _super.call(this, new THREE.OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
        }
        return DirectionalLightShadow;
    }(THREE.LightShadow));
    THREE.DirectionalLightShadow = DirectionalLightShadow;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var HemisphereLight = (function (_super) {
        __extends(HemisphereLight, _super);
        function HemisphereLight(skyColor, groundColor, intensity) {
            _super.call(this, skyColor, intensity);
            this.type = 'HemisphereLight';
            this.castShadow = undefined;
            this.position.copy(THREE.Object3D.DefaultUp);
            this.updateMatrix();
            this.groundColor = new THREE.Color(groundColor);
        }
        ;
        HemisphereLight.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.groundColor.copy(source.groundColor);
            return this;
        };
        return HemisphereLight;
    }(THREE.Light));
    THREE.HemisphereLight = HemisphereLight;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var PointLight = (function (_super) {
        __extends(PointLight, _super);
        function PointLight(color, intensity, distance, decay) {
            _super.call(this, color, intensity);
            this.type = 'PointLight';
            this.distance = (distance !== undefined) ? distance : 0;
            this.decay = (decay !== undefined) ? decay : 1;
            this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(90, 1, 0.5, 500));
        }
        ;
        Object.defineProperty(PointLight.prototype, "power", {
            get: function () {
                return this.intensity * 4 * THREE.Math.PI;
            },
            enumerable: true,
            configurable: true
        });
        PointLight.prototype.set = function (power) {
            this.intensity = power / (4 * THREE.Math.PI);
        };
        PointLight.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.distance = source.distance;
            this.decay = source.decay;
            this.shadow = source.shadow.clone();
            return this;
        };
        return PointLight;
    }(THREE.Light));
    THREE.PointLight = PointLight;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var SpotLight = (function (_super) {
        __extends(SpotLight, _super);
        function SpotLight(color, intensity, distance, angle, penumbra, decay) {
            _super.call(this, color, intensity);
            this.type = 'SpotLight';
            this.position.copy(THREE.Object3D.DefaultUp);
            this.updateMatrix();
            this.target = new THREE.Object3D();
            this.distance = (distance !== undefined) ? distance : 0;
            this.angle = (angle !== undefined) ? angle : THREE.Math.PI / 3;
            this.penumbra = (penumbra !== undefined) ? penumbra : 0;
            this.decay = (decay !== undefined) ? decay : 1;
            this.shadow = new THREE.SpotLightShadow();
        }
        ;
        Object.defineProperty(SpotLight.prototype, "power", {
            get: function () {
                return this.intensity * THREE.Math.PI;
            },
            set: function (power) {
                this.intensity = power / THREE.Math.PI;
            },
            enumerable: true,
            configurable: true
        });
        SpotLight.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.distance = source.distance;
            this.angle = source.angle;
            this.penumbra = source.penumbra;
            this.decay = source.decay;
            this.target = source.target.clone();
            this.shadow = source.shadow.clone();
            return this;
        };
        return SpotLight;
    }(THREE.Light));
    THREE.SpotLight = SpotLight;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var SpotLightShadow = (function (_super) {
        __extends(SpotLightShadow, _super);
        function SpotLightShadow() {
            _super.call(this, new THREE.PerspectiveCamera(50, 1, 0.5, 500));
        }
        SpotLightShadow.prototype.update = function (light) {
            var fov = THREE.Math.RAD2DEG * 2 * light.angle;
            var aspect = this.mapSize.width / this.mapSize.height;
            var far = light.distance || 500;
            var camera = this.camera;
            if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
                camera.fov = fov;
                camera.aspect = aspect;
                camera.far = far;
                camera.updateProjectionMatrix();
            }
        };
        return SpotLightShadow;
    }(THREE.LightShadow));
    THREE.SpotLightShadow = SpotLightShadow;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var AnimationLoader = (function () {
        function AnimationLoader(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        }
        ;
        AnimationLoader.prototype.load = function (url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new THREE.XHRLoader(scope.manager);
            loader.load(url, function (text) {
                onLoad(scope.parse(JSON.parse(text)));
            }, onProgress, onError);
        };
        AnimationLoader.prototype.parse = function (json, onLoad) {
            var animations = [];
            for (var i = 0; i < json.length; i++) {
                var clip = THREE.AnimationClip.parse(json[i]);
                animations.push(clip);
            }
            if (onload !== undefined)
                onLoad(animations);
        };
        return AnimationLoader;
    }());
    THREE.AnimationLoader = AnimationLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var AudioLoader = (function () {
        function AudioLoader(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        }
        ;
        AudioLoader.prototype.load = function (url, onLoad, onProgress, onError) {
            var loader = new THREE.XHRLoader(this.manager);
            loader.setResponseType('arraybuffer');
            loader.load(url, function (buffer) {
                var context = THREE.AudioContext;
                context.decodeAudioData(buffer, function (audioBuffer) {
                    onLoad(audioBuffer);
                });
            }, onProgress, onError);
        };
        return AudioLoader;
    }());
    THREE.AudioLoader = AudioLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var BinaryTextureLoader = (function () {
        function BinaryTextureLoader(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
            this._parser = null;
        }
        ;
        BinaryTextureLoader.prototype.load = function (url, onLoad, onProgress, onError) {
            var scope = this;
            var texture = new THREE.DataTexture();
            var loader = new THREE.XHRLoader(this.manager);
            loader.setResponseType('arraybuffer');
            loader.load(url, function (buffer) {
                var texData = scope._parser(buffer);
                if (!texData)
                    return;
                if (undefined !== texData.image) {
                    texture.image = texData.image;
                }
                else if (undefined !== texData.data) {
                    texture.image.width = texData.width;
                    texture.image.height = texData.height;
                    texture.image.data = texData.data;
                }
                texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
                texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;
                texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
                texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;
                texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
                if (undefined !== texData.format) {
                    texture.format = texData.format;
                }
                if (undefined !== texData.type) {
                    texture.type = texData.type;
                }
                if (undefined !== texData.mipmaps) {
                    texture.mipmaps = texData.mipmaps;
                }
                if (1 === texData.mipmapCount) {
                    texture.minFilter = THREE.LinearFilter;
                }
                texture.needsUpdate = true;
                if (onLoad)
                    onLoad(texture, texData);
            }, onProgress, onError);
            return texture;
        };
        return BinaryTextureLoader;
    }());
    THREE.BinaryTextureLoader = BinaryTextureLoader;
    THREE.DataTextureLoader = BinaryTextureLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var BufferGeometryLoader = (function () {
        function BufferGeometryLoader(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        }
        ;
        BufferGeometryLoader.prototype.load = function (url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new THREE.XHRLoader(scope.manager);
            loader.load(url, function (text) {
                onLoad(scope.parse(JSON.parse(text)));
            }, onProgress, onError);
        };
        BufferGeometryLoader.prototype.parse = function (json) {
            var geometry = new THREE.BufferGeometry();
            var index = json.data.index;
            var TYPED_ARRAYS = {
                'Int8Array': Int8Array,
                'Uint8Array': Uint8Array,
                'Uint8ClampedArray': Uint8ClampedArray,
                'Int16Array': Int16Array,
                'Uint16Array': Uint16Array,
                'Int32Array': Int32Array,
                'Uint32Array': Uint32Array,
                'Float32Array': Float32Array,
                'Float64Array': Float64Array
            };
            if (index !== undefined) {
                var typedArray = new TYPED_ARRAYS[index.type](index.array);
                geometry.setIndex(new THREE.BufferAttribute(typedArray, 1));
            }
            var attributes = json.data.attributes;
            for (var key in attributes) {
                var attribute = attributes[key];
                var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                geometry.addAttribute(key, new THREE.BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));
            }
            var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
            if (groups !== undefined) {
                for (var i = 0, n = groups.length; i !== n; ++i) {
                    var group = groups[i];
                    geometry.addGroup(group.start, group.count, group.materialIndex);
                }
            }
            var boundingSphere = json.data.boundingSphere;
            if (boundingSphere !== undefined) {
                var center = new THREE.Vector3();
                if (boundingSphere.center !== undefined) {
                    center.fromArray(boundingSphere.center);
                }
                geometry.boundingSphere = new THREE.Sphere(center, boundingSphere.radius);
            }
            return geometry;
        };
        return BufferGeometryLoader;
    }());
    THREE.BufferGeometryLoader = BufferGeometryLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    THREE.Cache = {
        enabled: false,
        files: {},
        add: function (key, file) {
            if (this.enabled === false)
                return;
            this.files[key] = file;
        },
        get: function (key) {
            if (this.enabled === false)
                return;
            return this.files[key];
        },
        remove: function (key) {
            delete this.files[key];
        },
        clear: function () {
            this.files = {};
        }
    };
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var CompressedTextureLoader = (function () {
        function CompressedTextureLoader(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
            this._parser = null;
        }
        ;
        CompressedTextureLoader.prototype.load = function (url, onLoad, onProgress, onError) {
            var scope = this;
            var images = [];
            var texture = new THREE.CompressedTexture();
            texture.image = images;
            var loader = new THREE.XHRLoader(this.manager);
            loader.setPath(this.path);
            loader.setResponseType('arraybuffer');
            function loadTexture(i) {
                loader.load(url[i], function (buffer) {
                    var texDatas = scope._parser(buffer, true);
                    images[i] = {
                        width: texDatas.width,
                        height: texDatas.height,
                        format: texDatas.format,
                        mipmaps: texDatas.mipmaps
                    };
                    loaded += 1;
                    if (loaded === 6) {
                        if (texDatas.mipmapCount === 1)
                            texture.minFilter = THREE.LinearFilter;
                        texture.format = texDatas.format;
                        texture.needsUpdate = true;
                        if (onLoad)
                            onLoad(texture);
                    }
                }, onProgress, onError);
            }
            if (Array.isArray(url)) {
                var loaded = 0;
                for (var i = 0, il = url.length; i < il; ++i) {
                    loadTexture(i);
                }
            }
            else {
                loader.load(url, function (buffer) {
                    var texDatas = scope._parser(buffer, true);
                    if (texDatas.isCubemap) {
                        var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                        for (var f = 0; f < faces; f++) {
                            images[f] = { mipmaps: [] };
                            for (var i = 0; i < texDatas.mipmapCount; i++) {
                                images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                                images[f].format = texDatas.format;
                                images[f].width = texDatas.width;
                                images[f].height = texDatas.height;
                            }
                        }
                    }
                    else {
                        texture.image.width = texDatas.width;
                        texture.image.height = texDatas.height;
                        texture.mipmaps = texDatas.mipmaps;
                    }
                    if (texDatas.mipmapCount === 1) {
                        texture.minFilter = THREE.LinearFilter;
                    }
                    texture.format = texDatas.format;
                    texture.needsUpdate = true;
                    if (onLoad)
                        onLoad(texture);
                }, onProgress, onError);
            }
            return texture;
        };
        CompressedTextureLoader.prototype.setPath = function (value) {
            this.path = value;
            return this;
        };
        return CompressedTextureLoader;
    }());
    THREE.CompressedTextureLoader = CompressedTextureLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var CubeTextureLoader = (function () {
        function CubeTextureLoader(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        }
        CubeTextureLoader.prototype.load = function (urls, onLoad, onProgress, onError) {
            var texture = new THREE.CubeTexture();
            var loader = new THREE.ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            loader.setPath(this.path);
            var loaded = 0;
            function loadTexture(i) {
                loader.load(urls[i], function (image) {
                    texture.images[i] = image;
                    loaded++;
                    if (loaded === 6) {
                        texture.needsUpdate = true;
                        if (onLoad)
                            onLoad(texture);
                    }
                }, undefined, onError);
            }
            for (var i = 0; i < urls.length; ++i) {
                loadTexture(i);
            }
            return texture;
        };
        CubeTextureLoader.prototype.setCrossOrigin = function (value) {
            this.crossOrigin = value;
            return this;
        };
        CubeTextureLoader.prototype.setPath = function (value) {
            this.path = value;
            return this;
        };
        return CubeTextureLoader;
    }());
    THREE.CubeTextureLoader = CubeTextureLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var FontLoader = (function () {
        function FontLoader(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        }
        ;
        FontLoader.prototype.load = function (url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new THREE.XHRLoader(this.manager);
            loader.load(url, function (text) {
                var json;
                try {
                    json = JSON.parse(text);
                }
                catch (e) {
                    console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                    json = JSON.parse(text.substring(65, text.length - 2));
                }
                var font = scope.parse(json);
                if (onLoad)
                    onLoad(font);
            }, onProgress, onError);
        };
        FontLoader.prototype.parse = function (json) {
            return new THREE.Font(json);
        };
        return FontLoader;
    }());
    THREE.FontLoader = FontLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var ImageLoader = (function () {
        function ImageLoader(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        }
        ;
        ImageLoader.prototype.load = function (url, onLoad, onProgress, onError) {
            var scope = this;
            var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
            image.onload = function () {
                URL.revokeObjectURL(image.src);
                if (onLoad)
                    onLoad(image);
                scope.manager.itemEnd(url);
            };
            if (url.indexOf('data:') === 0) {
                image.src = url;
            }
            else {
                var loader = new THREE.XHRLoader();
                loader.setPath(this.path);
                loader.setResponseType('blob');
                loader.load(url, function (blob) {
                    image.src = URL.createObjectURL(blob);
                }, onProgress, onError);
            }
            scope.manager.itemStart(url);
            return image;
        };
        ImageLoader.prototype.setCrossOrigin = function (value) {
            this.crossOrigin = value;
            return this;
        };
        ImageLoader.prototype.setPath = function (value) {
            this.path = value;
            return this;
        };
        return ImageLoader;
    }());
    THREE.ImageLoader = ImageLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var JSONLoader = (function () {
        function JSONLoader(manager) {
            if (typeof manager === 'boolean') {
                console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');
                manager = undefined;
            }
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
            this.withCredentials = false;
        }
        ;
        JSONLoader.prototype.load = function (url, onLoad, onProgress, onError) {
            var scope = this;
            var texturePath = this.texturePath && (typeof this.texturePath === "string")
                ? this.texturePath : THREE.Loader.prototype.extractUrlBase(url);
            var loader = new THREE.XHRLoader(this.manager);
            loader.setWithCredentials(this.withCredentials);
            loader.load(url, function (text) {
                var json = JSON.parse(text);
                var metadata = json.metadata;
                if (metadata !== undefined) {
                    var type = metadata.type;
                    if (type !== undefined) {
                        if (type.toLowerCase() === 'object') {
                            console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.');
                            return;
                        }
                        if (type.toLowerCase() === 'scene') {
                            console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.');
                            return;
                        }
                    }
                }
                var object = scope.parse(json, texturePath);
                onLoad(object.geometry, object.materials);
            }, onProgress, onError);
        };
        JSONLoader.prototype.setTexturePath = function (value) {
            this.texturePath = value;
        };
        JSONLoader.prototype.parse = function (json, texturePath) {
            var geometry = new THREE.Geometry(), scale = (json.scale !== undefined) ? 1.0 / json.scale : 1.0;
            parseModel(scale);
            parseSkin();
            parseMorphing(scale);
            parseAnimations();
            geometry.computeFaceNormals();
            geometry.computeBoundingSphere();
            function parseModel(scale) {
                function isBitSet(value, position) {
                    return value & (1 << position);
                }
                var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, hex, normal, uvLayer, uv, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, nUvLayers = 0;
                if (json.uvs !== undefined) {
                    for (i = 0; i < json.uvs.length; i++) {
                        if (json.uvs[i].length)
                            nUvLayers++;
                    }
                    for (i = 0; i < nUvLayers; i++) {
                        geometry.faceVertexUvs[i] = [];
                    }
                }
                offset = 0;
                zLength = vertices.length;
                while (offset < zLength) {
                    vertex = new THREE.Vector3();
                    vertex.x = vertices[offset++] * scale;
                    vertex.y = vertices[offset++] * scale;
                    vertex.z = vertices[offset++] * scale;
                    geometry.vertices.push(vertex);
                }
                offset = 0;
                zLength = faces.length;
                while (offset < zLength) {
                    type = faces[offset++];
                    isQuad = isBitSet(type, 0);
                    hasMaterial = isBitSet(type, 1);
                    hasFaceVertexUv = isBitSet(type, 3);
                    hasFaceNormal = isBitSet(type, 4);
                    hasFaceVertexNormal = isBitSet(type, 5);
                    hasFaceColor = isBitSet(type, 6);
                    hasFaceVertexColor = isBitSet(type, 7);
                    if (isQuad) {
                        faceA = new THREE.Face3();
                        faceA.a = faces[offset];
                        faceA.b = faces[offset + 1];
                        faceA.c = faces[offset + 3];
                        faceB = new THREE.Face3();
                        faceB.a = faces[offset + 1];
                        faceB.b = faces[offset + 2];
                        faceB.c = faces[offset + 3];
                        offset += 4;
                        if (hasMaterial) {
                            materialIndex = faces[offset++];
                            faceA.materialIndex = materialIndex;
                            faceB.materialIndex = materialIndex;
                        }
                        fi = geometry.faces.length;
                        if (hasFaceVertexUv) {
                            for (i = 0; i < nUvLayers; i++) {
                                uvLayer = json.uvs[i];
                                geometry.faceVertexUvs[i][fi] = [];
                                geometry.faceVertexUvs[i][fi + 1] = [];
                                for (j = 0; j < 4; j++) {
                                    uvIndex = faces[offset++];
                                    u = uvLayer[uvIndex * 2];
                                    v = uvLayer[uvIndex * 2 + 1];
                                    uv = new THREE.Vector2(u, v);
                                    if (j !== 2)
                                        geometry.faceVertexUvs[i][fi].push(uv);
                                    if (j !== 0)
                                        geometry.faceVertexUvs[i][fi + 1].push(uv);
                                }
                            }
                        }
                        if (hasFaceNormal) {
                            normalIndex = faces[offset++] * 3;
                            faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                            faceB.normal.copy(faceA.normal);
                        }
                        if (hasFaceVertexNormal) {
                            for (i = 0; i < 4; i++) {
                                normalIndex = faces[offset++] * 3;
                                normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                                if (i !== 2)
                                    faceA.vertexNormals.push(normal);
                                if (i !== 0)
                                    faceB.vertexNormals.push(normal);
                            }
                        }
                        if (hasFaceColor) {
                            colorIndex = faces[offset++];
                            hex = colors[colorIndex];
                            faceA.color.setHex(hex);
                            faceB.color.setHex(hex);
                        }
                        if (hasFaceVertexColor) {
                            for (i = 0; i < 4; i++) {
                                colorIndex = faces[offset++];
                                hex = colors[colorIndex];
                                if (i !== 2)
                                    faceA.vertexColors.push(new THREE.Color(hex));
                                if (i !== 0)
                                    faceB.vertexColors.push(new THREE.Color(hex));
                            }
                        }
                        geometry.faces.push(faceA);
                        geometry.faces.push(faceB);
                    }
                    else {
                        face = new THREE.Face3();
                        face.a = faces[offset++];
                        face.b = faces[offset++];
                        face.c = faces[offset++];
                        if (hasMaterial) {
                            materialIndex = faces[offset++];
                            face.materialIndex = materialIndex;
                        }
                        fi = geometry.faces.length;
                        if (hasFaceVertexUv) {
                            for (i = 0; i < nUvLayers; i++) {
                                uvLayer = json.uvs[i];
                                geometry.faceVertexUvs[i][fi] = [];
                                for (j = 0; j < 3; j++) {
                                    uvIndex = faces[offset++];
                                    u = uvLayer[uvIndex * 2];
                                    v = uvLayer[uvIndex * 2 + 1];
                                    uv = new THREE.Vector2(u, v);
                                    geometry.faceVertexUvs[i][fi].push(uv);
                                }
                            }
                        }
                        if (hasFaceNormal) {
                            normalIndex = faces[offset++] * 3;
                            face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                        }
                        if (hasFaceVertexNormal) {
                            for (i = 0; i < 3; i++) {
                                normalIndex = faces[offset++] * 3;
                                normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                                face.vertexNormals.push(normal);
                            }
                        }
                        if (hasFaceColor) {
                            colorIndex = faces[offset++];
                            face.color.setHex(colors[colorIndex]);
                        }
                        if (hasFaceVertexColor) {
                            for (i = 0; i < 3; i++) {
                                colorIndex = faces[offset++];
                                face.vertexColors.push(new THREE.Color(colors[colorIndex]));
                            }
                        }
                        geometry.faces.push(face);
                    }
                }
            }
            function parseSkin() {
                var influencesPerVertex = (json.influencesPerVertex !== undefined) ? json.influencesPerVertex : 2;
                if (json.skinWeights) {
                    for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {
                        var x = json.skinWeights[i];
                        var y = (influencesPerVertex > 1) ? json.skinWeights[i + 1] : 0;
                        var z = (influencesPerVertex > 2) ? json.skinWeights[i + 2] : 0;
                        var w = (influencesPerVertex > 3) ? json.skinWeights[i + 3] : 0;
                        geometry.skinWeights.push(new THREE.Vector4(x, y, z, w));
                    }
                }
                if (json.skinIndices) {
                    for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {
                        var a = json.skinIndices[i];
                        var b = (influencesPerVertex > 1) ? json.skinIndices[i + 1] : 0;
                        var c = (influencesPerVertex > 2) ? json.skinIndices[i + 2] : 0;
                        var d = (influencesPerVertex > 3) ? json.skinIndices[i + 3] : 0;
                        geometry.skinIndices.push(new THREE.Vector4(a, b, c, d));
                    }
                }
                geometry.bones = json.bones;
                if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
                    console.warn('When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
                        geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');
                }
            }
            function parseMorphing(scale) {
                if (json.morphTargets !== undefined) {
                    for (var i = 0, l = json.morphTargets.length; i < l; i++) {
                        geometry.morphTargets[i] = {};
                        geometry.morphTargets[i].name = json.morphTargets[i].name;
                        geometry.morphTargets[i].vertices = [];
                        var dstVertices = geometry.morphTargets[i].vertices;
                        var srcVertices = json.morphTargets[i].vertices;
                        for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {
                            var vertex = new THREE.Vector3();
                            vertex.x = srcVertices[v] * scale;
                            vertex.y = srcVertices[v + 1] * scale;
                            vertex.z = srcVertices[v + 2] * scale;
                            dstVertices.push(vertex);
                        }
                    }
                }
                if (json.morphColors !== undefined && json.morphColors.length > 0) {
                    console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                    var faces = geometry.faces;
                    var morphColors = json.morphColors[0].colors;
                    for (var i_4 = 0, l_2 = faces.length; i_4 < l_2; i_4++) {
                        faces[i_4].color.fromArray(morphColors, i_4 * 3);
                    }
                }
            }
            function parseAnimations() {
                var outputAnimations = [];
                var animations = [];
                if (json.animation !== undefined) {
                    animations.push(json.animation);
                }
                if (json.animations !== undefined) {
                    if (json.animations.length) {
                        animations = animations.concat(json.animations);
                    }
                    else {
                        animations.push(json.animations);
                    }
                }
                for (var i = 0; i < animations.length; i++) {
                    var clip = THREE.AnimationClip.parseAnimation(animations[i], geometry.bones);
                    if (clip)
                        outputAnimations.push(clip);
                }
                if (geometry.morphTargets) {
                    var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
                    outputAnimations = outputAnimations.concat(morphAnimationClips);
                }
                if (outputAnimations.length > 0)
                    geometry.animations = outputAnimations;
            }
            if (json.materials === undefined || json.materials.length === 0) {
                return { geometry: geometry };
            }
            else {
                var materials = THREE.Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);
                return { geometry: geometry, materials: materials };
            }
        };
        return JSONLoader;
    }());
    THREE.JSONLoader = JSONLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Loader = (function () {
        function Loader() {
            this.crossOrigin = undefined;
        }
        ;
        Loader.prototype.onLoadStart = function () { };
        ;
        Loader.prototype.onLoadProgress = function () { };
        ;
        Loader.prototype.onLoadComplete = function () { };
        ;
        Loader.prototype.extractUrlBase = function (url) {
            var parts = url.split('/');
            if (parts.length === 1)
                return './';
            parts.pop();
            return parts.join('/') + '/';
        };
        Loader.prototype.initMaterials = function (materials, texturePath, crossOrigin) {
            var array = [];
            for (var i = 0; i < materials.length; ++i) {
                array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
            }
            return array;
        };
        Loader.prototype.createMaterial = function (m, texturePath, crossOrigin) {
            if (Loader.color === undefined)
                Loader.color = new THREE.Color();
            if (Loader.textureLoader === undefined)
                Loader.textureLoader = new THREE.TextureLoader();
            if (Loader.materialLoader === undefined)
                Loader.materialLoader = new THREE.MaterialLoader();
            var color = Loader.color;
            var textureLoader = Loader.textureLoader;
            var materialLoader = Loader.materialLoader;
            var textures = {};
            function loadTexture(path, repeat, offset, wrap, anisotropy) {
                var fullPath = texturePath + path;
                var loader = Loader.Handlers.get(fullPath);
                var texture;
                if (loader !== null) {
                    texture = loader.load(fullPath);
                }
                else {
                    textureLoader.setCrossOrigin(crossOrigin);
                    texture = textureLoader.load(fullPath);
                }
                if (repeat !== undefined) {
                    texture.repeat.fromArray(repeat);
                    if (repeat[0] !== 1)
                        texture.wrapS = THREE.RepeatWrapping;
                    if (repeat[1] !== 1)
                        texture.wrapT = THREE.RepeatWrapping;
                }
                if (offset !== undefined) {
                    texture.offset.fromArray(offset);
                }
                if (wrap !== undefined) {
                    if (wrap[0] === 'repeat')
                        texture.wrapS = THREE.RepeatWrapping;
                    if (wrap[0] === 'mirror')
                        texture.wrapS = THREE.MirroredRepeatWrapping;
                    if (wrap[1] === 'repeat')
                        texture.wrapT = THREE.RepeatWrapping;
                    if (wrap[1] === 'mirror')
                        texture.wrapT = THREE.MirroredRepeatWrapping;
                }
                if (anisotropy !== undefined) {
                    texture.anisotropy = anisotropy;
                }
                var uuid = THREE.Math.generateUUID();
                textures[uuid] = texture;
                return uuid;
            }
            var json = {
                uuid: THREE.Math.generateUUID(),
                type: 'MeshLambertMaterial'
            };
            for (var name in m) {
                var value = m[name];
                switch (name) {
                    case 'DbgColor':
                    case 'DbgIndex':
                    case 'opticalDensity':
                    case 'illumination':
                        break;
                    case 'DbgName':
                        json.name = value;
                        break;
                    case 'blending':
                        json.blending = THREE[value];
                        break;
                    case 'colorAmbient':
                    case 'mapAmbient':
                        console.warn('THREE.Loader.createMaterial:', name, 'is no longer supported.');
                        break;
                    case 'colorDiffuse':
                        json.color = color.fromArray(value).getHex();
                        break;
                    case 'colorSpecular':
                        json.specular = color.fromArray(value).getHex();
                        break;
                    case 'colorEmissive':
                        json.emissive = color.fromArray(value).getHex();
                        break;
                    case 'specularCoef':
                        json.shininess = value;
                        break;
                    case 'shading':
                        if (value.toLowerCase() === 'basic')
                            json.type = 'MeshBasicMaterial';
                        if (value.toLowerCase() === 'phong')
                            json.type = 'MeshPhongMaterial';
                        if (value.toLowerCase() === 'standard')
                            json.type = 'MeshStandardMaterial';
                        break;
                    case 'mapDiffuse':
                        json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
                        break;
                    case 'mapDiffuseRepeat':
                    case 'mapDiffuseOffset':
                    case 'mapDiffuseWrap':
                    case 'mapDiffuseAnisotropy':
                        break;
                    case 'mapEmissive':
                        json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
                        break;
                    case 'mapEmissiveRepeat':
                    case 'mapEmissiveOffset':
                    case 'mapEmissiveWrap':
                    case 'mapEmissiveAnisotropy':
                        break;
                    case 'mapLight':
                        json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
                        break;
                    case 'mapLightRepeat':
                    case 'mapLightOffset':
                    case 'mapLightWrap':
                    case 'mapLightAnisotropy':
                        break;
                    case 'mapAO':
                        json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
                        break;
                    case 'mapAORepeat':
                    case 'mapAOOffset':
                    case 'mapAOWrap':
                    case 'mapAOAnisotropy':
                        break;
                    case 'mapBump':
                        json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
                        break;
                    case 'mapBumpScale':
                        json.bumpScale = value;
                        break;
                    case 'mapBumpRepeat':
                    case 'mapBumpOffset':
                    case 'mapBumpWrap':
                    case 'mapBumpAnisotropy':
                        break;
                    case 'mapNormal':
                        json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
                        break;
                    case 'mapNormalFactor':
                        json.normalScale = [value, value];
                        break;
                    case 'mapNormalRepeat':
                    case 'mapNormalOffset':
                    case 'mapNormalWrap':
                    case 'mapNormalAnisotropy':
                        break;
                    case 'mapSpecular':
                        json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
                        break;
                    case 'mapSpecularRepeat':
                    case 'mapSpecularOffset':
                    case 'mapSpecularWrap':
                    case 'mapSpecularAnisotropy':
                        break;
                    case 'mapMetalness':
                        json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
                        break;
                    case 'mapMetalnessRepeat':
                    case 'mapMetalnessOffset':
                    case 'mapMetalnessWrap':
                    case 'mapMetalnessAnisotropy':
                        break;
                    case 'mapRoughness':
                        json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
                        break;
                    case 'mapRoughnessRepeat':
                    case 'mapRoughnessOffset':
                    case 'mapRoughnessWrap':
                    case 'mapRoughnessAnisotropy':
                        break;
                    case 'mapAlpha':
                        json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
                        break;
                    case 'mapAlphaRepeat':
                    case 'mapAlphaOffset':
                    case 'mapAlphaWrap':
                    case 'mapAlphaAnisotropy':
                        break;
                    case 'flipSided':
                        json.side = THREE.BackSide;
                        break;
                    case 'doubleSided':
                        json.side = THREE.DoubleSide;
                        break;
                    case 'transparency':
                        console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');
                        json.opacity = value;
                        break;
                    case 'depthTest':
                    case 'depthWrite':
                    case 'colorWrite':
                    case 'opacity':
                    case 'reflectivity':
                    case 'transparent':
                    case 'visible':
                    case 'wireframe':
                        json[name] = value;
                        break;
                    case 'vertexColors':
                        if (value === true)
                            json.vertexColors = THREE.VertexColors;
                        if (value === 'face')
                            json.vertexColors = THREE.FaceColors;
                        break;
                    default:
                        console.error('THREE.Loader.createMaterial: Unsupported', name, value);
                        break;
                }
            }
            if (json.type === 'MeshBasicMaterial')
                delete json.emissive;
            if (json.type !== 'MeshPhongMaterial')
                delete json.specular;
            if (json.opacity < 1)
                json.transparent = true;
            materialLoader.setTextures(textures);
            return materialLoader.parse(json);
        };
        Loader.Handlers = {
            handlers: [],
            add: function (regex, loader) {
                this.handlers.push(regex, loader);
            },
            get: function (file) {
                var handlers = this.handlers;
                for (var i = 0, l = handlers.length; i < l; i += 2) {
                    var regex = handlers[i];
                    var loader = handlers[i + 1];
                    if (regex.test(file)) {
                        return loader;
                    }
                }
                return null;
            }
        };
        return Loader;
    }());
    THREE.Loader = Loader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var LoadingManager = (function () {
        function LoadingManager(onLoad, onProgress, onError) {
            this.isLoading = false;
            this.itemsLoaded = 0;
            this.itemsTotal = 0;
            var scope = this;
            this.onStart = undefined;
            this.onLoad = onLoad;
            this.onProgress = onProgress;
            this.onError = onError;
        }
        LoadingManager.prototype.itemStart = function (url) {
            this.itemsTotal++;
            if (this.isLoading === false) {
                if (this.onStart !== undefined) {
                    this.onStart(url, this.itemsLoaded, this.itemsTotal);
                }
            }
            this.isLoading = true;
        };
        LoadingManager.prototype.itemEnd = function (url) {
            this.itemsLoaded++;
            if (this.onProgress !== undefined) {
                this.onProgress(url, this.itemsLoaded, this.itemsTotal);
            }
            if (this.itemsLoaded === this.itemsTotal) {
                this.isLoading = false;
                if (this.onLoad !== undefined) {
                    this.onLoad();
                }
            }
        };
        LoadingManager.prototype.itemError = function (url) {
            if (this.onError !== undefined) {
                this.onError(url);
            }
        };
        ;
        return LoadingManager;
    }());
    THREE.LoadingManager = LoadingManager;
    THREE.DefaultLoadingManager = new LoadingManager();
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var MaterialLoader = (function () {
        function MaterialLoader(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
            this.textures = {};
        }
        ;
        MaterialLoader.prototype.load = function (url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new THREE.XHRLoader(scope.manager);
            loader.load(url, function (text) {
                onLoad(scope.parse(JSON.parse(text)));
            }, onProgress, onError);
        };
        MaterialLoader.prototype.setTextures = function (value) {
            this.textures = value;
        };
        MaterialLoader.prototype.getTexture = function (name) {
            var textures = this.textures;
            if (textures[name] === undefined) {
                console.warn('THREE.MaterialLoader: Undefined texture', name);
            }
            return textures[name];
        };
        MaterialLoader.prototype.parse = function (json) {
            var material = new THREE[json.type];
            if (json.uuid !== undefined)
                material.uuid = json.uuid;
            if (json.name !== undefined)
                material.name = json.name;
            if (json.color !== undefined)
                material.color.setHex(json.color);
            if (json.roughness !== undefined)
                material.roughness = json.roughness;
            if (json.metalness !== undefined)
                material.metalness = json.metalness;
            if (json.emissive !== undefined)
                material.emissive.setHex(json.emissive);
            if (json.specular !== undefined)
                material.specular.setHex(json.specular);
            if (json.shininess !== undefined)
                material.shininess = json.shininess;
            if (json.uniforms !== undefined)
                material.uniforms = json.uniforms;
            if (json.vertexShader !== undefined)
                material.vertexShader = json.vertexShader;
            if (json.fragmentShader !== undefined)
                material.fragmentShader = json.fragmentShader;
            if (json.vertexColors !== undefined)
                material.vertexColors = json.vertexColors;
            if (json.shading !== undefined)
                material.shading = json.shading;
            if (json.blending !== undefined)
                material.blending = json.blending;
            if (json.side !== undefined)
                material.side = json.side;
            if (json.opacity !== undefined)
                material.opacity = json.opacity;
            if (json.transparent !== undefined)
                material.transparent = json.transparent;
            if (json.alphaTest !== undefined)
                material.alphaTest = json.alphaTest;
            if (json.depthTest !== undefined)
                material.depthTest = json.depthTest;
            if (json.depthWrite !== undefined)
                material.depthWrite = json.depthWrite;
            if (json.colorWrite !== undefined)
                material.colorWrite = json.colorWrite;
            if (json.wireframe !== undefined)
                material.wireframe = json.wireframe;
            if (json.wireframeLinewidth !== undefined)
                material.wireframeLinewidth = json.wireframeLinewidth;
            if (json.size !== undefined)
                material.size = json.size;
            if (json.sizeAttenuation !== undefined)
                material.sizeAttenuation = json.sizeAttenuation;
            if (json.map !== undefined)
                material.map = this.getTexture(json.map);
            if (json.alphaMap !== undefined) {
                material.alphaMap = this.getTexture(json.alphaMap);
                material.transparent = true;
            }
            if (json.bumpMap !== undefined)
                material.bumpMap = this.getTexture(json.bumpMap);
            if (json.bumpScale !== undefined)
                material.bumpScale = json.bumpScale;
            if (json.normalMap !== undefined)
                material.normalMap = this.getTexture(json.normalMap);
            if (json.normalScale !== undefined) {
                var normalScale = json.normalScale;
                if (Array.isArray(normalScale) === false) {
                    normalScale = [normalScale, normalScale];
                }
                material.normalScale = new THREE.Vector2().fromArray(normalScale);
            }
            if (json.displacementMap !== undefined)
                material.displacementMap = this.getTexture(json.displacementMap);
            if (json.displacementScale !== undefined)
                material.displacementScale = json.displacementScale;
            if (json.displacementBias !== undefined)
                material.displacementBias = json.displacementBias;
            if (json.roughnessMap !== undefined)
                material.roughnessMap = this.getTexture(json.roughnessMap);
            if (json.metalnessMap !== undefined)
                material.metalnessMap = this.getTexture(json.metalnessMap);
            if (json.emissiveMap !== undefined)
                material.emissiveMap = this.getTexture(json.emissiveMap);
            if (json.emissiveIntensity !== undefined)
                material.emissiveIntensity = json.emissiveIntensity;
            if (json.specularMap !== undefined)
                material.specularMap = this.getTexture(json.specularMap);
            if (json.envMap !== undefined) {
                material.envMap = this.getTexture(json.envMap);
                material.combine = THREE.MultiplyOperation;
            }
            if (json.reflectivity !== undefined)
                material.reflectivity = json.reflectivity;
            if (json.lightMap !== undefined)
                material.lightMap = this.getTexture(json.lightMap);
            if (json.lightMapIntensity !== undefined)
                material.lightMapIntensity = json.lightMapIntensity;
            if (json.aoMap !== undefined)
                material.aoMap = this.getTexture(json.aoMap);
            if (json.aoMapIntensity !== undefined)
                material.aoMapIntensity = json.aoMapIntensity;
            if (json.materials !== undefined) {
                for (var i = 0, l = json.materials.length; i < l; i++) {
                    material.materials.push(this.parse(json.materials[i]));
                }
            }
            return material;
        };
        return MaterialLoader;
    }());
    THREE.MaterialLoader = MaterialLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var ObjectLoader = (function () {
        function ObjectLoader(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
            this.texturePath = '';
        }
        ;
        ObjectLoader.prototype.load = function (url, onLoad, onProgress, onError) {
            if (this.texturePath === '') {
                this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);
            }
            var scope = this;
            var loader = new THREE.XHRLoader(scope.manager);
            loader.load(url, function (text) {
                scope.parse(JSON.parse(text), onLoad);
            }, onProgress, onError);
        };
        ObjectLoader.prototype.setTexturePath = function (value) {
            this.texturePath = value;
        };
        ObjectLoader.prototype.setCrossOrigin = function (value) {
            this.crossOrigin = value;
        };
        ObjectLoader.prototype.parse = function (json, onLoad) {
            var geometries = this.parseGeometries(json.geometries);
            var images = this.parseImages(json.images, function () {
                if (onLoad !== undefined)
                    onLoad(object);
            });
            var textures = this.parseTextures(json.textures, images);
            var materials = this.parseMaterials(json.materials, textures);
            var object = this.parseObject(json.object, geometries, materials);
            if (json.animations) {
                object.animations = this.parseAnimations(json.animations);
            }
            if (json.images === undefined || json.images.length === 0) {
                if (onLoad !== undefined)
                    onLoad(object);
            }
            return object;
        };
        ObjectLoader.prototype.parseGeometries = function (json) {
            var geometries = {};
            if (json !== undefined) {
                var geometryLoader = new THREE.JSONLoader();
                var bufferGeometryLoader = new THREE.BufferGeometryLoader();
                for (var i = 0, l = json.length; i < l; i++) {
                    var geometry;
                    var data = json[i];
                    switch (data.type) {
                        case 'PlaneGeometry':
                        case 'PlaneBufferGeometry':
                            geometry = new THREE[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                            break;
                        case 'BoxGeometry':
                        case 'BoxBufferGeometry':
                        case 'CubeGeometry':
                            geometry = new THREE[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                            break;
                        case 'CircleGeometry':
                        case 'CircleBufferGeometry':
                            geometry = new THREE[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                            break;
                        case 'CylinderGeometry':
                        case 'CylinderBufferGeometry':
                            geometry = new THREE[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                            break;
                        case 'ConeGeometry':
                        case 'ConeBufferGeometry':
                            geometry = new THREE[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                            break;
                        case 'SphereGeometry':
                        case 'SphereBufferGeometry':
                            geometry = new THREE[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                            break;
                        case 'DodecahedronGeometry':
                        case 'IcosahedronGeometry':
                        case 'OctahedronGeometry':
                        case 'TetrahedronGeometry':
                            geometry = new THREE[data.type](data.radius, data.detail);
                            break;
                        case 'RingGeometry':
                        case 'RingBufferGeometry':
                            geometry = new THREE[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                            break;
                        case 'TorusGeometry':
                        case 'TorusBufferGeometry':
                            geometry = new THREE[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                            break;
                        case 'TorusKnotGeometry':
                        case 'TorusKnotBufferGeometry':
                            geometry = new THREE[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                            break;
                        case 'LatheGeometry':
                        case 'LatheBufferGeometry':
                            geometry = new THREE[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                            break;
                        case 'BufferGeometry':
                            geometry = bufferGeometryLoader.parse(data);
                            break;
                        case 'Geometry':
                            geometry = geometryLoader.parse(data.data, this.texturePath).geometry;
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                            continue;
                    }
                    geometry.uuid = data.uuid;
                    if (data.name !== undefined)
                        geometry.name = data.name;
                    geometries[data.uuid] = geometry;
                }
            }
            return geometries;
        };
        ObjectLoader.prototype.parseMaterials = function (json, textures) {
            var materials = {};
            if (json !== undefined) {
                var loader = new THREE.MaterialLoader();
                loader.setTextures(textures);
                for (var i = 0, l = json.length; i < l; i++) {
                    var material = loader.parse(json[i]);
                    materials[material.uuid] = material;
                }
            }
            return materials;
        };
        ObjectLoader.prototype.parseAnimations = function (json) {
            var animations = [];
            for (var i = 0; i < json.length; i++) {
                var clip = THREE.AnimationClip.parse(json[i]);
                animations.push(clip);
            }
            return animations;
        };
        ObjectLoader.prototype.parseImages = function (json, onLoad) {
            var scope = this;
            var images = {};
            function loadImage(url) {
                scope.manager.itemStart(url);
                return loader.load(url, function () {
                    scope.manager.itemEnd(url);
                });
            }
            if (json !== undefined && json.length > 0) {
                var manager = new THREE.LoadingManager(onLoad);
                var loader = new THREE.ImageLoader(manager);
                loader.setCrossOrigin(this.crossOrigin);
                for (var i = 0, l = json.length; i < l; i++) {
                    var image = json[i];
                    var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
                    images[image.uuid] = loadImage(path);
                }
            }
            return images;
        };
        ObjectLoader.prototype.parseTextures = function (json, images) {
            function parseConstant(value) {
                if (typeof (value) === 'number')
                    return value;
                console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
                return THREE[value];
            }
            var textures = {};
            if (json !== undefined) {
                for (var i = 0, l = json.length; i < l; i++) {
                    var data = json[i];
                    if (data.image === undefined) {
                        console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
                    }
                    if (images[data.image] === undefined) {
                        console.warn('THREE.ObjectLoader: Undefined image', data.image);
                    }
                    var texture = new THREE.Texture(images[data.image]);
                    texture.needsUpdate = true;
                    texture.uuid = data.uuid;
                    if (data.name !== undefined)
                        texture.name = data.name;
                    if (data.mapping !== undefined)
                        texture.mapping = parseConstant(data.mapping);
                    if (data.offset !== undefined)
                        texture.offset.fromArray(data.offset);
                    if (data.repeat !== undefined)
                        texture.repeat.fromArray(data.repeat);
                    if (data.wrap !== undefined) {
                        texture.wrapS = parseConstant(data.wrap[0]);
                        texture.wrapT = parseConstant(data.wrap[1]);
                    }
                    if (data.minFilter !== undefined)
                        texture.minFilter = parseConstant(data.minFilter);
                    if (data.magFilter !== undefined)
                        texture.magFilter = parseConstant(data.magFilter);
                    if (data.anisotropy !== undefined)
                        texture.anisotropy = data.anisotropy;
                    if (data.flipY !== undefined)
                        texture.flipY = data.flipY;
                    textures[data.uuid] = texture;
                }
            }
            return textures;
        };
        ObjectLoader.prototype.parseObject = function (data, geometries, materials) {
            var matrix = ObjectLoader[".parseObject.matrix"] || (ObjectLoader[".parseObject.matrix"] = new THREE.Matrix4());
            var object;
            function getGeometry(name) {
                if (geometries[name] === undefined) {
                    console.warn('THREE.ObjectLoader: Undefined geometry', name);
                }
                return geometries[name];
            }
            function getMaterial(name) {
                if (name === undefined)
                    return undefined;
                if (materials[name] === undefined) {
                    console.warn('THREE.ObjectLoader: Undefined material', name);
                }
                return materials[name];
            }
            switch (data.type) {
                case 'Scene':
                    object = new THREE.Scene();
                    break;
                case 'PerspectiveCamera':
                    object = new THREE.PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                    if (data.focus !== undefined)
                        object.focus = data.focus;
                    if (data.zoom !== undefined)
                        object.zoom = data.zoom;
                    if (data.filmGauge !== undefined)
                        object.filmGauge = data.filmGauge;
                    if (data.filmOffset !== undefined)
                        object.filmOffset = data.filmOffset;
                    if (data.view !== undefined)
                        object.view = Object.assign({}, data.view);
                    break;
                case 'OrthographicCamera':
                    object = new THREE.OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                    break;
                case 'AmbientLight':
                    object = new THREE.AmbientLight(data.color, data.intensity);
                    break;
                case 'DirectionalLight':
                    object = new THREE.DirectionalLight(data.color, data.intensity);
                    break;
                case 'PointLight':
                    object = new THREE.PointLight(data.color, data.intensity, data.distance, data.decay);
                    break;
                case 'SpotLight':
                    object = new THREE.SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                    break;
                case 'HemisphereLight':
                    object = new THREE.HemisphereLight(data.color, data.groundColor, data.intensity);
                    break;
                case 'Mesh':
                    var geometry = getGeometry(data.geometry);
                    var material = getMaterial(data.material);
                    if (geometry.bones && geometry.bones.length > 0) {
                        object = new THREE.SkinnedMesh(geometry, material);
                    }
                    else {
                        object = new THREE.Mesh(geometry, material);
                    }
                    break;
                case 'LOD':
                    object = new THREE.LOD();
                    break;
                case 'Line':
                    object = new THREE.Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
                    break;
                case 'PointCloud':
                case 'Points':
                    object = new THREE.Points(getGeometry(data.geometry), getMaterial(data.material));
                    break;
                case 'Sprite':
                    object = new THREE.Sprite(getMaterial(data.material));
                    break;
                case 'Group':
                    object = new THREE.Group();
                    break;
                default:
                    object = new THREE.Object3D();
            }
            object.uuid = data.uuid;
            if (data.name !== undefined)
                object.name = data.name;
            if (data.matrix !== undefined) {
                matrix.fromArray(data.matrix);
                matrix.decompose(object.position, object.quaternion, object.scale);
            }
            else {
                if (data.position !== undefined)
                    object.position.fromArray(data.position);
                if (data.rotation !== undefined)
                    object.rotation.fromArray(data.rotation);
                if (data.scale !== undefined)
                    object.scale.fromArray(data.scale);
            }
            if (data.castShadow !== undefined)
                object.castShadow = data.castShadow;
            if (data.receiveShadow !== undefined)
                object.receiveShadow = data.receiveShadow;
            if (data.visible !== undefined)
                object.visible = data.visible;
            if (data.userData !== undefined)
                object.userData = data.userData;
            if (data.children !== undefined) {
                for (var child in data.children) {
                    object.add(this.parseObject(data.children[child], geometries, materials));
                }
            }
            if (data.type === 'LOD') {
                var levels = data.levels;
                for (var l = 0; l < levels.length; l++) {
                    var level = levels[l];
                    var child_1 = object.getObjectByProperty('uuid', level.object);
                    if (child_1 !== undefined) {
                        object.addLevel(child_1, level.distance);
                    }
                }
            }
            return object;
        };
        return ObjectLoader;
    }());
    THREE.ObjectLoader = ObjectLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var TextureLoader = (function () {
        function TextureLoader(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        }
        ;
        TextureLoader.prototype.load = function (url, onLoad, onProgress, onError) {
            var texture = new THREE.Texture();
            var loader = new THREE.ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            loader.setPath(this.path);
            loader.load(url, function (image) {
                var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;
                texture.format = isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;
                texture.image = image;
                texture.needsUpdate = true;
                if (onLoad !== undefined) {
                    onLoad(texture);
                }
            }, onProgress, onError);
            return texture;
        };
        TextureLoader.prototype.setCrossOrigin = function (value) {
            this.crossOrigin = value;
            return this;
        };
        TextureLoader.prototype.setPath = function (value) {
            this.path = value;
            return this;
        };
        return TextureLoader;
    }());
    THREE.TextureLoader = TextureLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var XHRLoader = (function () {
        function XHRLoader(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        }
        ;
        XHRLoader.prototype.load = function (url, onLoad, onProgress, onError) {
            if (this.path !== undefined)
                url = this.path + url;
            var scope = this;
            var cached = THREE.Cache.get(url);
            if (cached !== undefined) {
                scope.manager.itemStart(url);
                setTimeout(function () {
                    if (onLoad)
                        onLoad(cached);
                    scope.manager.itemEnd(url);
                }, 0);
                return cached;
            }
            var request = new XMLHttpRequest();
            request.overrideMimeType('text/plain');
            request.open('GET', url, true);
            request.addEventListener('load', function (event) {
                var response = event.target.response;
                THREE.Cache.add(url, response);
                if (this.status === 200) {
                    if (onLoad)
                        onLoad(response);
                    scope.manager.itemEnd(url);
                }
                else if (this.status === 0) {
                    console.warn('THREE.XHRLoader: HTTP Status 0 received.');
                    if (onLoad)
                        onLoad(response);
                    scope.manager.itemEnd(url);
                }
                else {
                    if (onError)
                        onError(event);
                    scope.manager.itemError(url);
                }
            }, false);
            if (onProgress !== undefined) {
                request.addEventListener('progress', function (event) {
                    onProgress(event);
                }, false);
            }
            request.addEventListener('error', function (event) {
                if (onError)
                    onError(event);
                scope.manager.itemError(url);
            }, false);
            if (this.responseType !== undefined)
                request.responseType = this.responseType;
            if (this.withCredentials !== undefined)
                request.withCredentials = this.withCredentials;
            request.send(null);
            scope.manager.itemStart(url);
            return request;
        };
        XHRLoader.prototype.setPath = function (value) {
            this.path = value;
            return this;
        };
        XHRLoader.prototype.setResponseType = function (value) {
            this.responseType = value;
            return this;
        };
        XHRLoader.prototype.setWithCredentials = function (value) {
            this.withCredentials = value;
            return this;
        };
        return XHRLoader;
    }());
    THREE.XHRLoader = XHRLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Material = (function (_super) {
        __extends(Material, _super);
        function Material() {
            _super.call(this);
            this._id = THREE.MaterialIdCount++;
            this.uuid = THREE.Math.generateUUID();
            this.name = '';
            this.type = 'Material';
            this.fog = true;
            this.lights = true;
            this.blending = THREE.NormalBlending;
            this.side = THREE.FrontSide;
            this.shading = THREE.SmoothShading;
            this.vertexColors = THREE.NoColors;
            this.opacity = 1;
            this.transparent = false;
            this.blendSrc = THREE.SrcAlphaFactor;
            this.blendDst = THREE.OneMinusSrcAlphaFactor;
            this.blendEquation = THREE.AddEquation;
            this.blendSrcAlpha = null;
            this.blendDstAlpha = null;
            this.blendEquationAlpha = null;
            this.depthFunc = THREE.LessEqualDepth;
            this.depthTest = true;
            this.depthWrite = true;
            this.clippingPlanes = null;
            this.clipShadows = false;
            this.colorWrite = true;
            this.precision = null;
            this.polygonOffset = false;
            this.polygonOffsetFactor = 0;
            this.polygonOffsetUnits = 0;
            this.alphaTest = 0;
            this.premultipliedAlpha = false;
            this.overdraw = 0;
            this.visible = true;
            this._needsUpdate = true;
        }
        Object.defineProperty(Material.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(Material.prototype, "needsUpdate", {
            get: function () {
                return this._needsUpdate;
            },
            set: function (value) {
                if (value === true)
                    this.update();
                this._needsUpdate = value;
            },
            enumerable: true,
            configurable: true
        });
        Material.prototype.setValues = function (values) {
            if (values === undefined)
                return;
            for (var key in values) {
                var newValue = values[key];
                if (newValue === undefined) {
                    console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                    continue;
                }
                var currentValue = this[key];
                if (currentValue === undefined) {
                    console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                    continue;
                }
                if (currentValue instanceof THREE.Color) {
                    currentValue.set(newValue);
                }
                else if (currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3) {
                    currentValue.copy(newValue);
                }
                else if (key === 'overdraw') {
                    this[key] = Number(newValue);
                }
                else {
                    this[key] = newValue;
                }
            }
        };
        Material.prototype.toJSON = function (meta) {
            var isRoot = meta === undefined;
            if (isRoot) {
                meta = {
                    textures: {},
                    images: {}
                };
            }
            var data = {
                metadata: {
                    version: 4.4,
                    type: 'Material',
                    generator: 'Material.toJSON'
                }
            };
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '')
                data.name = this.name;
            if (this.color instanceof THREE.Color)
                data.color = this.color.getHex();
            if (this.roughness !== undefined)
                data.roughness = this.roughness;
            if (this.metalness !== undefined)
                data.metalness = this.metalness;
            if (this.emissive instanceof THREE.Color)
                data.emissive = this.emissive.getHex();
            if (this.specular instanceof THREE.Color)
                data.specular = this.specular.getHex();
            if (this.shininess !== undefined)
                data.shininess = this.shininess;
            if (this.map instanceof THREE.Texture)
                data.map = this.map.toJSON(meta).uuid;
            if (this.alphaMap instanceof THREE.Texture)
                data.alphaMap = this.alphaMap.toJSON(meta).uuid;
            if (this.lightMap instanceof THREE.Texture)
                data.lightMap = this.lightMap.toJSON(meta).uuid;
            if (this.bumpMap instanceof THREE.Texture) {
                data.bumpMap = this.bumpMap.toJSON(meta).uuid;
                data.bumpScale = this.bumpScale;
            }
            if (this.normalMap instanceof THREE.Texture) {
                data.normalMap = this.normalMap.toJSON(meta).uuid;
                data.normalScale = this.normalScale.toArray();
            }
            if (this.displacementMap instanceof THREE.Texture) {
                data.displacementMap = this.displacementMap.toJSON(meta).uuid;
                data.displacementScale = this.displacementScale;
                data.displacementBias = this.displacementBias;
            }
            if (this.roughnessMap instanceof THREE.Texture)
                data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
            if (this.metalnessMap instanceof THREE.Texture)
                data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
            if (this.emissiveMap instanceof THREE.Texture)
                data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
            if (this.specularMap instanceof THREE.Texture)
                data.specularMap = this.specularMap.toJSON(meta).uuid;
            if (this.envMap instanceof THREE.Texture) {
                data.envMap = this.envMap.toJSON(meta).uuid;
                data.reflectivity = this.reflectivity;
            }
            if (this.size !== undefined)
                data.size = this.size;
            if (this.sizeAttenuation !== undefined)
                data.sizeAttenuation = this.sizeAttenuation;
            if (this.blending !== THREE.NormalBlending)
                data.blending = this.blending;
            if (this.shading !== THREE.SmoothShading)
                data.shading = this.shading;
            if (this.side !== THREE.FrontSide)
                data.side = this.side;
            if (this.vertexColors !== THREE.NoColors)
                data.vertexColors = this.vertexColors;
            if (this.opacity < 1)
                data.opacity = this.opacity;
            if (this.transparent === true)
                data.transparent = this.transparent;
            if (this.alphaTest > 0)
                data.alphaTest = this.alphaTest;
            if (this.premultipliedAlpha === true)
                data.premultipliedAlpha = this.premultipliedAlpha;
            if (this.wireframe === true)
                data.wireframe = this.wireframe;
            if (this.wireframeLinewidth > 1)
                data.wireframeLinewidth = this.wireframeLinewidth;
            function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                    var data = cache[key];
                    delete data.metadata;
                    values.push(data);
                }
                return values;
            }
            if (isRoot) {
                var textures = extractFromCache(meta.textures);
                var images = extractFromCache(meta.images);
                if (textures.length > 0)
                    data.textures = textures;
                if (images.length > 0)
                    data.images = images;
            }
            return data;
        };
        Material.prototype.clone = function () {
            return new this.constructor().copy(this);
        };
        Material.prototype.copy = function (source) {
            this.name = source.name;
            this.fog = source.fog;
            this.lights = source.lights;
            this.blending = source.blending;
            this.side = source.side;
            this.shading = source.shading;
            this.vertexColors = source.vertexColors;
            this.opacity = source.opacity;
            this.transparent = source.transparent;
            this.blendSrc = source.blendSrc;
            this.blendDst = source.blendDst;
            this.blendEquation = source.blendEquation;
            this.blendSrcAlpha = source.blendSrcAlpha;
            this.blendDstAlpha = source.blendDstAlpha;
            this.blendEquationAlpha = source.blendEquationAlpha;
            this.depthFunc = source.depthFunc;
            this.depthTest = source.depthTest;
            this.depthWrite = source.depthWrite;
            this.colorWrite = source.colorWrite;
            this.precision = source.precision;
            this.polygonOffset = source.polygonOffset;
            this.polygonOffsetFactor = source.polygonOffsetFactor;
            this.polygonOffsetUnits = source.polygonOffsetUnits;
            this.alphaTest = source.alphaTest;
            this.premultipliedAlpha = source.premultipliedAlpha;
            this.overdraw = source.overdraw;
            this.visible = source.visible;
            this.clipShadows = source.clipShadows;
            var srcPlanes = source.clippingPlanes, dstPlanes = null;
            if (srcPlanes !== null) {
                var n = srcPlanes.length;
                dstPlanes = new Array(n);
                for (var i = 0; i !== n; ++i)
                    dstPlanes[i] = srcPlanes[i].clone();
            }
            this.clippingPlanes = dstPlanes;
            return this;
        };
        Material.prototype.update = function () {
            this.dispatchEvent({ type: 'update' });
        };
        Material.prototype.dispose = function () {
            this.dispatchEvent({ type: 'dispose' });
        };
        return Material;
    }(THREE.EventDispatcher));
    THREE.Material = Material;
    THREE.MaterialIdCount = 0;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var LineBasicMaterial = (function (_super) {
        __extends(LineBasicMaterial, _super);
        function LineBasicMaterial(parameters) {
            _super.call(this);
            this.linewidth = 1;
            this.linecap = 'round';
            this.linejoin = 'round';
            this.type = 'LineBasicMaterial';
            this.color = new THREE.Color(0xffffff);
            this.lights = false;
            this.setValues(parameters);
        }
        ;
        LineBasicMaterial.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.linewidth = source.linewidth;
            this.linecap = source.linecap;
            this.linejoin = source.linejoin;
            return this;
        };
        ;
        return LineBasicMaterial;
    }(THREE.Material));
    THREE.LineBasicMaterial = LineBasicMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var LineDashedMaterial = (function (_super) {
        __extends(LineDashedMaterial, _super);
        function LineDashedMaterial(parameters) {
            _super.call(this);
            this.linewidth = 1;
            this.scale = 1;
            this.dashSize = 3;
            this.gapSize = 1;
            this.type = 'LineDashedMaterial';
            this.color = new THREE.Color(0xffffff);
            this.lights = false;
            this.setValues(parameters);
        }
        ;
        LineDashedMaterial.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.linewidth = source.linewidth;
            this.scale = source.scale;
            this.dashSize = source.dashSize;
            this.gapSize = source.gapSize;
            return this;
        };
        ;
        return LineDashedMaterial;
    }(THREE.Material));
    THREE.LineDashedMaterial = LineDashedMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var MeshBasicMaterial = (function (_super) {
        __extends(MeshBasicMaterial, _super);
        function MeshBasicMaterial(parameters) {
            _super.call(this);
            this.aoMap = null;
            this.aoMapIntensity = 1.0;
            this.combine = THREE.MultiplyOperation;
            this.refractionRatio = 0.98;
            this.wireframeLinecap = 'round';
            this.wireframeLinejoin = 'round';
            this.skinning = false;
            this.morphTargets = false;
            this.type = 'MeshBasicMaterial';
            this.color = new THREE.Color(0xffffff);
            this.map = null;
            this.specularMap = null;
            this.alphaMap = null;
            this.envMap = null;
            this.reflectivity = 1;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.lights = false;
            this.setValues(parameters);
        }
        ;
        MeshBasicMaterial.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.map = source.map;
            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;
            this.specularMap = source.specularMap;
            this.alphaMap = source.alphaMap;
            this.envMap = source.envMap;
            this.combine = source.combine;
            this.reflectivity = source.reflectivity;
            this.refractionRatio = source.refractionRatio;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            return this;
        };
        ;
        return MeshBasicMaterial;
    }(THREE.Material));
    THREE.MeshBasicMaterial = MeshBasicMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var MeshDepthMaterial = (function (_super) {
        __extends(MeshDepthMaterial, _super);
        function MeshDepthMaterial(parameters) {
            _super.call(this);
            this.depthPacking = THREE.BasicDepthPacking;
            this.skinning = false;
            this.morphTargets = false;
            this.type = 'MeshDepthMaterial';
            this.map = null;
            this.alphaMap = null;
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.fog = false;
            this.lights = false;
            this.setValues(parameters);
        }
        ;
        MeshDepthMaterial.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.depthPacking = source.depthPacking;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.map = source.map;
            this.alphaMap = source.alphaMap;
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            return this;
        };
        ;
        return MeshDepthMaterial;
    }(THREE.Material));
    THREE.MeshDepthMaterial = MeshDepthMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var MeshLambertMaterial = (function (_super) {
        __extends(MeshLambertMaterial, _super);
        function MeshLambertMaterial(parameters) {
            _super.call(this);
            this.lightMapIntensity = 1.0;
            this.aoMap = null;
            this.aoMapIntensity = 1.0;
            this.emissiveIntensity = 1.0;
            this.combine = THREE.MultiplyOperation;
            this.refractionRatio = 0.98;
            this.wireframeLinecap = 'round';
            this.wireframeLinejoin = 'round';
            this.skinning = false;
            this.morphTargets = false;
            this.morphNormals = false;
            this.type = 'MeshLambertMaterial';
            this.color = new THREE.Color(0xffffff);
            this.map = null;
            this.lightMap = null;
            this.aoMap = null;
            this.emissive = new THREE.Color(0x000000);
            this.emissiveMap = null;
            this.specularMap = null;
            this.alphaMap = null;
            this.envMap = null;
            this.reflectivity = 1;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.setValues(parameters);
        }
        ;
        MeshLambertMaterial.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.map = source.map;
            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;
            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;
            this.emissive.copy(source.emissive);
            this.emissiveMap = source.emissiveMap;
            this.emissiveIntensity = source.emissiveIntensity;
            this.specularMap = source.specularMap;
            this.alphaMap = source.alphaMap;
            this.envMap = source.envMap;
            this.combine = source.combine;
            this.reflectivity = source.reflectivity;
            this.refractionRatio = source.refractionRatio;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.morphNormals = source.morphNormals;
            return this;
        };
        ;
        return MeshLambertMaterial;
    }(THREE.Material));
    THREE.MeshLambertMaterial = MeshLambertMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var MeshNormalMaterial = (function (_super) {
        __extends(MeshNormalMaterial, _super);
        function MeshNormalMaterial(parameters) {
            _super.call(this);
            this.morphTargets = false;
            this.type = 'MeshNormalMaterial';
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.fog = false;
            this.lights = false;
            this.setValues(parameters);
        }
        MeshNormalMaterial.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            return this;
        };
        return MeshNormalMaterial;
    }(THREE.Material));
    THREE.MeshNormalMaterial = MeshNormalMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var MeshPhongMaterial = (function (_super) {
        __extends(MeshPhongMaterial, _super);
        function MeshPhongMaterial(parameters) {
            _super.call(this);
            this.type = 'MeshPhongMaterial';
            this.color = new THREE.Color(0xffffff);
            this.specular = new THREE.Color(0x111111);
            this.shininess = 30;
            this.map = null;
            this.lightMap = null;
            this.lightMapIntensity = 1.0;
            this.aoMap = null;
            this.aoMapIntensity = 1.0;
            this.emissive = new THREE.Color(0x000000);
            this.emissiveIntensity = 1.0;
            this.emissiveMap = null;
            this.bumpMap = null;
            this.bumpScale = 1;
            this.normalMap = null;
            this.normalScale = new THREE.Vector2(1, 1);
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.specularMap = null;
            this.alphaMap = null;
            this.envMap = null;
            this.combine = THREE.MultiplyOperation;
            this.reflectivity = 1;
            this.refractionRatio = 0.98;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = 'round';
            this.wireframeLinejoin = 'round';
            this.skinning = false;
            this.morphTargets = false;
            this.morphNormals = false;
            this.setValues(parameters);
        }
        ;
        MeshPhongMaterial.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.specular.copy(source.specular);
            this.shininess = source.shininess;
            this.map = source.map;
            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;
            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;
            this.emissive.copy(source.emissive);
            this.emissiveMap = source.emissiveMap;
            this.emissiveIntensity = source.emissiveIntensity;
            this.bumpMap = source.bumpMap;
            this.bumpScale = source.bumpScale;
            this.normalMap = source.normalMap;
            this.normalScale.copy(source.normalScale);
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            this.specularMap = source.specularMap;
            this.alphaMap = source.alphaMap;
            this.envMap = source.envMap;
            this.combine = source.combine;
            this.reflectivity = source.reflectivity;
            this.refractionRatio = source.refractionRatio;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.morphNormals = source.morphNormals;
            return this;
        };
        ;
        return MeshPhongMaterial;
    }(THREE.Material));
    THREE.MeshPhongMaterial = MeshPhongMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var MeshStandardMaterial = (function (_super) {
        __extends(MeshStandardMaterial, _super);
        function MeshStandardMaterial(parameters) {
            _super.call(this);
            this.defines = { 'STANDARD': '' };
            this.type = 'MeshStandardMaterial';
            this.color = new THREE.Color(0xffffff);
            this.roughness = 0.5;
            this.metalness = 0.5;
            this.map = null;
            this.lightMap = null;
            this.lightMapIntensity = 1.0;
            this.aoMap = null;
            this.aoMapIntensity = 1.0;
            this.emissive = new THREE.Color(0x000000);
            this.emissiveIntensity = 1.0;
            this.emissiveMap = null;
            this.bumpMap = null;
            this.bumpScale = 1;
            this.normalMap = null;
            this.normalScale = new THREE.Vector2(1, 1);
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.roughnessMap = null;
            this.metalnessMap = null;
            this.alphaMap = null;
            this.envMap = null;
            this.envMapIntensity = 1.0;
            this.refractionRatio = 0.98;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = 'round';
            this.wireframeLinejoin = 'round';
            this.skinning = false;
            this.morphTargets = false;
            this.morphNormals = false;
            this.setValues(parameters);
        }
        ;
        MeshStandardMaterial.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.defines = { 'STANDARD': '' };
            this.color.copy(source.color);
            this.roughness = source.roughness;
            this.metalness = source.metalness;
            this.map = source.map;
            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;
            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;
            this.emissive.copy(source.emissive);
            this.emissiveMap = source.emissiveMap;
            this.emissiveIntensity = source.emissiveIntensity;
            this.bumpMap = source.bumpMap;
            this.bumpScale = source.bumpScale;
            this.normalMap = source.normalMap;
            this.normalScale.copy(source.normalScale);
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            this.roughnessMap = source.roughnessMap;
            this.metalnessMap = source.metalnessMap;
            this.alphaMap = source.alphaMap;
            this.envMap = source.envMap;
            this.envMapIntensity = source.envMapIntensity;
            this.refractionRatio = source.refractionRatio;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.morphNormals = source.morphNormals;
            return this;
        };
        ;
        return MeshStandardMaterial;
    }(THREE.Material));
    THREE.MeshStandardMaterial = MeshStandardMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var MeshPhysicalMaterial = (function (_super) {
        __extends(MeshPhysicalMaterial, _super);
        function MeshPhysicalMaterial(parameters) {
            _super.call(this);
            this.clearCoat = 0.0;
            this.clearCoatRoughness = 0.0;
            this.defines = { 'PHYSICAL': '' };
            this.type = 'MeshPhysicalMaterial';
            this.reflectivity = 0.5;
            this.clearCoat = 0.0;
            this.clearCoatRoughness = 0.0;
            this.setValues(parameters);
        }
        ;
        MeshPhysicalMaterial.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.defines = { 'PHYSICAL': '' };
            this.reflectivity = source.reflectivity;
            this.clearCoat = source.clearCoat;
            this.clearCoatRoughness = source.clearCoatRoughness;
            return this;
        };
        ;
        return MeshPhysicalMaterial;
    }(THREE.MeshStandardMaterial));
    THREE.MeshPhysicalMaterial = MeshPhysicalMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var MultiMaterial = (function () {
        function MultiMaterial(materials) {
            this.uuid = THREE.Math.generateUUID();
            this.type = 'MultiMaterial';
            this.visible = true;
            this.materials = materials instanceof Array ? materials : [];
        }
        ;
        MultiMaterial.prototype.toJSON = function (meta) {
            var output = {
                metadata: {
                    version: 4.2,
                    type: 'material',
                    generator: 'MaterialExporter'
                },
                uuid: this.uuid,
                type: this.type,
                materials: []
            };
            var materials = this.materials;
            for (var i = 0, l = materials.length; i < l; i++) {
                var material = materials[i].toJSON(meta);
                delete material.metadata;
                output.materials.push(material);
            }
            output.visible = this.visible;
            return output;
        };
        MultiMaterial.prototype.clone = function () {
            var material = new this.constructor();
            for (var i = 0; i < this.materials.length; i++) {
                material.materials.push(this.materials[i].clone());
            }
            material.visible = this.visible;
            return material;
        };
        return MultiMaterial;
    }());
    THREE.MultiMaterial = MultiMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var PointsMaterial = (function (_super) {
        __extends(PointsMaterial, _super);
        function PointsMaterial(parameters) {
            _super.call(this);
            this.type = 'PointsMaterial';
            this.color = new THREE.Color(0xffffff);
            this.map = null;
            this.size = 1;
            this.lights = false;
            this.sizeAttenuation = true;
            this.setValues(parameters);
        }
        ;
        PointsMaterial.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.map = source.map;
            this.size = source.size;
            this.sizeAttenuation = source.sizeAttenuation;
            return this;
        };
        ;
        return PointsMaterial;
    }(THREE.Material));
    THREE.PointsMaterial = PointsMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var ShaderMaterial = (function (_super) {
        __extends(ShaderMaterial, _super);
        function ShaderMaterial(parameters) {
            _super.call(this);
            this.defines = {};
            this.uniforms = {};
            this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
            this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
            this.linewidth = 1;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.fog = false;
            this.lights = false;
            this.clipping = false;
            this.skinning = false;
            this.morphTargets = false;
            this.morphNormals = false;
            this.extensions = {
                derivatives: false,
                fragDepth: false,
                drawBuffers: false,
                shaderTextureLOD: false
            };
            this.defaultAttributeValues = {
                'color': [1, 1, 1],
                'uv': [0, 0],
                'uv2': [0, 0]
            };
            this.index0AttributeName = undefined;
            if (parameters !== undefined) {
                if (parameters["attributes"] !== undefined) {
                    console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
                }
                this.setValues(parameters);
            }
        }
        ;
        ShaderMaterial.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.fragmentShader = source.fragmentShader;
            this.vertexShader = source.vertexShader;
            this.uniforms = THREE.UniformsUtils.clone(source.uniforms);
            this.defines = source.defines;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.lights = source.lights;
            this.clipping = source.clipping;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.morphNormals = source.morphNormals;
            this.extensions = source.extensions;
            return this;
        };
        ;
        ShaderMaterial.prototype.toJSON = function (meta) {
            var data = _super.prototype.toJSON.call(this, meta);
            data.uniforms = this.uniforms;
            data.vertexShader = this.vertexShader;
            data.fragmentShader = this.fragmentShader;
            return data;
        };
        ;
        return ShaderMaterial;
    }(THREE.Material));
    THREE.ShaderMaterial = ShaderMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var RawShaderMaterial = (function (_super) {
        __extends(RawShaderMaterial, _super);
        function RawShaderMaterial(parameters) {
            _super.call(this, parameters);
            this.type = 'RawShaderMaterial';
        }
        ;
        return RawShaderMaterial;
    }(THREE.ShaderMaterial));
    THREE.RawShaderMaterial = RawShaderMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var ShadowMaterial = (function (_super) {
        __extends(ShadowMaterial, _super);
        function ShadowMaterial() {
            _super.call(this, {
                uniforms: THREE.UniformsUtils.merge([
                    THREE.UniformsLib["lights"],
                    {
                        opacity: { value: 1.0 }
                    }
                ]),
                vertexShader: THREE.ShaderChunk['shadow_vert'],
                fragmentShader: THREE.ShaderChunk['shadow_frag']
            });
            this.lights = true;
            this.transparent = true;
        }
        Object.defineProperty(ShadowMaterial.prototype, "opacity", {
            get: function () {
                if (this.uniforms == null || this.uniforms.opacity == null)
                    return 0;
                return this.uniforms.opacity.value;
            },
            set: function (value) {
                if (this.uniforms == null || this.uniforms.opacity == null)
                    return;
                this.uniforms.opacity.value = value;
            },
            enumerable: true,
            configurable: true
        });
        return ShadowMaterial;
    }(THREE.ShaderMaterial));
    THREE.ShadowMaterial = ShadowMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var SpriteMaterial = (function (_super) {
        __extends(SpriteMaterial, _super);
        function SpriteMaterial(parameters) {
            _super.call(this);
            this.rotation = 0;
            this.type = 'SpriteMaterial';
            this.color = new THREE.Color(0xffffff);
            this.map = null;
            this.fog = false;
            this.lights = false;
            this.setValues(parameters);
        }
        ;
        SpriteMaterial.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.map = source.map;
            this.rotation = source.rotation;
            return this;
        };
        ;
        return SpriteMaterial;
    }(THREE.Material));
    THREE.SpriteMaterial = SpriteMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Euler = (function () {
        function Euler(_x, _y, _z, _order) {
            if (_x === void 0) { _x = 0; }
            if (_y === void 0) { _y = 0; }
            if (_z === void 0) { _z = 0; }
            if (_order === void 0) { _order = Euler.DefaultOrder; }
            this._x = _x;
            this._y = _y;
            this._z = _z;
            this._order = _order;
        }
        Object.defineProperty(Euler.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (value) {
                this._x = value;
                this.onChangeCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Euler.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (value) {
                this._y = value;
                this.onChangeCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Euler.prototype, "z", {
            get: function () {
                return this._z;
            },
            set: function (value) {
                this._z = value;
                this.onChangeCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Euler.prototype, "order", {
            get: function () {
                return this._order;
            },
            set: function (value) {
                this._order = value;
                this.onChangeCallback();
            },
            enumerable: true,
            configurable: true
        });
        Euler.prototype.set = function (x, y, z, order) {
            if (order === void 0) { order = this._order; }
            this._x = x;
            this._y = y;
            this._z = z;
            this._order = order;
            this.onChangeCallback();
            return this;
        };
        Euler.prototype.clone = function () {
            return new Euler(this._x, this._y, this._z, this._order);
        };
        Euler.prototype.copy = function (euler) {
            this._x = euler._x;
            this._y = euler._y;
            this._z = euler._z;
            this._order = euler._order;
            this.onChangeCallback();
            return this;
        };
        Euler.prototype.setFromRotationMatrix = function (m, order, update) {
            var clamp = THREE.Math.clamp;
            var te = m.elements;
            var m11 = te[0], m12 = te[4], m13 = te[8];
            var m21 = te[1], m22 = te[5], m23 = te[9];
            var m31 = te[2], m32 = te[6], m33 = te[10];
            order = order || this._order;
            if (order === 'XYZ') {
                this._y = THREE.Math.asin(clamp(m13, -1, 1));
                if (THREE.Math.abs(m13) < 0.99999) {
                    this._x = THREE.Math.atan2(-m23, m33);
                    this._z = THREE.Math.atan2(-m12, m11);
                }
                else {
                    this._x = THREE.Math.atan2(m32, m22);
                    this._z = 0;
                }
            }
            else if (order === 'YXZ') {
                this._x = THREE.Math.asin(-clamp(m23, -1, 1));
                if (THREE.Math.abs(m23) < 0.99999) {
                    this._y = THREE.Math.atan2(m13, m33);
                    this._z = THREE.Math.atan2(m21, m22);
                }
                else {
                    this._y = THREE.Math.atan2(-m31, m11);
                    this._z = 0;
                }
            }
            else if (order === 'ZXY') {
                this._x = THREE.Math.asin(clamp(m32, -1, 1));
                if (THREE.Math.abs(m32) < 0.99999) {
                    this._y = THREE.Math.atan2(-m31, m33);
                    this._z = THREE.Math.atan2(-m12, m22);
                }
                else {
                    this._y = 0;
                    this._z = THREE.Math.atan2(m21, m11);
                }
            }
            else if (order === 'ZYX') {
                this._y = THREE.Math.asin(-clamp(m31, -1, 1));
                if (THREE.Math.abs(m31) < 0.99999) {
                    this._x = THREE.Math.atan2(m32, m33);
                    this._z = THREE.Math.atan2(m21, m11);
                }
                else {
                    this._x = 0;
                    this._z = THREE.Math.atan2(-m12, m22);
                }
            }
            else if (order === 'YZX') {
                this._z = THREE.Math.asin(clamp(m21, -1, 1));
                if (THREE.Math.abs(m21) < 0.99999) {
                    this._x = THREE.Math.atan2(-m23, m22);
                    this._y = THREE.Math.atan2(-m31, m11);
                }
                else {
                    this._x = 0;
                    this._y = THREE.Math.atan2(m13, m33);
                }
            }
            else if (order === 'XZY') {
                this._z = THREE.Math.asin(-clamp(m12, -1, 1));
                if (THREE.Math.abs(m12) < 0.99999) {
                    this._x = THREE.Math.atan2(m32, m22);
                    this._y = THREE.Math.atan2(m13, m11);
                }
                else {
                    this._x = THREE.Math.atan2(-m23, m33);
                    this._y = 0;
                }
            }
            else {
                console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
            }
            this._order = order;
            if (update !== false)
                this.onChangeCallback();
            return this;
        };
        Euler.prototype.setFromQuaternion = function (q, order, update) {
            var matrix = new THREE.Matrix4();
            var func = Euler.prototype.setFromQuaternion
                = function (q, order, update) {
                    matrix.makeRotationFromQuaternion(q);
                    this.setFromRotationMatrix(matrix, order, update);
                    return this;
                };
            return func.apply(this, arguments);
        };
        Euler.prototype.setFromVector3 = function (v, order) {
            if (order === void 0) { order = this._order; }
            return this.set(v.x, v.y, v.z, order);
        };
        Euler.prototype.reorder = function (newOrder) {
            var q = new THREE.Quaternion();
            var func = Euler.prototype.reorder
                = function (newOrder) {
                    q.setFromEuler(this);
                    this.setFromQuaternion(q, newOrder);
                    return this;
                };
            return func.apply(this, arguments);
        };
        Euler.prototype.equals = function (euler) {
            return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);
        };
        Euler.prototype.fromArray = function (array) {
            this._x = array[0];
            this._y = array[1];
            this._z = array[2];
            if (array[3] !== undefined)
                this._order = array[3];
            this.onChangeCallback();
            return this;
        };
        Euler.prototype.toArray = function (array, offset) {
            if (array === void 0) { array = []; }
            if (offset === void 0) { offset = 0; }
            array[offset] = this._x;
            array[offset + 1] = this._y;
            array[offset + 2] = this._z;
            array[offset + 3] = this._order;
            return array;
        };
        Euler.prototype.toVector3 = function (optionalResult) {
            if (optionalResult) {
                return optionalResult.set(this._x, this._y, this._z);
            }
            else {
                return new THREE.Vector3(this._x, this._y, this._z);
            }
        };
        Euler.prototype.onChange = function (callback, _this) {
            this.onChangeCallback_this = _this;
            this.onChangeCallback_func = callback;
            return this;
        };
        Euler.prototype.onChangeCallback = function () {
            if (this.onChangeCallback_func != null)
                this.onChangeCallback_func.apply(this.onChangeCallback_this, arguments);
        };
        Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
        Euler.DefaultOrder = 'XYZ';
        return Euler;
    }());
    THREE.Euler = Euler;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Frustum = (function () {
        function Frustum(p0, p1, p2, p3, p4, p5) {
            this.planes = [
                (p0 !== undefined) ? p0 : new THREE.Plane(),
                (p1 !== undefined) ? p1 : new THREE.Plane(),
                (p2 !== undefined) ? p2 : new THREE.Plane(),
                (p3 !== undefined) ? p3 : new THREE.Plane(),
                (p4 !== undefined) ? p4 : new THREE.Plane(),
                (p5 !== undefined) ? p5 : new THREE.Plane()
            ];
        }
        Frustum.prototype.set = function (p0, p1, p2, p3, p4, p5) {
            var planes = this.planes;
            planes[0].copy(p0);
            planes[1].copy(p1);
            planes[2].copy(p2);
            planes[3].copy(p3);
            planes[4].copy(p4);
            planes[5].copy(p5);
            return this;
        };
        Frustum.prototype.clone = function () {
            return new Frustum().copy(this);
        };
        Frustum.prototype.copy = function (frustum) {
            var planes = this.planes;
            for (var i = 0; i < 6; i++) {
                planes[i].copy(frustum.planes[i]);
            }
            return this;
        };
        Frustum.prototype.setFromMatrix = function (m) {
            var planes = this.planes;
            var me = m.elements;
            var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
            var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
            var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
            var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
            planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
            planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
            planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
            planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
            planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
            planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
            return this;
        };
        Frustum.prototype.intersectsObject = function (object) {
            var sphere = new THREE.Sphere();
            var func = Frustum.prototype.intersectsObject = function (object) {
                var geometry = object.geometry;
                if (geometry.boundingSphere === null)
                    geometry.computeBoundingSphere();
                sphere.copy(geometry.boundingSphere)
                    .applyMatrix4(object.matrixWorld);
                return this.intersectsSphere(sphere);
            };
            return func.apply(this, arguments);
        };
        Frustum.prototype.intersectsSprite = function (sprite) {
            var sphere = new THREE.Sphere();
            var func = Frustum.prototype.intersectsSprite = function (sprite) {
                sphere.center.set(0, 0, 0);
                sphere.radius = 0.7071067811865476;
                sphere.applyMatrix4(sprite.matrixWorld);
                return this.intersectsSphere(sphere);
            };
            return func.apply(this, arguments);
        };
        Frustum.prototype.intersectsSphere = function (sphere) {
            var planes = this.planes;
            var center = sphere.center;
            var negRadius = -sphere.radius;
            for (var i = 0; i < 6; i++) {
                var distance = planes[i].distanceToPoint(center);
                if (distance < negRadius) {
                    return false;
                }
            }
            return true;
        };
        Frustum.prototype.intersectsBox = function (box) {
            var p1 = new THREE.Vector3();
            var p2 = new THREE.Vector3();
            var func = Frustum.prototype.intersectsBox = function (box) {
                var planes = this.planes;
                for (var i = 0; i < 6; i++) {
                    var plane = planes[i];
                    p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                    p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                    p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                    p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                    p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                    p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                    var d1 = plane.distanceToPoint(p1);
                    var d2 = plane.distanceToPoint(p2);
                    if (d1 < 0 && d2 < 0) {
                        return false;
                    }
                }
                return true;
            };
            return func.apply(this, arguments);
        };
        Frustum.prototype.containsPoint = function (point) {
            var planes = this.planes;
            for (var i = 0; i < 6; i++) {
                if (planes[i].distanceToPoint(point) < 0) {
                    return false;
                }
            }
            return true;
        };
        return Frustum;
    }());
    THREE.Frustum = Frustum;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Interpolant = (function () {
        function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            this.settings = null;
            this.DefaultSettings_ = {};
            this.parameterPositions = parameterPositions;
            this._cachedIndex = 0;
            this.resultBuffer = resultBuffer !== undefined
                ? resultBuffer
                : new (sampleValues.constructor(sampleSize));
            this.sampleValues = sampleValues;
            this.valueSize = sampleSize;
        }
        Interpolant.prototype.evaluate = function (t) {
            var pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
            validate_interval: {
                seek: {
                    var right;
                    linear_scan: {
                        forward_scan: if (!(t < t1)) {
                            for (var giveUpAt = i1 + 2;;) {
                                if (t1 === undefined) {
                                    if (t < t0)
                                        break forward_scan;
                                    i1 = pp.length;
                                    this._cachedIndex = i1;
                                    return this.afterEnd_(i1 - 1, t, t0);
                                }
                                if (i1 === giveUpAt)
                                    break;
                                t0 = t1;
                                t1 = pp[++i1];
                                if (t < t1) {
                                    break seek;
                                }
                            }
                            right = pp.length;
                            break linear_scan;
                        }
                        if (!(t >= t0)) {
                            var t1global = pp[1];
                            if (t < t1global) {
                                i1 = 2;
                                t0 = t1global;
                            }
                            for (var giveUpAt = i1 - 2;;) {
                                if (t0 === undefined) {
                                    this._cachedIndex = 0;
                                    return this.beforeStart_(0, t, t1);
                                }
                                if (i1 === giveUpAt)
                                    break;
                                t1 = t0;
                                t0 = pp[--i1 - 1];
                                if (t >= t0) {
                                    break seek;
                                }
                            }
                            right = i1;
                            i1 = 0;
                            break linear_scan;
                        }
                        break validate_interval;
                    }
                    while (i1 < right) {
                        var mid = (i1 + right) >>> 1;
                        if (t < pp[mid]) {
                            right = mid;
                        }
                        else {
                            i1 = mid + 1;
                        }
                    }
                    t1 = pp[i1];
                    t0 = pp[i1 - 1];
                    if (t0 === undefined) {
                        this._cachedIndex = 0;
                        return this.beforeStart_(0, t, t1);
                    }
                    if (t1 === undefined) {
                        i1 = pp.length;
                        this._cachedIndex = i1;
                        return this.afterEnd_(i1 - 1, t0, t);
                    }
                }
                this._cachedIndex = i1;
                this.intervalChanged_(i1, t0, t1);
            }
            return this.interpolate_(i1, t0, t, t1);
        };
        Interpolant.prototype.getSettings_ = function () {
            return this.settings || this.DefaultSettings_;
        };
        Interpolant.prototype.copySampleValue_ = function (index) {
            var result = this.resultBuffer;
            var values = this.sampleValues;
            var stride = this.valueSize;
            var offset = index * stride;
            for (var i = 0; i !== stride; ++i) {
                result[i] = values[offset + i];
            }
            return result;
        };
        Interpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
            throw new Error("call to abstract method");
        };
        Interpolant.prototype.intervalChanged_ = function (i1, t0, t1) {
        };
        Interpolant.prototype.beforeStart_ = function (i1, t0, t1) {
            return null;
        };
        Interpolant.prototype.afterEnd_ = function (i1, t0, t1) {
            return null;
        };
        return Interpolant;
    }());
    THREE.Interpolant = Interpolant;
    Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
    Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var CubicInterpolant = (function (_super) {
        __extends(CubicInterpolant, _super);
        function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            _super.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
            this._weightPrev = -0;
            this._offsetPrev = -0;
            this._weightNext = -0;
            this._offsetNext = -0;
            this.DefaultSettings_ =
                {
                    endingStart: THREE.ZeroCurvatureEnding,
                    endingEnd: THREE.ZeroCurvatureEnding
                };
        }
        CubicInterpolant.prototype.intervalChanged_ = function (i1, t0, t1) {
            var pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
            if (tPrev === undefined) {
                switch (this.getSettings_().endingStart) {
                    case THREE.ZeroSlopeEnding:
                        iPrev = i1;
                        tPrev = 2 * t0 - t1;
                        break;
                    case THREE.WrapAroundEnding:
                        iPrev = pp.length - 2;
                        tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                        break;
                    default:
                        iPrev = i1;
                        tPrev = t1;
                }
            }
            if (tNext === undefined) {
                switch (this.getSettings_().endingEnd) {
                    case THREE.ZeroSlopeEnding:
                        iNext = i1;
                        tNext = 2 * t1 - t0;
                        break;
                    case THREE.WrapAroundEnding:
                        iNext = 1;
                        tNext = t1 + pp[1] - pp[0];
                        break;
                    default:
                        iNext = i1 - 1;
                        tNext = t0;
                }
            }
            var halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
            this._weightPrev = halfDt / (t0 - tPrev);
            this._weightNext = halfDt / (tNext - t1);
            this._offsetPrev = iPrev * stride;
            this._offsetNext = iNext * stride;
        };
        CubicInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
            var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
            var sP = -wP * ppp + 2 * wP * pp - wP * p;
            var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
            var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
            var sN = wN * ppp - wN * pp;
            for (var i = 0; i !== stride; ++i) {
                result[i] =
                    sP * values[oP + i] +
                        s0 * values[o0 + i] +
                        s1 * values[o1 + i] +
                        sN * values[oN + i];
            }
            return result;
        };
        return CubicInterpolant;
    }(THREE.Interpolant));
    THREE.CubicInterpolant = CubicInterpolant;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var DiscreteInterpolant = (function (_super) {
        __extends(DiscreteInterpolant, _super);
        function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            _super.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        DiscreteInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
            return this.copySampleValue_(i1 - 1);
        };
        return DiscreteInterpolant;
    }(THREE.Interpolant));
    THREE.DiscreteInterpolant = DiscreteInterpolant;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var LinearInterpolant = (function (_super) {
        __extends(LinearInterpolant, _super);
        function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            _super.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        LinearInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
            var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
            for (var i = 0; i !== stride; ++i) {
                result[i] =
                    values[offset0 + i] * weight0 +
                        values[offset1 + i] * weight1;
            }
            return result;
        };
        return LinearInterpolant;
    }(THREE.Interpolant));
    THREE.LinearInterpolant = LinearInterpolant;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var QuaternionLinearInterpolant = (function (_super) {
        __extends(QuaternionLinearInterpolant, _super);
        function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            _super.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        QuaternionLinearInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
            var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = i1 * stride, alpha = (t - t0) / (t1 - t0);
            for (var end = offset + stride; offset !== end; offset += 4) {
                THREE.Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
            }
            return result;
        };
        return QuaternionLinearInterpolant;
    }(THREE.Interpolant));
    THREE.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Line3 = (function () {
        function Line3(start, end) {
            if (start === void 0) { start = new THREE.Vector3(); }
            if (end === void 0) { end = new THREE.Vector3(); }
            this.start = start;
            this.end = end;
        }
        Line3.prototype.set = function (start, end) {
            this.start.copy(start);
            this.end.copy(end);
            return this;
        };
        Line3.prototype.clone = function () {
            return new Line3().copy(this);
        };
        Line3.prototype.copy = function (line) {
            this.start.copy(line.start);
            this.end.copy(line.end);
            return this;
        };
        Line3.prototype.center = function (optionalTarget) {
            var result = optionalTarget || new THREE.Vector3();
            return result.addVectors(this.start, this.end).multiplyScalar(0.5);
        };
        Line3.prototype.delta = function (optionalTarget) {
            var result = optionalTarget || new THREE.Vector3();
            return result.subVectors(this.end, this.start);
        };
        Line3.prototype.distanceSq = function () {
            return this.start.distanceToSquared(this.end);
        };
        Line3.prototype.distance = function () {
            return this.start.distanceTo(this.end);
        };
        Line3.prototype.at = function (t, optionalTarget) {
            var result = optionalTarget || new THREE.Vector3();
            return this.delta(result).multiplyScalar(t).add(this.start);
        };
        Line3.prototype.closestPointToPointParameter = function (point, clampToLine) {
            var startP = new THREE.Vector3();
            var startEnd = new THREE.Vector3();
            var func = Line3.prototype.closestPointToPointParameter = function (point, clampToLine) {
                startP.subVectors(point, this.start);
                startEnd.subVectors(this.end, this.start);
                var startEnd2 = startEnd.dot(startEnd);
                var startEnd_startP = startEnd.dot(startP);
                var t = startEnd_startP / startEnd2;
                if (clampToLine) {
                    t = THREE.Math.clamp(t, 0, 1);
                }
                return t;
            };
            return func.apply(this, arguments);
        };
        Line3.prototype.closestPointToPoint = function (point, clampToLine, optionalTarget) {
            var t = this.closestPointToPointParameter(point, clampToLine);
            var result = optionalTarget || new THREE.Vector3();
            return this.delta(result).multiplyScalar(t).add(this.start);
        };
        Line3.prototype.applyMatrix4 = function (matrix) {
            this.start.applyMatrix4(matrix);
            this.end.applyMatrix4(matrix);
            return this;
        };
        Line3.prototype.equals = function (line) {
            return line.start.equals(this.start) && line.end.equals(this.end);
        };
        return Line3;
    }());
    THREE.Line3 = Line3;
    ;
})(THREE || (THREE = {}));
if (Math.DEG2RAD === undefined) {
    Math.DEG2RAD = Math.PI / 180;
    Math.RAD2DEG = 180 / Math.PI;
    Math.generateUUID = function () {
        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
        var uuid = new Array(36);
        var rnd = 0, r;
        return function generateUUID() {
            for (var i = 0; i < 36; i++) {
                if (i === 8 || i === 13 || i === 18 || i === 23) {
                    uuid[i] = '-';
                }
                else if (i === 14) {
                    uuid[i] = '4';
                }
                else {
                    if (rnd <= 0x02)
                        rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
                    r = rnd & 0xf;
                    rnd = rnd >> 4;
                    uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];
                }
            }
            return uuid.join('');
        };
    }();
    Math.clamp = function (value, min, max) {
        return Math.max(min, Math.min(max, value));
    };
    Math.euclideanModulo = function (n, m) {
        return ((n % m) + m) % m;
    };
    Math.mapLinear = function (x, a1, a2, b1, b2) {
        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
    };
    Math.smoothstep = function (x, min, max) {
        if (x <= min)
            return 0;
        if (x >= max)
            return 1;
        x = (x - min) / (max - min);
        return x * x * (3 - 2 * x);
    };
    Math.smootherstep = function (x, min, max) {
        if (x <= min)
            return 0;
        if (x >= max)
            return 1;
        x = (x - min) / (max - min);
        return x * x * x * (x * (x * 6 - 15) + 10);
    };
    Math.randInt = function (low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
    };
    Math.randFloat = function (low, high) {
        return low + Math.random() * (high - low);
    };
    Math.randFloatSpread = function (range) {
        return range * (0.5 - Math.random());
    };
    Math.degToRad = function (degrees) {
        return degrees * Math.DEG2RAD;
    };
    Math.radToDeg = function (radians) {
        return radians * Math.RAD2DEG;
    };
    Math.isPowerOfTwo = function (value) {
        return (value & (value - 1)) === 0 && value !== 0;
    };
    Math.nearestPowerOfTwo = function (value) {
        return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
    };
    Math.nextPowerOfTwo = function (value) {
        value--;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        value++;
        return value;
    };
}
var _math = Math;
var THREE;
(function (THREE) {
    THREE.Math = _math;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Plane = (function () {
        function Plane(normal, constant) {
            if (normal === void 0) { normal = new THREE.Vector3(1, 0, 0); }
            if (constant === void 0) { constant = 0; }
            this.normal = normal;
            this.constant = constant;
        }
        Plane.prototype.set = function (normal, constant) {
            this.normal.copy(normal);
            this.constant = constant;
            return this;
        };
        Plane.prototype.setComponents = function (x, y, z, w) {
            this.normal.set(x, y, z);
            this.constant = w;
            return this;
        };
        Plane.prototype.setFromNormalAndCoplanarPoint = function (normal, point) {
            this.normal.copy(normal);
            this.constant = -point.dot(this.normal);
            return this;
        };
        Plane.prototype.setFromCoplanarPoints = function (a, b, c) {
            var v1 = new THREE.Vector3();
            var v2 = new THREE.Vector3();
            var func = Plane.prototype.setFromCoplanarPoints = function (a, b, c) {
                var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
                this.setFromNormalAndCoplanarPoint(normal, a);
                return this;
            };
            return func.apply(this, arguments);
        };
        Plane.prototype.clone = function () {
            return new Plane().copy(this);
        };
        Plane.prototype.copy = function (plane) {
            this.normal.copy(plane.normal);
            this.constant = plane.constant;
            return this;
        };
        Plane.prototype.normalize = function () {
            var inverseNormalLength = 1.0 / this.normal.length();
            this.normal.multiplyScalar(inverseNormalLength);
            this.constant *= inverseNormalLength;
            return this;
        };
        Plane.prototype.negate = function () {
            this.constant *= -1;
            this.normal.negate();
            return this;
        };
        Plane.prototype.distanceToPoint = function (point) {
            return this.normal.dot(point) + this.constant;
        };
        Plane.prototype.distanceToSphere = function (sphere) {
            return this.distanceToPoint(sphere.center) - sphere.radius;
        };
        Plane.prototype.projectPoint = function (point, optionalTarget) {
            return this.orthoPoint(point, optionalTarget).sub(point).negate();
        };
        Plane.prototype.orthoPoint = function (point, optionalTarget) {
            var perpendicularMagnitude = this.distanceToPoint(point);
            var result = optionalTarget || new THREE.Vector3();
            return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
        };
        Plane.prototype.intersectLine = function (line, optionalTarget) {
            var v1 = new THREE.Vector3();
            var func = Plane.prototype.intersectLine = function (line, optionalTarget) {
                var result = optionalTarget || new THREE.Vector3();
                var direction = line.delta(v1);
                var denominator = this.normal.dot(direction);
                if (denominator === 0) {
                    if (this.distanceToPoint(line.start) === 0) {
                        return result.copy(line.start);
                    }
                    return undefined;
                }
                var t = -(line.start.dot(this.normal) + this.constant) / denominator;
                if (t < 0 || t > 1) {
                    return undefined;
                }
                result.copy(direction).multiplyScalar(t).add(line.start);
                return result;
            };
            return func.apply(this, arguments);
        };
        Plane.prototype.intersectsLine = function (line) {
            var startSign = this.distanceToPoint(line.start);
            var endSign = this.distanceToPoint(line.end);
            return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
        };
        Plane.prototype.intersectsBox = function (box) {
            return box.intersectsPlane(this);
        };
        Plane.prototype.intersectsSphere = function (sphere) {
            return sphere.intersectsPlane(this);
        };
        Plane.prototype.coplanarPoint = function (optionalTarget) {
            var result = optionalTarget || new THREE.Vector3();
            return result.copy(this.normal).multiplyScalar(-this.constant);
        };
        Plane.prototype.applyMatrix4 = function (matrix, optionalNormalMatrix) {
            var v1 = new THREE.Vector3;
            var m1 = new THREE.Matrix3;
            var func = Plane.prototype.applyMatrix4 = function (matrix, optionalNormalMatrix) {
                var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);
                var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
                var normal = this.normal.applyMatrix3(normalMatrix).normalize();
                this.constant = -referencePoint.dot(normal);
                return this;
            };
            return func.apply(this, arguments);
        };
        Plane.prototype.translate = function (offset) {
            this.constant = this.constant - offset.dot(this.normal);
            return this;
        };
        Plane.prototype.equals = function (plane) {
            return plane.normal.equals(this.normal) && (plane.constant === this.constant);
        };
        return Plane;
    }());
    THREE.Plane = Plane;
    ;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Quaternion = (function () {
        function Quaternion(_x, _y, _z, _w) {
            if (_x === void 0) { _x = 0; }
            if (_y === void 0) { _y = 0; }
            if (_z === void 0) { _z = 0; }
            if (_w === void 0) { _w = 1; }
            this._x = _x;
            this._y = _y;
            this._z = _z;
            this._w = _w;
        }
        Object.defineProperty(Quaternion.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (value) {
                this._x = value;
                this.onChangeCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Quaternion.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (value) {
                this._y = value;
                this.onChangeCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Quaternion.prototype, "z", {
            get: function () {
                return this._z;
            },
            set: function (value) {
                this._z = value;
                this.onChangeCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Quaternion.prototype, "w", {
            get: function () {
                return this._w;
            },
            set: function (value) {
                this._w = value;
                this.onChangeCallback();
            },
            enumerable: true,
            configurable: true
        });
        Quaternion.prototype.set = function (x, y, z, w) {
            this._x = x;
            this._y = y;
            this._z = z;
            this._w = w;
            this.onChangeCallback();
            return this;
        };
        Quaternion.prototype.clone = function () {
            return new Quaternion(this._x, this._y, this._z, this._w);
        };
        Quaternion.prototype.copy = function (quaternion) {
            this._x = quaternion.x;
            this._y = quaternion.y;
            this._z = quaternion.z;
            this._w = quaternion.w;
            this.onChangeCallback();
            return this;
        };
        Quaternion.prototype.setFromEuler = function (euler, update) {
            var c1 = THREE.Math.cos(euler._x / 2);
            var c2 = THREE.Math.cos(euler._y / 2);
            var c3 = THREE.Math.cos(euler._z / 2);
            var s1 = THREE.Math.sin(euler._x / 2);
            var s2 = THREE.Math.sin(euler._y / 2);
            var s3 = THREE.Math.sin(euler._z / 2);
            var order = euler.order;
            if (order === 'XYZ') {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            }
            else if (order === 'YXZ') {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            }
            else if (order === 'ZXY') {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            }
            else if (order === 'ZYX') {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            }
            else if (order === 'YZX') {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            }
            else if (order === 'XZY') {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            }
            if (update !== false)
                this.onChangeCallback();
            return this;
        };
        Quaternion.prototype.setFromAxisAngle = function (axis, angle) {
            var halfAngle = angle / 2, s = THREE.Math.sin(halfAngle);
            this._x = axis.x * s;
            this._y = axis.y * s;
            this._z = axis.z * s;
            this._w = THREE.Math.cos(halfAngle);
            this.onChangeCallback();
            return this;
        };
        Quaternion.prototype.setFromRotationMatrix = function (m) {
            var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s;
            if (trace > 0) {
                s = 0.5 / THREE.Math.sqrt(trace + 1.0);
                this._w = 0.25 / s;
                this._x = (m32 - m23) * s;
                this._y = (m13 - m31) * s;
                this._z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * THREE.Math.sqrt(1.0 + m11 - m22 - m33);
                this._w = (m32 - m23) / s;
                this._x = 0.25 * s;
                this._y = (m12 + m21) / s;
                this._z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * THREE.Math.sqrt(1.0 + m22 - m11 - m33);
                this._w = (m13 - m31) / s;
                this._x = (m12 + m21) / s;
                this._y = 0.25 * s;
                this._z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * THREE.Math.sqrt(1.0 + m33 - m11 - m22);
                this._w = (m21 - m12) / s;
                this._x = (m13 + m31) / s;
                this._y = (m23 + m32) / s;
                this._z = 0.25 * s;
            }
            this.onChangeCallback();
            return this;
        };
        Quaternion.prototype.setFromUnitVectors = function (vFrom, vTo) {
            var v1, r;
            var EPS = 0.000001;
            var func = Quaternion.prototype.setFromUnitVectors = function setFromUnitVectors(vFrom, vTo) {
                if (v1 === undefined)
                    v1 = new THREE.Vector3();
                r = vFrom.dot(vTo) + 1;
                if (r < EPS) {
                    r = 0;
                    if (THREE.Math.abs(vFrom.x) > THREE.Math.abs(vFrom.z)) {
                        v1.set(-vFrom.y, vFrom.x, 0);
                    }
                    else {
                        v1.set(0, -vFrom.z, vFrom.y);
                    }
                }
                else {
                    v1.crossVectors(vFrom, vTo);
                }
                this._x = v1.x;
                this._y = v1.y;
                this._z = v1.z;
                this._w = r;
                return this.normalize();
            };
            return func.apply(this, arguments);
        };
        Quaternion.prototype.inverse = function () {
            return this.conjugate().normalize();
        };
        Quaternion.prototype.conjugate = function () {
            this._x *= -1;
            this._y *= -1;
            this._z *= -1;
            this.onChangeCallback();
            return this;
        };
        Quaternion.prototype.dot = function (v) {
            return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
        };
        Quaternion.prototype.lengthSq = function () {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        };
        Quaternion.prototype.length = function () {
            return THREE.Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        };
        Quaternion.prototype.normalize = function () {
            var l = this.length();
            if (l === 0) {
                this._x = 0;
                this._y = 0;
                this._z = 0;
                this._w = 1;
            }
            else {
                l = 1 / l;
                this._x = this._x * l;
                this._y = this._y * l;
                this._z = this._z * l;
                this._w = this._w * l;
            }
            this.onChangeCallback();
            return this;
        };
        Quaternion.prototype.multiply = function (q) {
            return this.multiplyQuaternions(this, q);
        };
        Quaternion.prototype.premultiply = function (q) {
            return this.multiplyQuaternions(q, this);
        };
        Quaternion.prototype.multiplyQuaternions = function (a, b) {
            var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
            var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
            this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
            this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
            this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
            this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
            this.onChangeCallback();
            return this;
        };
        Quaternion.prototype.slerp = function (qb, t) {
            if (t === 0)
                return this;
            if (t === 1)
                return this.copy(qb);
            var x = this._x, y = this._y, z = this._z, w = this._w;
            var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
            if (cosHalfTheta < 0) {
                this._w = -qb._w;
                this._x = -qb._x;
                this._y = -qb._y;
                this._z = -qb._z;
                cosHalfTheta = -cosHalfTheta;
            }
            else {
                this.copy(qb);
            }
            if (cosHalfTheta >= 1.0) {
                this._w = w;
                this._x = x;
                this._y = y;
                this._z = z;
                return this;
            }
            var sinHalfTheta = THREE.Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
            if (THREE.Math.abs(sinHalfTheta) < 0.001) {
                this._w = 0.5 * (w + this._w);
                this._x = 0.5 * (x + this._x);
                this._y = 0.5 * (y + this._y);
                this._z = 0.5 * (z + this._z);
                return this;
            }
            var halfTheta = THREE.Math.atan2(sinHalfTheta, cosHalfTheta);
            var ratioA = THREE.Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = THREE.Math.sin(t * halfTheta) / sinHalfTheta;
            this._w = (w * ratioA + this._w * ratioB);
            this._x = (x * ratioA + this._x * ratioB);
            this._y = (y * ratioA + this._y * ratioB);
            this._z = (z * ratioA + this._z * ratioB);
            this.onChangeCallback();
            return this;
        };
        Quaternion.prototype.equals = function (quaternion) {
            return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);
        };
        Quaternion.prototype.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            this._x = array[offset];
            this._y = array[offset + 1];
            this._z = array[offset + 2];
            this._w = array[offset + 3];
            this.onChangeCallback();
            return this;
        };
        Quaternion.prototype.toArray = function (array, offset) {
            if (array === void 0) { array = []; }
            if (offset === void 0) { offset = 0; }
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            array[offset] = this._x;
            array[offset + 1] = this._y;
            array[offset + 2] = this._z;
            array[offset + 3] = this._w;
            return array;
        };
        Quaternion.prototype.onChange = function (callback, _this) {
            this.onChangeCallback_this = _this;
            this.onChangeCallback_func = callback;
            return this;
        };
        Quaternion.prototype.onChangeCallback = function () {
            if (this.onChangeCallback_func != null)
                this.onChangeCallback_func.apply(this.onChangeCallback_this, arguments);
        };
        Quaternion.slerp = function (qa, qb, qm, t) {
            return qm.copy(qa).slerp(qb, t);
        };
        Quaternion.slerpFlat = function (dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
            var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
            if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = (cos >= 0 ? 1 : -1), sqrSin = 1 - cos * cos;
                if (sqrSin > Number.EPSILON) {
                    var sin = THREE.Math.sqrt(sqrSin), len = THREE.Math.atan2(sin, cos * dir);
                    s = THREE.Math.sin(s * len) / sin;
                    t = THREE.Math.sin(t * len) / sin;
                }
                var tDir = t * dir;
                x0 = x0 * s + x1 * tDir;
                y0 = y0 * s + y1 * tDir;
                z0 = z0 * s + z1 * tDir;
                w0 = w0 * s + w1 * tDir;
                if (s === 1 - t) {
                    var f = 1 / THREE.Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                    x0 *= f;
                    y0 *= f;
                    z0 *= f;
                    w0 *= f;
                }
            }
            dst[dstOffset] = x0;
            dst[dstOffset + 1] = y0;
            dst[dstOffset + 2] = z0;
            dst[dstOffset + 3] = w0;
        };
        return Quaternion;
    }());
    THREE.Quaternion = Quaternion;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Ray = (function () {
        function Ray(origin, direction) {
            if (origin === void 0) { origin = new THREE.Vector3(); }
            if (direction === void 0) { direction = new THREE.Vector3(); }
            this.origin = origin;
            this.direction = direction;
        }
        Ray.prototype.set = function (origin, direction) {
            this.origin.copy(origin);
            this.direction.copy(direction);
            return this;
        };
        Ray.prototype.clone = function () {
            return new Ray().copy(this);
        };
        Ray.prototype.copy = function (ray) {
            this.origin.copy(ray.origin);
            this.direction.copy(ray.direction);
            return this;
        };
        Ray.prototype.at = function (t, optionalTarget) {
            var result = optionalTarget || new THREE.Vector3();
            return result.copy(this.direction).multiplyScalar(t).add(this.origin);
        };
        Ray.prototype.lookAt = function (v) {
            this.direction.copy(v).sub(this.origin).normalize();
            return this;
        };
        Ray.prototype.recast = function (t) {
            var v1 = new THREE.Vector3();
            var func = Ray.prototype.recast = function (t) {
                this.origin.copy(this.at(t, v1));
                return this;
            };
            return func.apply(this, arguments);
        };
        Ray.prototype.closestPointToPoint = function (point, optionalTarget) {
            var result = optionalTarget || new THREE.Vector3();
            result.subVectors(point, this.origin);
            var directionDistance = result.dot(this.direction);
            if (directionDistance < 0) {
                return result.copy(this.origin);
            }
            return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        };
        Ray.prototype.distanceToPoint = function (point) {
            return THREE.Math.sqrt(this.distanceSqToPoint(point));
        };
        Ray.prototype.distanceSqToPoint = function (point) {
            var v1 = Ray[".distanceSqToPoint.v1"] || (Ray[".distanceSqToPoint.v1"] = new THREE.Vector3());
            var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
            var r;
            if (directionDistance < 0) {
                r = this.origin.distanceToSquared(point);
                return r;
            }
            v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
            r = v1.distanceToSquared(point);
            return r;
        };
        Ray.prototype.distanceSqToSegment = function (v0, v1, optionalPointOnRay, optionalPointOnSegment) {
            var segCenter = Ray[".dst.segCenter"] || (Ray[".dst.segCenter"] = new THREE.Vector3());
            var segDir = Ray[".dst.segDir"] || (Ray[".dst.segDir"] = new THREE.Vector3());
            var diff = Ray[".dst.diff"] || (Ray[".dst.diff"] = new THREE.Vector3());
            segCenter.copy(v0).add(v1).multiplyScalar(0.5);
            segDir.copy(v1).sub(v0).normalize();
            diff.copy(this.origin).sub(segCenter);
            var segExtent = v0.distanceTo(v1) * 0.5;
            var a01 = -this.direction.dot(segDir);
            var b0 = diff.dot(this.direction);
            var b1 = -diff.dot(segDir);
            var c = diff.lengthSq();
            var det = THREE.Math.abs(1 - a01 * a01);
            var s0, s1, sqrDist, extDet;
            if (det > 0) {
                s0 = a01 * b1 - b0;
                s1 = a01 * b0 - b1;
                extDet = segExtent * det;
                if (s0 >= 0) {
                    if (s1 >= -extDet) {
                        if (s1 <= extDet) {
                            var invDet = 1 / det;
                            s0 *= invDet;
                            s1 *= invDet;
                            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                        }
                        else {
                            s1 = segExtent;
                            s0 = THREE.Math.max(0, -(a01 * s1 + b0));
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                    }
                    else {
                        s1 = -segExtent;
                        s0 = THREE.Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                }
                else {
                    if (s1 <= -extDet) {
                        s0 = THREE.Math.max(0, -(-a01 * segExtent + b0));
                        s1 = (s0 > 0) ? -segExtent : THREE.Math.min(THREE.Math.max(-segExtent, -b1), segExtent);
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                    else if (s1 <= extDet) {
                        s0 = 0;
                        s1 = THREE.Math.min(THREE.Math.max(-segExtent, -b1), segExtent);
                        sqrDist = s1 * (s1 + 2 * b1) + c;
                    }
                    else {
                        s0 = THREE.Math.max(0, -(a01 * segExtent + b0));
                        s1 = (s0 > 0) ? segExtent : THREE.Math.min(THREE.Math.max(-segExtent, -b1), segExtent);
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                }
            }
            else {
                s1 = (a01 > 0) ? -segExtent : segExtent;
                s0 = THREE.Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
            if (optionalPointOnRay) {
                optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
            }
            if (optionalPointOnSegment) {
                optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
            }
            return sqrDist;
        };
        Ray.prototype.intersectSphere = function (sphere, optionalTarget) {
            var v1 = Ray[".isp.segCenter"] || (Ray[".isp.segCenter"] = new THREE.Vector3());
            v1.subVectors(sphere.center, this.origin);
            var tca = v1.dot(this.direction);
            var d2 = v1.dot(v1) - tca * tca;
            var radius2 = sphere.radius * sphere.radius;
            if (d2 > radius2)
                return null;
            var thc = THREE.Math.sqrt(radius2 - d2);
            var t0 = tca - thc;
            var t1 = tca + thc;
            if (t0 < 0 && t1 < 0)
                return null;
            if (t0 < 0)
                return this.at(t1, optionalTarget);
            return this.at(t0, optionalTarget);
        };
        Ray.prototype.intersectsSphere = function (sphere) {
            return this.distanceToPoint(sphere.center) <= sphere.radius;
        };
        Ray.prototype.distanceToPlane = function (plane) {
            var denominator = plane.normal.dot(this.direction);
            if (denominator === 0) {
                if (plane.distanceToPoint(this.origin) === 0) {
                    return 0;
                }
                return null;
            }
            var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
            return t >= 0 ? t : null;
        };
        Ray.prototype.intersectPlane = function (plane, optionalTarget) {
            var t = this.distanceToPlane(plane);
            if (t === null) {
                return null;
            }
            return this.at(t, optionalTarget);
        };
        Ray.prototype.intersectsPlane = function (plane) {
            var distToPoint = plane.distanceToPoint(this.origin);
            if (distToPoint === 0) {
                return true;
            }
            var denominator = plane.normal.dot(this.direction);
            if (denominator * distToPoint < 0) {
                return true;
            }
            return false;
        };
        Ray.prototype.intersectBox = function (box, optionalTarget) {
            var tmin, tmax, tymin, tymax, tzmin, tzmax;
            var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
            var origin = this.origin;
            if (invdirx >= 0) {
                tmin = (box.min.x - origin.x) * invdirx;
                tmax = (box.max.x - origin.x) * invdirx;
            }
            else {
                tmin = (box.max.x - origin.x) * invdirx;
                tmax = (box.min.x - origin.x) * invdirx;
            }
            if (invdiry >= 0) {
                tymin = (box.min.y - origin.y) * invdiry;
                tymax = (box.max.y - origin.y) * invdiry;
            }
            else {
                tymin = (box.max.y - origin.y) * invdiry;
                tymax = (box.min.y - origin.y) * invdiry;
            }
            if ((tmin > tymax) || (tymin > tmax))
                return null;
            if (tymin > tmin || tmin !== tmin)
                tmin = tymin;
            if (tymax < tmax || tmax !== tmax)
                tmax = tymax;
            if (invdirz >= 0) {
                tzmin = (box.min.z - origin.z) * invdirz;
                tzmax = (box.max.z - origin.z) * invdirz;
            }
            else {
                tzmin = (box.max.z - origin.z) * invdirz;
                tzmax = (box.min.z - origin.z) * invdirz;
            }
            if ((tmin > tzmax) || (tzmin > tmax))
                return null;
            if (tzmin > tmin || tmin !== tmin)
                tmin = tzmin;
            if (tzmax < tmax || tmax !== tmax)
                tmax = tzmax;
            if (tmax < 0)
                return null;
            return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
        };
        Ray.prototype.intersectsBox = function (box) {
            var v = Ray[".ibx.v"] || (Ray[".ibx.v"] = new THREE.Vector3());
            var result = this.intersectBox(box, v) !== null;
            return result;
        };
        Ray.prototype.intersectTriangle = function (a, b, c, backfaceCulling, optionalTarget) {
            var diff = Ray[".itg.1"] || (Ray[".itg.1"] = new THREE.Vector3());
            var edge1 = Ray[".itg.2"] || (Ray[".itg.2"] = new THREE.Vector3());
            var edge2 = Ray[".itg.3"] || (Ray[".itg.3"] = new THREE.Vector3());
            var normal = Ray[".itg.4"] || (Ray[".itg.4"] = new THREE.Vector3());
            edge1.subVectors(b, a);
            edge2.subVectors(c, a);
            normal.crossVectors(edge1, edge2);
            var DdN = this.direction.dot(normal);
            var sign;
            if (DdN > 0) {
                if (backfaceCulling)
                    return null;
                sign = 1;
            }
            else if (DdN < 0) {
                sign = -1;
                DdN = -DdN;
            }
            else {
                return null;
            }
            diff.subVectors(this.origin, a);
            var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
            if (DdQxE2 < 0) {
                return null;
            }
            var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
            if (DdE1xQ < 0) {
                return null;
            }
            if (DdQxE2 + DdE1xQ > DdN) {
                return null;
            }
            var QdN = -sign * diff.dot(normal);
            if (QdN < 0) {
                return null;
            }
            return this.at(QdN / DdN, optionalTarget);
        };
        Ray.prototype.applyMatrix4 = function (matrix4) {
            this.direction.add(this.origin).applyMatrix4(matrix4);
            this.origin.applyMatrix4(matrix4);
            this.direction.sub(this.origin);
            this.direction.normalize();
            return this;
        };
        Ray.prototype.equals = function (ray) {
            return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        };
        return Ray;
    }());
    THREE.Ray = Ray;
    ;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Spline = (function () {
        function Spline(points) {
            this.c = [0, 0, 0, 0];
            this.v3 = new THREE.Vector3();
            this.points = points;
        }
        Spline.prototype.initFromArray = function (a) {
            this.points = [];
            for (var i = 0; i < a.length; i++) {
                this.points[i] = new THREE.Vector3(a[i][0], a[i][1], a[i][2]);
            }
        };
        ;
        Spline.prototype.getPoint = function (k) {
            var point = (this.points.length - 1) * k;
            var intPoint = THREE.Math.floor(point);
            var weight = point - intPoint;
            var c = this.c;
            c[0] = intPoint === 0 ? intPoint : intPoint - 1;
            c[1] = intPoint;
            c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
            c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
            var pa = this.points[c[0]];
            var pb = this.points[c[1]];
            var pc = this.points[c[2]];
            var pd = this.points[c[3]];
            var w2 = weight * weight;
            var w3 = weight * w2;
            var v3 = this.v3;
            v3.x = Spline.interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);
            v3.y = Spline.interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);
            v3.z = Spline.interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);
            return this.v3;
        };
        ;
        Spline.prototype.getControlPointsArray = function () {
            var i;
            var p;
            var l = this.points.length;
            var coords = [];
            for (i = 0; i < l; i++) {
                p = this.points[i];
                coords[i] = [p.x, p.y, p.z];
            }
            return coords;
        };
        Spline.prototype.getLength = function (nSubDivisions) {
            var i, index, nSamples, position, point = 0, intPoint = 0, oldIntPoint = 0, oldPosition = new THREE.Vector3(), tmpVec = new THREE.Vector3(), chunkLengths = [], totalLength = 0;
            chunkLengths[0] = 0;
            if (!nSubDivisions)
                nSubDivisions = 100;
            nSamples = this.points.length * nSubDivisions;
            oldPosition.copy(this.points[0]);
            for (i = 1; i < nSamples; i++) {
                index = i / nSamples;
                position = this.getPoint(index);
                tmpVec.copy(position);
                totalLength += tmpVec.distanceTo(oldPosition);
                oldPosition.copy(position);
                point = (this.points.length - 1) * index;
                intPoint = THREE.Math.floor(point);
                if (intPoint !== oldIntPoint) {
                    chunkLengths[intPoint] = totalLength;
                    oldIntPoint = intPoint;
                }
            }
            chunkLengths[chunkLengths.length] = totalLength;
            return { chunks: chunkLengths, total: totalLength };
        };
        Spline.interpolate = function (p0, p1, p2, p3, t, t2, t3) {
            var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5;
            return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
        };
        return Spline;
    }());
    THREE.Spline = Spline;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Bone = (function (_super) {
        __extends(Bone, _super);
        function Bone(skin) {
            _super.call(this);
            this.type = 'Bone';
            this.skin = skin;
        }
        ;
        Bone.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.skin = source.skin;
            return this;
        };
        return Bone;
    }(THREE.Object3D));
    THREE.Bone = Bone;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Group = (function (_super) {
        __extends(Group, _super);
        function Group() {
            _super.call(this);
            this.type = 'Group';
        }
        ;
        return Group;
    }(THREE.Object3D));
    THREE.Group = Group;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var LensFlare = (function (_super) {
        __extends(LensFlare, _super);
        function LensFlare(texture, size, distance, blending, color) {
            _super.call(this);
            this.lensFlares = [];
            this.positionScreen = new THREE.Vector3();
            if (texture !== undefined) {
                this.add(texture, size, distance, blending, color);
            }
        }
        ;
        LensFlare.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source);
            this.positionScreen.copy(source.positionScreen);
            this.customUpdateCallback = source.customUpdateCallback;
            for (var i = 0, l = source.lensFlares.length; i < l; i++) {
                this.lensFlares.push(source.lensFlares[i]);
            }
            return this;
        };
        LensFlare.prototype.add = function (texture, size, distance, blending, color, opacity) {
            if (size === undefined)
                size = -1;
            if (distance === undefined)
                distance = 0;
            if (opacity === undefined)
                opacity = 1;
            if (color === undefined)
                color = new THREE.Color(0xffffff);
            if (blending === undefined)
                blending = THREE.NormalBlending;
            distance = THREE.Math.min(distance, THREE.Math.max(0, distance));
            this.lensFlares.push({
                texture: texture,
                size: size,
                distance: distance,
                x: 0, y: 0, z: 0,
                scale: 1,
                rotation: 0,
                opacity: opacity,
                color: color,
                blending: blending
            });
            return this;
        };
        LensFlare.prototype.updateLensFlares = function () {
            var f, fl = this.lensFlares.length;
            var flare;
            var vecX = -this.positionScreen.x * 2;
            var vecY = -this.positionScreen.y * 2;
            for (f = 0; f < fl; f++) {
                flare = this.lensFlares[f];
                flare.x = this.positionScreen.x + vecX * flare.distance;
                flare.y = this.positionScreen.y + vecY * flare.distance;
                flare.wantedRotation = flare.x * THREE.Math.PI * 0.25;
                flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;
            }
        };
        return LensFlare;
    }(THREE.Object3D));
    THREE.LensFlare = LensFlare;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var LOD = (function (_super) {
        __extends(LOD, _super);
        function LOD() {
            _super.call(this);
            this._level = [];
            this.type = 'LOD';
        }
        ;
        Object.defineProperty(LOD.prototype, "levels", {
            get: function () {
                return this._level;
            },
            enumerable: true,
            configurable: true
        });
        LOD.prototype.copy = function (source) {
            _super.prototype.copy.call(this, source, false);
            var levels = source.levels;
            for (var i = 0, l = levels.length; i < l; i++) {
                var level = levels[i];
                this.addLevel(level.object.clone(), level.distance);
            }
            return this;
        };
        LOD.prototype.addLevel = function (object, distance) {
            if (distance === undefined)
                distance = 0;
            distance = THREE.Math.abs(distance);
            var levels = this.levels;
            for (var l = 0; l < levels.length; l++) {
                if (distance < levels[l].distance) {
                    break;
                }
            }
            levels.splice(l, 0, { distance: distance, object: object });
            this.add(object);
        };
        LOD.prototype.getObjectForDistance = function (distance) {
            var levels = this.levels;
            for (var i = 1, l = levels.length; i < l; i++) {
                if (distance < levels[i].distance) {
                    break;
                }
            }
            return levels[i - 1].object;
        };
        LOD.prototype.raycast = function (raycaster, intersects) {
            var matrixPosition = LOD.raycast_matrixPosition;
            matrixPosition.setFromMatrixPosition(this.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(matrixPosition);
            this.getObjectForDistance(distance).raycast(raycaster, intersects);
        };
        LOD.prototype.update = function (camera) {
            var v1 = LOD.update_v1;
            var v2 = LOD.update_v2;
            var levels = this.levels;
            if (levels.length > 1) {
                v1.setFromMatrixPosition(camera.matrixWorld);
                v2.setFromMatrixPosition(this.matrixWorld);
                var distance = v1.distanceTo(v2);
                levels[0].object.visible = true;
                for (var i = 1, l = levels.length; i < l; i++) {
                    if (distance >= levels[i].distance) {
                        levels[i - 1].object.visible = false;
                        levels[i].object.visible = true;
                    }
                    else {
                        break;
                    }
                }
                for (; i < l; i++) {
                    levels[i].object.visible = false;
                }
            }
        };
        LOD.prototype.toJSON = function (meta) {
            var data = _super.prototype.toJSON.call(this, meta);
            data.object.levels = [];
            var levels = this.levels;
            for (var i = 0, l = levels.length; i < l; i++) {
                var level = levels[i];
                data.object.levels.push({
                    object: level.object.uuid,
                    distance: level.distance
                });
            }
            return data;
        };
        LOD.raycast_matrixPosition = new THREE.Vector3();
        LOD.update_v1 = new THREE.Vector3();
        LOD.update_v2 = new THREE.Vector3();
        return LOD;
    }(THREE.Object3D));
    THREE.LOD = LOD;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Points = (function (_super) {
        __extends(Points, _super);
        function Points(geometry, material) {
            _super.call(this);
            this.type = 'Points';
            this.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();
            this.material = material !== undefined ? material : new THREE.PointsMaterial({ color: THREE.Math.random() * 0xffffff });
        }
        ;
        Points.prototype.raycast = function (raycaster, intersects) {
            var inverseMatrix = Points.raycast_inverseMatrix;
            var ray = Points.raycast_ray;
            var sphere = Points.raycast_sphere;
            var object = this;
            var geometry = this.geometry;
            var matrixWorld = this.matrixWorld;
            var threshold = raycaster.params.Points.threshold;
            if (geometry.boundingSphere === null)
                geometry.computeBoundingSphere();
            sphere.copy(geometry.boundingSphere);
            sphere.applyMatrix4(matrixWorld);
            if (raycaster.ray.intersectsSphere(sphere) === false)
                return;
            inverseMatrix.getInverse(matrixWorld);
            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
            var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
            var localThresholdSq = localThreshold * localThreshold;
            var position = new THREE.Vector3();
            function testPoint(point, index) {
                var rayPointDistanceSq = ray.distanceSqToPoint(point);
                if (rayPointDistanceSq < localThresholdSq) {
                    var intersectPoint = ray.closestPointToPoint(point);
                    intersectPoint.applyMatrix4(matrixWorld);
                    var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                    if (distance < raycaster.near || distance > raycaster.far)
                        return;
                    intersects.push({
                        distance: distance,
                        distanceToRay: THREE.Math.sqrt(rayPointDistanceSq),
                        point: intersectPoint.clone(),
                        index: index,
                        face: null,
                        object: object
                    });
                }
            }
            if (geometry instanceof THREE.BufferGeometry) {
                var index = geometry.index;
                var attributes = geometry.attributes;
                var positions = attributes.position.array;
                if (index !== null) {
                    var indices = index.array;
                    for (var i = 0, il = indices.length; i < il; i++) {
                        var a = indices[i];
                        position.fromArray(positions, a * 3);
                        testPoint(position, a);
                    }
                }
                else {
                    for (var i = 0, l = positions.length / 3; i < l; i++) {
                        position.fromArray(positions, i * 3);
                        testPoint(position, i);
                    }
                }
            }
            else {
                var vertices = geometry.vertices;
                for (var i = 0, l = vertices.length; i < l; i++) {
                    testPoint(vertices[i], i);
                }
            }
        };
        Points.prototype.clone = function () {
            return new this.constructor(this.geometry, this.material).copy(this);
        };
        Points.raycast_inverseMatrix = new THREE.Matrix4();
        Points.raycast_ray = new THREE.Ray();
        Points.raycast_sphere = new THREE.Sphere();
        return Points;
    }(THREE.Object3D));
    THREE.Points = Points;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Skeleton = (function () {
        function Skeleton(bones, boneInverses, useVertexTexture) {
            this.identityMatrix = new THREE.Matrix4();
            this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
            this.identityMatrix = new THREE.Matrix4();
            bones = bones || [];
            this.bones = bones.slice(0);
            if (this.useVertexTexture) {
                var size = THREE.Math.sqrt(this.bones.length * 4);
                size = THREE.Math.nextPowerOfTwo(THREE.Math.ceil(size));
                size = THREE.Math.max(size, 4);
                this.boneTextureWidth = size;
                this.boneTextureHeight = size;
                this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4);
                this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType);
            }
            else {
                this.boneMatrices = new Float32Array(16 * this.bones.length);
            }
            if (boneInverses === undefined) {
                this.calculateInverses();
            }
            else {
                if (this.bones.length === boneInverses.length) {
                    this.boneInverses = boneInverses.slice(0);
                }
                else {
                    console.warn('THREE.Skeleton bonInverses is the wrong length.');
                    this.boneInverses = [];
                    for (var b = 0, bl = this.bones.length; b < bl; b++) {
                        this.boneInverses.push(new THREE.Matrix4());
                    }
                }
            }
        }
        ;
        Skeleton.prototype.calculateInverses = function () {
            this.boneInverses = [];
            for (var b = 0, bl = this.bones.length; b < bl; b++) {
                var inverse = new THREE.Matrix4();
                if (this.bones[b]) {
                    inverse.getInverse(this.bones[b].matrixWorld);
                }
                this.boneInverses.push(inverse);
            }
        };
        Skeleton.prototype.pose = function () {
            var bone;
            for (var b = 0, bl = this.bones.length; b < bl; b++) {
                bone = this.bones[b];
                if (bone) {
                    bone.matrixWorld.getInverse(this.boneInverses[b]);
                }
            }
            for (var b = 0, bl = this.bones.length; b < bl; b++) {
                bone = this.bones[b];
                if (bone) {
                    if (bone.parent instanceof THREE.Bone) {
                        bone.matrix.getInverse(bone.parent.matrixWorld);
                        bone.matrix.multiply(bone.matrixWorld);
                    }
                    else {
                        bone.matrix.copy(bone.matrixWorld);
                    }
                    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
                }
            }
        };
        Skeleton.prototype.update = function () {
            var offsetMatrix = Skeleton.update_offsetMatrix;
            for (var b = 0, bl = this.bones.length; b < bl; b++) {
                var matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
                offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]);
                offsetMatrix.toArray(this.boneMatrices, b * 16);
            }
            if (this.useVertexTexture) {
                this.boneTexture.needsUpdate = true;
            }
        };
        Skeleton.prototype.clone = function () {
            return new Skeleton(this.bones, this.boneInverses, this.useVertexTexture);
        };
        Skeleton.update_offsetMatrix = new THREE.Matrix4();
        return Skeleton;
    }());
    THREE.Skeleton = Skeleton;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var SkinnedMesh = (function (_super) {
        __extends(SkinnedMesh, _super);
        function SkinnedMesh(geometry, material, useVertexTexture) {
            _super.call(this, geometry, material);
            this.type = 'SkinnedMesh';
            this.bindMode = "attached";
            this.bindMatrix = new THREE.Matrix4();
            this.bindMatrixInverse = new THREE.Matrix4();
            var bones = [];
            if (this.geometry && this.geometry["bones"] !== undefined) {
                var gbones = this.geometry["bones"];
                var bone, gbone;
                for (var b = 0, bl = gbones.length; b < bl; ++b) {
                    gbone = gbones[b];
                    bone = new THREE.Bone(this);
                    bones.push(bone);
                    bone.name = gbone.name;
                    bone.position.fromArray(gbone.pos);
                    bone.quaternion.fromArray(gbone.rotq);
                    if (gbone.scl !== undefined)
                        bone.scale.fromArray(gbone.scl);
                }
                for (var b = 0, bl = gbones.length; b < bl; ++b) {
                    gbone = gbones[b];
                    if (gbone.parent !== -1 && gbone.parent !== null &&
                        bones[gbone.parent] !== undefined) {
                        bones[gbone.parent].add(bones[b]);
                    }
                    else {
                        this.add(bones[b]);
                    }
                }
            }
            this.normalizeSkinWeights();
            this.updateMatrixWorld(true);
            this.bind(new THREE.Skeleton(bones, undefined, useVertexTexture), this.matrixWorld);
        }
        ;
        SkinnedMesh.prototype.bind = function (skeleton, bindMatrix) {
            this.skeleton = skeleton;
            if (bindMatrix === undefined) {
                this.updateMatrixWorld(true);
                this.skeleton.calculateInverses();
                bindMatrix = this.matrixWorld;
            }
            this.bindMatrix.copy(bindMatrix);
            this.bindMatrixInverse.getInverse(bindMatrix);
        };
        SkinnedMesh.prototype.pose = function () {
            this.skeleton.pose();
        };
        SkinnedMesh.prototype.normalizeSkinWeights = function () {
            var geometry = this.geometry;
            if (geometry instanceof THREE.Geometry) {
                for (var i = 0; i < geometry.skinWeights.length; i++) {
                    var sw = geometry.skinWeights[i];
                    var scale = 1.0 / sw.lengthManhattan();
                    if (scale !== Infinity) {
                        sw.multiplyScalar(scale);
                    }
                    else {
                        sw.set(1, 0, 0, 0);
                    }
                }
            }
            else if (geometry instanceof THREE.BufferGeometry) {
                var vec = new THREE.Vector4();
                var skinWeight = geometry.attributes.skinWeight;
                for (var i = 0; i < skinWeight.count; i++) {
                    vec.x = skinWeight.getX(i);
                    vec.y = skinWeight.getY(i);
                    vec.z = skinWeight.getZ(i);
                    vec.w = skinWeight.getW(i);
                    var scale = 1.0 / vec.lengthManhattan();
                    if (scale !== Infinity) {
                        vec.multiplyScalar(scale);
                    }
                    else {
                        vec.set(1, 0, 0, 0);
                    }
                    skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w);
                }
            }
        };
        SkinnedMesh.prototype.updateMatrixWorld = function (force) {
            _super.prototype.updateMatrixWorld.call(this, true);
            if (this.bindMode === "attached") {
                this.bindMatrixInverse.getInverse(this.matrixWorld);
            }
            else if (this.bindMode === "detached") {
                this.bindMatrixInverse.getInverse(this.bindMatrix);
            }
            else {
                console.warn('THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode);
            }
        };
        SkinnedMesh.prototype.clone = function () {
            return new this.constructor(this.geometry, this.material, this.skeleton.useVertexTexture).copy(this);
        };
        return SkinnedMesh;
    }(THREE.Mesh));
    THREE.SkinnedMesh = SkinnedMesh;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Sprite = (function (_super) {
        __extends(Sprite, _super);
        function Sprite(material) {
            _super.call(this);
            this.type = 'Sprite';
            this.material = (material !== undefined) ? material : new THREE.SpriteMaterial();
        }
        ;
        Sprite.prototype.raycast = function (raycaster, intersects) {
            var matrixPosition = Sprite.raycast_matrixPosition;
            matrixPosition.setFromMatrixPosition(this.matrixWorld);
            var distanceSq = raycaster.ray.distanceSqToPoint(matrixPosition);
            var guessSizeSq = this.scale.x * this.scale.y / 4;
            if (distanceSq > guessSizeSq) {
                return;
            }
            intersects.push({
                distance: THREE.Math.sqrt(distanceSq),
                point: this.position,
                face: null,
                object: this
            });
        };
        Sprite.prototype.clone = function () {
            return new this.constructor(this.material).copy(this);
        };
        Sprite.raycast_matrixPosition = new THREE.Vector3();
        return Sprite;
    }(THREE.Object3D));
    THREE.Sprite = Sprite;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    THREE.ShaderChunk = {};
    THREE.ShaderChunk['alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
    THREE.ShaderChunk['alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif\n";
    THREE.ShaderChunk['alphatest_fragment'] = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
    THREE.ShaderChunk['aomap_fragment'] = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif\n";
    THREE.ShaderChunk['aomap_pars_fragment'] = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
    THREE.ShaderChunk['begin_vertex'] = "\nvec3 transformed = vec3( position );\n";
    THREE.ShaderChunk['beginnormal_vertex'] = "\nvec3 objectNormal = vec3( normal );\n";
    THREE.ShaderChunk['bsdfs'] = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n	return any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n		if( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n			float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n			float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n			return distanceFalloff * maxDistanceCutoffFactor;\n#else\n			return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n		}\n		return 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n	return specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
    THREE.ShaderChunk['bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif\n";
    THREE.ShaderChunk['clipping_planes_fragment'] = "#if NUM_CLIPPING_PLANES > 0\n	for ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n		vec4 plane = clippingPlanes[ i ];\n		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n	}\n#endif\n";
    THREE.ShaderChunk['clipping_planes_pars_fragment'] = "#if NUM_CLIPPING_PLANES > 0\n	#if ! defined( PHYSICAL ) && ! defined( PHONG )\n		varying vec3 vViewPosition;\n	#endif\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";
    THREE.ShaderChunk['clipping_planes_pars_vertex'] = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	varying vec3 vViewPosition;\n#endif\n";
    THREE.ShaderChunk['clipping_planes_vertex'] = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	vViewPosition = - mvPosition.xyz;\n#endif\n";
    THREE.ShaderChunk['color_fragment'] = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";
    THREE.ShaderChunk['color_pars_fragment'] = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif\n";
    THREE.ShaderChunk['color_pars_vertex'] = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
    THREE.ShaderChunk['color_vertex'] = "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif";
    THREE.ShaderChunk['common'] = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n";
    THREE.ShaderChunk['cube_uv_reflection_fragment'] = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n	vec3 absDirection = abs(direction);\n	int face = -1;\n	if( absDirection.x > absDirection.z ) {\n		if(absDirection.x > absDirection.y )\n			face = direction.x > 0.0 ? 0 : 3;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	else {\n		if(absDirection.z > absDirection.y )\n			face = direction.z > 0.0 ? 2 : 5;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	return face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n	float dxRoughness = dFdx(roughness);\n	float dyRoughness = dFdy(roughness);\n	vec3 dx = dFdx( vec * scale * dxRoughness );\n	vec3 dy = dFdy( vec * scale * dyRoughness );\n	float d = max( dot( dx, dx ), dot( dy, dy ) );\n	d = clamp(d, 1.0, cubeUV_rangeClamp);\n	float mipLevel = 0.5 * log2(d);\n	return vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n	float a = 16.0 * cubeUV_rcpTextureSize;\n	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n	float powScale = exp2_packed.x * exp2_packed.y;\n	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n	bool bRes = mipLevel == 0.0;\n	scale =  bRes && (scale < a) ? a : scale;\n	vec3 r;\n	vec2 offset;\n	int face = getFaceFromDirection(direction);\n	float rcpPowScale = 1.0 / powScale;\n	if( face == 0) {\n		r = vec3(direction.x, -direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 1) {\n		r = vec3(direction.y, direction.x, direction.z);\n		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 2) {\n		r = vec3(direction.z, direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 3) {\n		r = vec3(direction.x, direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	else if( face == 4) {\n		r = vec3(direction.y, direction.x, -direction.z);\n		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	else {\n		r = vec3(direction.z, -direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	r = normalize(r);\n	float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n	vec2 base = offset + vec2( texelOffset );\n	return base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n	float roughnessVal = roughness* cubeUV_maxLods3;\n	float r1 = floor(roughnessVal);\n	float r2 = r1 + 1.0;\n	float t = fract(roughnessVal);\n	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n	float s = mipInfo.y;\n	float level0 = mipInfo.x;\n	float level1 = level0 + 1.0;\n	level1 = level1 > 5.0 ? 5.0 : level1;\n	level0 += min( floor( s + 0.5 ), 5.0 );\n	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n	vec4 result = mix(color10, color20, t);\n	return vec4(result.rgb, 1.0);\n}\n#endif\n";
    THREE.ShaderChunk['defaultnormal_vertex'] = "#ifdef FLIP_SIDED\n	objectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
    THREE.ShaderChunk['displacementmap_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
    THREE.ShaderChunk['displacementmap_pars_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif\n";
    THREE.ShaderChunk['emissivemap_fragment'] = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";
    THREE.ShaderChunk['emissivemap_pars_fragment'] = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif\n";
    THREE.ShaderChunk['encodings_pars_fragment'] = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n";
    THREE.ShaderChunk['encodings_fragment'] = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
    THREE.ShaderChunk['envmap_fragment'] = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n	envColor = envMapTexelToLinear( envColor );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif\n";
    THREE.ShaderChunk['envmap_pars_fragment'] = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n	uniform float reflectivity;\n	uniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n		varying vec3 vWorldPosition;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif\n";
    THREE.ShaderChunk['envmap_pars_vertex'] = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif\n";
    THREE.ShaderChunk['envmap_vertex'] = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif\n";
    THREE.ShaderChunk['fog_fragment'] = "#ifdef USE_FOG\n	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	#ifdef FOG_EXP2\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";
    THREE.ShaderChunk['fog_pars_fragment'] = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
    THREE.ShaderChunk['lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
    THREE.ShaderChunk['lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
    THREE.ShaderChunk['lights_lambert_vertex'] = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif\n";
    THREE.ShaderChunk['lights_pars'] = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		if ( testLightInRange( lightDistance, pointLight.distance ) ) {\n			directLight.color = pointLight.color;\n			directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		#include <normal_flip>\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		#include <normal_flip>\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n			sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif\n";
    THREE.ShaderChunk['lights_phong_fragment'] = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
    THREE.ShaderChunk['lights_phong_pars_fragment'] = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)\n";
    THREE.ShaderChunk['lights_physical_fragment'] = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
    THREE.ShaderChunk['lights_physical_pars_fragment'] = "struct PhysicalMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n	#ifndef STANDARD\n		float clearCoat;\n		float clearCoatRoughness;\n	#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifndef STANDARD\n		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n	#else\n		float clearCoatDHR = 0.0;\n	#endif\n	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	#ifndef STANDARD\n		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	#ifndef STANDARD\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		float dotNL = dotNV;\n		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n	#else\n		float clearCoatDHR = 0.0;\n	#endif\n	reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n	#ifndef STANDARD\n		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";
    THREE.ShaderChunk['lights_template'] = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef USE_LIGHTMAP\n		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n	 	irradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n	#endif\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n	#ifndef STANDARD\n		vec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n	#else\n		vec3 clearCoatRadiance = vec3( 0.0 );\n	#endif\n		\n	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";
    THREE.ShaderChunk['logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";
    THREE.ShaderChunk['logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n	uniform float logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n#endif\n";
    THREE.ShaderChunk['logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n	uniform float logDepthBufFC;\n#endif";
    THREE.ShaderChunk['logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n	#endif\n#endif\n";
    THREE.ShaderChunk['map_fragment'] = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif\n";
    THREE.ShaderChunk['map_pars_fragment'] = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n";
    THREE.ShaderChunk['map_particle_fragment'] = "#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";
    THREE.ShaderChunk['map_particle_pars_fragment'] = "#ifdef USE_MAP\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n#endif\n";
    THREE.ShaderChunk['metalnessmap_fragment'] = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.r;\n#endif\n";
    THREE.ShaderChunk['metalnessmap_pars_fragment'] = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
    THREE.ShaderChunk['morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
    THREE.ShaderChunk['morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
    THREE.ShaderChunk['morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif\n";
    THREE.ShaderChunk['normal_flip'] = "#ifdef DOUBLE_SIDED\n	float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n	float flipNormal = 1.0;\n#endif\n";
    THREE.ShaderChunk['normal_fragment'] = "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
    THREE.ShaderChunk['normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n	}\n#endif\n";
    THREE.ShaderChunk['packing'] = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
    THREE.ShaderChunk['premultiplied_alpha_fragment'] = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";
    THREE.ShaderChunk['project_vertex'] = "#ifdef USE_SKINNING\n	vec4 mvPosition = modelViewMatrix * skinned;\n#else\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";
    THREE.ShaderChunk['roughnessmap_fragment'] = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.r;\n#endif\n";
    THREE.ShaderChunk['roughnessmap_pars_fragment'] = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
    THREE.ShaderChunk['shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return 1.0;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		vec3 bd3D = normalize( lightToPosition );\n		float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif\n";
    THREE.ShaderChunk['shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif\n";
    THREE.ShaderChunk['shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif\n";
    THREE.ShaderChunk['shadowmask_pars_fragment'] = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}\n";
    THREE.ShaderChunk['skinbase_vertex'] = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
    THREE.ShaderChunk['skinning_pars_vertex'] = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif\n";
    THREE.ShaderChunk['skinning_vertex'] = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n#endif\n";
    THREE.ShaderChunk['skinnormal_vertex'] = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
    THREE.ShaderChunk['specularmap_fragment'] = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
    THREE.ShaderChunk['specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
    THREE.ShaderChunk['tonemapping_fragment'] = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";
    THREE.ShaderChunk['tonemapping_pars_fragment'] = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";
    THREE.ShaderChunk['uv2_pars_fragment'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
    THREE.ShaderChunk['uv2_pars_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif";
    THREE.ShaderChunk['uv2_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif";
    THREE.ShaderChunk['uv_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n#endif";
    THREE.ShaderChunk['uv_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n#endif\n";
    THREE.ShaderChunk['uv_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";
    THREE.ShaderChunk['worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n	#ifdef USE_SKINNING\n		vec4 worldPosition = modelMatrix * skinned;\n	#else\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n	#endif\n#endif\n";
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Texture = (function (_super) {
        __extends(Texture, _super);
        function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
            _super.call(this);
            this._id = THREE.TextureIdCount++;
            this.uuid = THREE.Math.generateUUID();
            this.name = '';
            this.sourceFile = '';
            this.mipmaps = [];
            this.offset = new THREE.Vector2(0, 0);
            this.repeat = new THREE.Vector2(1, 1);
            this.generateMipmaps = true;
            this.premultiplyAlpha = false;
            this.flipY = true;
            this.unpackAlignment = 4;
            this.version = 0;
            this.onUpdate = null;
            this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
            this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
            this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
            this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
            this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
            this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;
            this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
            this.format = format !== undefined ? format : THREE.RGBAFormat;
            this.type = type !== undefined ? type : THREE.UnsignedByteType;
            this.encoding = encoding !== undefined ? encoding : THREE.LinearEncoding;
        }
        Object.defineProperty(Texture.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(Texture.prototype, "needsUpdate", {
            set: function (value) {
                if (value === true)
                    this.version++;
            },
            enumerable: true,
            configurable: true
        });
        Texture.prototype.clone = function () {
            return new this.constructor().copy(this);
        };
        Texture.prototype.copy = function (source) {
            this.image = source.image;
            this.mipmaps = source.mipmaps.slice(0);
            this.mapping = source.mapping;
            this.wrapS = source.wrapS;
            this.wrapT = source.wrapT;
            this.magFilter = source.magFilter;
            this.minFilter = source.minFilter;
            this.anisotropy = source.anisotropy;
            this.format = source.format;
            this.type = source.type;
            this.offset.copy(source.offset);
            this.repeat.copy(source.repeat);
            this.generateMipmaps = source.generateMipmaps;
            this.premultiplyAlpha = source.premultiplyAlpha;
            this.flipY = source.flipY;
            this.unpackAlignment = source.unpackAlignment;
            this.encoding = source.encoding;
            return this;
        };
        Texture.prototype.toJSON = function (meta) {
            if (meta.textures[this.uuid] !== undefined) {
                return meta.textures[this.uuid];
            }
            function getDataURL(image) {
                var canvas;
                if (image.toDataURL !== undefined) {
                    canvas = image;
                }
                else {
                    canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                    canvas.width = image.width;
                    canvas.height = image.height;
                    canvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height);
                }
                if (canvas.width > 2048 || canvas.height > 2048) {
                    return canvas.toDataURL('image/jpeg', 0.6);
                }
                else {
                    return canvas.toDataURL('image/png');
                }
            }
            var output = {
                metadata: {
                    version: 4.4,
                    type: 'Texture',
                    generator: 'Texture.toJSON'
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                wrap: [this.wrapS, this.wrapT],
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (this.image !== undefined) {
                var image = this.image;
                if (image.uuid === undefined) {
                    image.uuid = THREE.Math.generateUUID();
                }
                if (meta.images[image.uuid] === undefined) {
                    meta.images[image.uuid] = {
                        uuid: image.uuid,
                        url: getDataURL(image)
                    };
                }
                output.image = image.uuid;
            }
            meta.textures[this.uuid] = output;
            return output;
        };
        Texture.prototype.dispose = function () {
            this.dispatchEvent({ type: 'dispose' });
        };
        Texture.prototype.transformUv = function (uv) {
            if (this.mapping !== THREE.UVMapping)
                return;
            uv.multiply(this.repeat);
            uv.add(this.offset);
            if (uv.x < 0 || uv.x > 1) {
                switch (this.wrapS) {
                    case THREE.RepeatWrapping:
                        uv.x = uv.x - THREE.Math.floor(uv.x);
                        break;
                    case THREE.ClampToEdgeWrapping:
                        uv.x = uv.x < 0 ? 0 : 1;
                        break;
                    case THREE.MirroredRepeatWrapping:
                        if (THREE.Math.abs(THREE.Math.floor(uv.x) % 2) === 1) {
                            uv.x = THREE.Math.ceil(uv.x) - uv.x;
                        }
                        else {
                            uv.x = uv.x - THREE.Math.floor(uv.x);
                        }
                        break;
                }
            }
            if (uv.y < 0 || uv.y > 1) {
                switch (this.wrapT) {
                    case THREE.RepeatWrapping:
                        uv.y = uv.y - THREE.Math.floor(uv.y);
                        break;
                    case THREE.ClampToEdgeWrapping:
                        uv.y = uv.y < 0 ? 0 : 1;
                        break;
                    case THREE.MirroredRepeatWrapping:
                        if (THREE.Math.abs(THREE.Math.floor(uv.y) % 2) === 1) {
                            uv.y = THREE.Math.ceil(uv.y) - uv.y;
                        }
                        else {
                            uv.y = uv.y - THREE.Math.floor(uv.y);
                        }
                        break;
                }
            }
            if (this.flipY) {
                uv.y = 1 - uv.y;
            }
        };
        Texture.DEFAULT_IMAGE = undefined;
        Texture.DEFAULT_MAPPING = THREE.UVMapping;
        return Texture;
    }(THREE.EventDispatcher));
    THREE.Texture = Texture;
    THREE.TextureIdCount = 0;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    THREE.UniformsUtils = {
        merge: function (uniforms) {
            var merged = {};
            for (var u = 0; u < uniforms.length; u++) {
                var tmp = this.clone(uniforms[u]);
                for (var p in tmp) {
                    merged[p] = tmp[p];
                }
            }
            return merged;
        },
        clone: function (uniforms_src) {
            var uniforms_dst = {};
            for (var u in uniforms_src) {
                uniforms_dst[u] = {};
                for (var p in uniforms_src[u]) {
                    var parameter_src = uniforms_src[u][p];
                    if (parameter_src instanceof THREE.Color ||
                        parameter_src instanceof THREE.Vector2 ||
                        parameter_src instanceof THREE.Vector3 ||
                        parameter_src instanceof THREE.Vector4 ||
                        parameter_src instanceof THREE.Matrix3 ||
                        parameter_src instanceof THREE.Matrix4 ||
                        parameter_src instanceof THREE.Texture) {
                        uniforms_dst[u][p] = parameter_src.clone();
                    }
                    else if (Array.isArray(parameter_src)) {
                        uniforms_dst[u][p] = parameter_src.slice();
                    }
                    else {
                        uniforms_dst[u][p] = parameter_src;
                    }
                }
            }
            return uniforms_dst;
        }
    };
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    THREE.UniformsLib = {
        common: {
            "diffuse": { value: new THREE.Color(0xeeeeee) },
            "opacity": { value: 1.0 },
            "map": { value: null },
            "offsetRepeat": { value: new THREE.Vector4(0, 0, 1, 1) },
            "specularMap": { value: null },
            "alphaMap": { value: null },
            "envMap": { value: null },
            "flipEnvMap": { value: -1 },
            "reflectivity": { value: 1.0 },
            "refractionRatio": { value: 0.98 }
        },
        aomap: {
            "aoMap": { value: null },
            "aoMapIntensity": { value: 1 }
        },
        lightmap: {
            "lightMap": { value: null },
            "lightMapIntensity": { value: 1 }
        },
        emissivemap: {
            "emissiveMap": { value: null }
        },
        bumpmap: {
            "bumpMap": { value: null },
            "bumpScale": { value: 1 }
        },
        normalmap: {
            "normalMap": { value: null },
            "normalScale": { value: new THREE.Vector2(1, 1) }
        },
        displacementmap: {
            "displacementMap": { value: null },
            "displacementScale": { value: 1 },
            "displacementBias": { value: 0 }
        },
        roughnessmap: {
            "roughnessMap": { value: null }
        },
        metalnessmap: {
            "metalnessMap": { value: null }
        },
        fog: {
            "fogDensity": { value: 0.00025 },
            "fogNear": { value: 1 },
            "fogFar": { value: 2000 },
            "fogColor": { value: new THREE.Color(0xffffff) }
        },
        lights: {
            "ambientLightColor": { value: [] },
            "directionalLights": {
                value: [], properties: {
                    "direction": {},
                    "color": {},
                    "shadow": {},
                    "shadowBias": {},
                    "shadowRadius": {},
                    "shadowMapSize": {}
                }
            },
            "directionalShadowMap": { value: [] },
            "directionalShadowMatrix": { value: [] },
            "spotLights": {
                value: [], properties: {
                    "color": {},
                    "position": {},
                    "direction": {},
                    "distance": {},
                    "coneCos": {},
                    "penumbraCos": {},
                    "decay": {},
                    "shadow": {},
                    "shadowBias": {},
                    "shadowRadius": {},
                    "shadowMapSize": {}
                }
            },
            "spotShadowMap": { value: [] },
            "spotShadowMatrix": { value: [] },
            "pointLights": {
                value: [], properties: {
                    "color": {},
                    "position": {},
                    "decay": {},
                    "distance": {},
                    "shadow": {},
                    "shadowBias": {},
                    "shadowRadius": {},
                    "shadowMapSize": {}
                }
            },
            "pointShadowMap": { value: [] },
            "pointShadowMatrix": { value: [] },
            "hemisphereLights": {
                value: [], properties: {
                    "direction": {},
                    "skyColor": {},
                    "groundColor": {}
                }
            }
        },
        points: {
            "diffuse": { value: new THREE.Color(0xeeeeee) },
            "opacity": { value: 1.0 },
            "size": { value: 1.0 },
            "scale": { value: 1.0 },
            "map": { value: null },
            "offsetRepeat": { value: new THREE.Vector4(0, 0, 1, 1) }
        }
    };
    THREE.ShaderChunk['cube_frag'] = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n	gl_FragColor.a *= opacity;\n}\n";
    THREE.ShaderChunk['cube_vert'] = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}\n";
    THREE.ShaderChunk['depth_frag'] = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n	#endif\n}\n";
    THREE.ShaderChunk['depth_vert'] = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";
    THREE.ShaderChunk['distanceRGBA_frag'] = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	gl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";
    THREE.ShaderChunk['distanceRGBA_vert'] = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition;\n}\n";
    THREE.ShaderChunk['equirect_frag'] = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldPosition );\n	vec2 sampleUV;\n	sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";
    THREE.ShaderChunk['equirect_vert'] = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}\n";
    THREE.ShaderChunk['linedashed_frag'] = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
    THREE.ShaderChunk['linedashed_vert'] = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";
    THREE.ShaderChunk['meshbasic_frag'] = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight;\n	reflectedLight.directDiffuse = vec3( 0.0 );\n	reflectedLight.directSpecular = vec3( 0.0 );\n	reflectedLight.indirectDiffuse = diffuseColor.rgb;\n	reflectedLight.indirectSpecular = vec3( 0.0 );\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <normal_flip>\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
    THREE.ShaderChunk['meshbasic_vert'] = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n}\n";
    THREE.ShaderChunk['meshlambert_frag'] = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <normal_flip>\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
    THREE.ShaderChunk['meshlambert_vert'] = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n}\n";
    THREE.ShaderChunk['meshphong_frag'] = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_flip>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
    THREE.ShaderChunk['meshphong_vert'] = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n}\n";
    THREE.ShaderChunk['meshphysical_frag'] = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n	uniform float clearCoat;\n	uniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_flip>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
    THREE.ShaderChunk['meshphysical_vert'] = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n";
    THREE.ShaderChunk['normal_frag'] = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	gl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n	#include <logdepthbuf_fragment>\n}\n";
    THREE.ShaderChunk['normal_vert'] = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vNormal = normalize( normalMatrix * normal );\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";
    THREE.ShaderChunk['points_frag'] = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
    THREE.ShaderChunk['points_vert'] = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <project_vertex>\n	#ifdef USE_SIZEATTENUATION\n		gl_PointSize = size * ( scale / - mvPosition.z );\n	#else\n		gl_PointSize = size;\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n";
    THREE.ShaderChunk['shadow_frag'] = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n";
    THREE.ShaderChunk['shadow_vert'] = "#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n";
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    THREE.ShaderLib = {
        'basic': {
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib['common'],
                THREE.UniformsLib['aomap'],
                THREE.UniformsLib['fog']
            ]),
            vertexShader: THREE.ShaderChunk['meshbasic_vert'],
            fragmentShader: THREE.ShaderChunk['meshbasic_frag']
        },
        'lambert': {
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib['common'],
                THREE.UniformsLib['aomap'],
                THREE.UniformsLib['lightmap'],
                THREE.UniformsLib['emissivemap'],
                THREE.UniformsLib['fog'],
                THREE.UniformsLib['lights'],
                {
                    "emissive": { value: new THREE.Color(0x000000) }
                }
            ]),
            vertexShader: THREE.ShaderChunk['meshlambert_vert'],
            fragmentShader: THREE.ShaderChunk['meshlambert_frag']
        },
        'phong': {
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib['common'],
                THREE.UniformsLib['aomap'],
                THREE.UniformsLib['lightmap'],
                THREE.UniformsLib['emissivemap'],
                THREE.UniformsLib['bumpmap'],
                THREE.UniformsLib['normalmap'],
                THREE.UniformsLib['displacementmap'],
                THREE.UniformsLib['fog'],
                THREE.UniformsLib['lights'],
                {
                    "emissive": { value: new THREE.Color(0x000000) },
                    "specular": { value: new THREE.Color(0x111111) },
                    "shininess": { value: 30 }
                }
            ]),
            vertexShader: THREE.ShaderChunk['meshphong_vert'],
            fragmentShader: THREE.ShaderChunk['meshphong_frag']
        },
        'standard': {
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib['common'],
                THREE.UniformsLib['aomap'],
                THREE.UniformsLib['lightmap'],
                THREE.UniformsLib['emissivemap'],
                THREE.UniformsLib['bumpmap'],
                THREE.UniformsLib['normalmap'],
                THREE.UniformsLib['displacementmap'],
                THREE.UniformsLib['roughnessmap'],
                THREE.UniformsLib['metalnessmap'],
                THREE.UniformsLib['fog'],
                THREE.UniformsLib['lights'],
                {
                    "emissive": { value: new THREE.Color(0x000000) },
                    "roughness": { value: 0.5 },
                    "metalness": { value: 0 },
                    "envMapIntensity": { value: 1 },
                }
            ]),
            vertexShader: THREE.ShaderChunk['meshphysical_vert'],
            fragmentShader: THREE.ShaderChunk['meshphysical_frag']
        },
        'points': {
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib['points'],
                THREE.UniformsLib['fog']
            ]),
            vertexShader: THREE.ShaderChunk['points_vert'],
            fragmentShader: THREE.ShaderChunk['points_frag']
        },
        'dashed': {
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib['common'],
                THREE.UniformsLib['fog'],
                {
                    "scale": { value: 1 },
                    "dashSize": { value: 1 },
                    "totalSize": { value: 2 }
                }
            ]),
            vertexShader: THREE.ShaderChunk['linedashed_vert'],
            fragmentShader: THREE.ShaderChunk['linedashed_frag']
        },
        'depth': {
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib['common'],
                THREE.UniformsLib['displacementmap']
            ]),
            vertexShader: THREE.ShaderChunk['depth_vert'],
            fragmentShader: THREE.ShaderChunk['depth_frag']
        },
        'normal': {
            uniforms: {
                "opacity": { value: 1.0 }
            },
            vertexShader: THREE.ShaderChunk['normal_vert'],
            fragmentShader: THREE.ShaderChunk['normal_frag']
        },
        'cube': {
            uniforms: {
                "tCube": { value: null },
                "tFlip": { value: -1 },
                "opacity": { value: 1.0 }
            },
            vertexShader: THREE.ShaderChunk['cube_vert'],
            fragmentShader: THREE.ShaderChunk['cube_frag']
        },
        'equirect': {
            uniforms: {
                "tEquirect": { value: null },
                "tFlip": { value: -1 }
            },
            vertexShader: THREE.ShaderChunk['equirect_vert'],
            fragmentShader: THREE.ShaderChunk['equirect_frag']
        },
        'distanceRGBA': {
            uniforms: {
                "lightPos": { value: new THREE.Vector3() }
            },
            vertexShader: THREE.ShaderChunk['distanceRGBA_vert'],
            fragmentShader: THREE.ShaderChunk['distanceRGBA_frag']
        }
    };
    THREE.ShaderLib['physical'] = {
        uniforms: THREE.UniformsUtils.merge([
            THREE.ShaderLib['standard'].uniforms,
            {
                "clearCoat": { value: 0 },
                "clearCoatRoughness": { value: 0 }
            }
        ]),
        vertexShader: THREE.ShaderChunk['meshphysical_vert'],
        fragmentShader: THREE.ShaderChunk['meshphysical_frag']
    };
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    function paramThreeToGL(renderer, p) {
        var _gl = renderer.context;
        var extensions = renderer.extensions;
        var extension;
        if (p === THREE.RepeatWrapping)
            return _gl.REPEAT;
        if (p === THREE.ClampToEdgeWrapping)
            return _gl.CLAMP_TO_EDGE;
        if (p === THREE.MirroredRepeatWrapping)
            return _gl.MIRRORED_REPEAT;
        if (p === THREE.NearestFilter)
            return _gl.NEAREST;
        if (p === THREE.NearestMipMapNearestFilter)
            return _gl.NEAREST_MIPMAP_NEAREST;
        if (p === THREE.NearestMipMapLinearFilter)
            return _gl.NEAREST_MIPMAP_LINEAR;
        if (p === THREE.LinearFilter)
            return _gl.LINEAR;
        if (p === THREE.LinearMipMapNearestFilter)
            return _gl.LINEAR_MIPMAP_NEAREST;
        if (p === THREE.LinearMipMapLinearFilter)
            return _gl.LINEAR_MIPMAP_LINEAR;
        if (p === THREE.UnsignedByteType)
            return _gl.UNSIGNED_BYTE;
        if (p === THREE.UnsignedShort4444Type)
            return _gl.UNSIGNED_SHORT_4_4_4_4;
        if (p === THREE.UnsignedShort5551Type)
            return _gl.UNSIGNED_SHORT_5_5_5_1;
        if (p === THREE.UnsignedShort565Type)
            return _gl.UNSIGNED_SHORT_5_6_5;
        if (p === THREE.ByteType)
            return _gl.BYTE;
        if (p === THREE.ShortType)
            return _gl.SHORT;
        if (p === THREE.UnsignedShortType)
            return _gl.UNSIGNED_SHORT;
        if (p === THREE.IntType)
            return _gl.INT;
        if (p === THREE.UnsignedIntType)
            return _gl.UNSIGNED_INT;
        if (p === THREE.FloatType)
            return _gl.FLOAT;
        extension = extensions.get('OES_texture_half_float');
        if (extension !== null) {
            if (p === THREE.HalfFloatType)
                return extension.HALF_FLOAT_OES;
        }
        if (p === THREE.AlphaFormat)
            return _gl.ALPHA;
        if (p === THREE.RGBFormat)
            return _gl.RGB;
        if (p === THREE.RGBAFormat)
            return _gl.RGBA;
        if (p === THREE.LuminanceFormat)
            return _gl.LUMINANCE;
        if (p === THREE.LuminanceAlphaFormat)
            return _gl.LUMINANCE_ALPHA;
        if (p === THREE.DepthFormat)
            return _gl.DEPTH_COMPONENT;
        if (p === THREE.AddEquation)
            return _gl.FUNC_ADD;
        if (p === THREE.SubtractEquation)
            return _gl.FUNC_SUBTRACT;
        if (p === THREE.ReverseSubtractEquation)
            return _gl.FUNC_REVERSE_SUBTRACT;
        if (p === THREE.ZeroFactor)
            return _gl.ZERO;
        if (p === THREE.OneFactor)
            return _gl.ONE;
        if (p === THREE.SrcColorFactor)
            return _gl.SRC_COLOR;
        if (p === THREE.OneMinusSrcColorFactor)
            return _gl.ONE_MINUS_SRC_COLOR;
        if (p === THREE.SrcAlphaFactor)
            return _gl.SRC_ALPHA;
        if (p === THREE.OneMinusSrcAlphaFactor)
            return _gl.ONE_MINUS_SRC_ALPHA;
        if (p === THREE.DstAlphaFactor)
            return _gl.DST_ALPHA;
        if (p === THREE.OneMinusDstAlphaFactor)
            return _gl.ONE_MINUS_DST_ALPHA;
        if (p === THREE.DstColorFactor)
            return _gl.DST_COLOR;
        if (p === THREE.OneMinusDstColorFactor)
            return _gl.ONE_MINUS_DST_COLOR;
        if (p === THREE.SrcAlphaSaturateFactor)
            return _gl.SRC_ALPHA_SATURATE;
        extension = extensions.get('WEBGL_compressed_texture_s3tc');
        if (extension !== null) {
            if (p === THREE.RGB_S3TC_DXT1_Format)
                return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (p === THREE.RGBA_S3TC_DXT1_Format)
                return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (p === THREE.RGBA_S3TC_DXT3_Format)
                return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (p === THREE.RGBA_S3TC_DXT5_Format)
                return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        extension = extensions.get('WEBGL_compressed_texture_pvrtc');
        if (extension !== null) {
            if (p === THREE.RGB_PVRTC_4BPPV1_Format)
                return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (p === THREE.RGB_PVRTC_2BPPV1_Format)
                return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (p === THREE.RGBA_PVRTC_4BPPV1_Format)
                return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (p === THREE.RGBA_PVRTC_2BPPV1_Format)
                return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        extension = extensions.get('WEBGL_compressed_texture_etc1');
        if (extension !== null) {
            if (p === THREE.RGB_ETC1_Format)
                return extension.COMPRESSED_RGB_ETC1_WEBGL;
        }
        extension = extensions.get('EXT_blend_minmax');
        if (extension !== null) {
            if (p === THREE.MinEquation)
                return extension.MIN_EXT;
            if (p === THREE.MaxEquation)
                return extension.MAX_EXT;
        }
        return 0;
    }
    THREE.paramThreeToGL = paramThreeToGL;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    function readRenderTargetPixels(renderer, renderTarget, x, y, width, height, buffer) {
        var _gl = renderer.context;
        var properties = renderer.properties;
        var extensions = renderer.extensions;
        if (renderTarget instanceof THREE.WebGLRenderTarget === false) {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
            return;
        }
        var framebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (framebuffer) {
            var restore = false;
            if (framebuffer !== renderer._currentFramebuffer) {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                restore = true;
            }
            try {
                var texture = renderTarget.texture;
                if (texture.format !== THREE.RGBAFormat
                    && THREE.paramThreeToGL(renderer, texture.format) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                    return;
                }
                if (texture.type !== THREE.UnsignedByteType &&
                    THREE.paramThreeToGL(this, texture.type) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) &&
                    !(texture.type === THREE.FloatType && extensions.get('WEBGL_color_buffer_float')) &&
                    !(texture.type === THREE.HalfFloatType && extensions.get('EXT_color_buffer_half_float'))) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                    return;
                }
                if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
                    if ((x >= 0 && x <= (renderTarget.width - width)) && (y >= 0 && y <= (renderTarget.height - height))) {
                        _gl.readPixels(x, y, width, height, THREE.paramThreeToGL(renderer, texture.format), THREE.paramThreeToGL(renderer, texture.type), buffer);
                    }
                }
                else {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
                }
            }
            finally {
                if (restore) {
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderer._currentFramebuffer);
                }
            }
        }
    }
    THREE.readRenderTargetPixels = readRenderTargetPixels;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WebGLRenderer = (function () {
        function WebGLRenderer(parameters) {
            var _this = this;
            console.log('THREE.WebGLRenderer', THREE.REVISION);
            parameters = this.parameters = parameters || {};
            var _canvas = this._canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            var _context = this._context = parameters.context !== undefined ? parameters.context : null;
            this._alpha = parameters.alpha !== undefined ? parameters.alpha : false;
            this._depth = parameters.depth !== undefined ? parameters.depth : true;
            this._stencil = parameters.stencil !== undefined ? parameters.stencil : true;
            this._antialias = parameters.antialias !== undefined ? parameters.antialias : false;
            this._premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true;
            this._preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
            this.lights = [];
            this.opaqueObjects = [];
            this.opaqueObjectsLastIndex = -1;
            this.transparentObjects = [];
            this.transparentObjectsLastIndex = -1;
            this.morphInfluences = new Float32Array(8);
            this.sprites = [];
            this.lensFlares = [];
            this.domElement = _canvas;
            this.context = null;
            this.autoClear = true;
            this.autoClearColor = true;
            this.autoClearDepth = true;
            this.autoClearStencil = true;
            this.sortObjects = true;
            this.clippingPlanes = [];
            this.localClippingEnabled = false;
            this.gammaFactor = 2.0;
            this.gammaInput = false;
            this.gammaOutput = false;
            this.physicallyCorrectLights = false;
            this.toneMapping = THREE.LinearToneMapping;
            this.toneMappingExposure = 1.0;
            this.toneMappingWhitePoint = 1.0;
            this.maxMorphTargets = 8;
            this.maxMorphNormals = 4;
            this._currentProgram = null;
            this._currentRenderTarget = null;
            this._currentFramebuffer = null;
            this._currentMaterialId = -1;
            this._currentGeometryProgram = '';
            this._currentCamera = null;
            this._currentScissor = new THREE.Vector4();
            this._currentScissorTest = null;
            this._currentViewport = new THREE.Vector4();
            this._usedTextureUnits = 0;
            this._clearColor = new THREE.Color(0x000000);
            this._clearAlpha = 0;
            this._width = _canvas.width;
            this._height = _canvas.height;
            var _pixelRatio = this._pixelRatio = 1;
            var _scissor = this._scissor = new THREE.Vector4(0, 0, this._width, this._height);
            var _scissorTest = this._scissorTest = false;
            var _viewport = this._viewport = new THREE.Vector4(0, 0, this._width, this._height);
            this._frustum = new THREE.Frustum();
            this._clipping = new THREE.WebGLClipping();
            this._clippingEnabled = false;
            this._localClippingEnabled = false;
            this._sphere = new THREE.Sphere();
            this._projScreenMatrix = new THREE.Matrix4();
            this._vector3 = new THREE.Vector3();
            this._lights = {
                hash: '',
                ambient: [0, 0, 0],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                shadows: []
            };
            this._infoRender = {
                calls: 0,
                vertices: 0,
                faces: 0,
                points: 0
            };
            this.info = {
                render: this._infoRender,
                memory: {
                    geometries: 0,
                    textures: 0
                },
                programs: null
            };
            this.init_context();
            this.init_extensions();
            this.capabilities = new THREE.WebGLCapabilities(this.context, this.extensions, parameters);
            this.state = new THREE.WebGLState(this);
            this.properties = new THREE.WebGLProperties();
            this.textures = new THREE.WebGLTextures(this);
            this.objects = new THREE.WebGLObjects(this.context, this.properties, this.info);
            this.programCache = new THREE.WebGLPrograms(this, this.capabilities);
            this.lightCache = new THREE.WebGLLights();
            this.info.programs = this.programCache.programs;
            this.bufferRenderer = new THREE.WebGLBufferRenderer(this.context, this.extensions, this._infoRender);
            this.indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer(this.context, this.extensions, this._infoRender);
            this.backgroundCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            this.backgroundCamera2 = new THREE.PerspectiveCamera();
            this.backgroundPlaneMesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), new THREE.MeshBasicMaterial({ depthTest: false, depthWrite: false, fog: false }));
            this.backgroundBoxShader = THREE.ShaderLib['cube'];
            this.backgroundBoxMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(5, 5, 5), new THREE.ShaderMaterial({
                uniforms: this.backgroundBoxShader.uniforms,
                vertexShader: this.backgroundBoxShader.vertexShader,
                fragmentShader: this.backgroundBoxShader.fragmentShader,
                side: THREE.BackSide,
                depthTest: false,
                depthWrite: false
            }));
            this.objects.update(this.backgroundPlaneMesh);
            this.objects.update(this.backgroundBoxMesh);
            this.setDefaultGLState();
            this.shadowMap = new THREE.WebGLShadowMap(this, this._lights, this.objects, this.capabilities);
            this.spritePlugin = new THREE.SpritePlugin(this);
            this.lensFlarePlugin = new THREE.LensFlarePlugin(this);
            this.onContextLost_ = function (event) {
                _this.onContextLost(event);
            };
            this.onMaterialDispose_ = function (event) {
                _this.onContextLost(event);
            };
        }
        WebGLRenderer.prototype.init_context = function () {
            var _gl;
            try {
                var attributes = {
                    alpha: this._alpha,
                    depth: this._depth,
                    stencil: this._stencil,
                    antialias: this._antialias,
                    premultipliedAlpha: this._premultipliedAlpha,
                    preserveDrawingBuffer: this._preserveDrawingBuffer
                };
                _gl = this._context
                    || this._canvas.getContext('webgl', attributes)
                    || this._canvas.getContext('experimental-webgl', attributes);
                if (_gl === null) {
                    if (this._canvas.getContext('webgl') !== null) {
                        throw 'Error creating WebGL context with your selected attributes.';
                    }
                    else {
                        throw 'Error creating WebGL context.';
                    }
                }
                if (_gl.getShaderPrecisionFormat === undefined) {
                    _gl.getShaderPrecisionFormat = function () {
                        return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
                    };
                }
                this._canvas.addEventListener('webglcontextlost', this.onContextLost_, false);
                this.context = _gl;
            }
            catch (error) {
                console.error('THREE.WebGLRenderer: ' + error);
            }
        };
        WebGLRenderer.prototype.init_extensions = function () {
            var extensions = new THREE.WebGLExtensions(this.context);
            extensions.get('WEBGL_depth_texture');
            extensions.get('OES_texture_float');
            extensions.get('OES_texture_float_linear');
            extensions.get('OES_texture_half_float');
            extensions.get('OES_texture_half_float_linear');
            extensions.get('OES_standard_derivatives');
            extensions.get('ANGLE_instanced_arrays');
            if (extensions.get('OES_element_index_uint')) {
                THREE.BufferGeometry.MaxIndex = 4294967296;
            }
            this.extensions = extensions;
        };
        WebGLRenderer.prototype.getTargetPixelRatio = function () {
            return this._currentRenderTarget === null ? this._pixelRatio : 1;
        };
        WebGLRenderer.prototype.getContext = function () {
            return this.context;
        };
        ;
        WebGLRenderer.prototype.glClearColor = function (r, g, b, a) {
            if (this._premultipliedAlpha === true) {
                r *= a;
                g *= a;
                b *= a;
            }
            this.state.clearColor(r, g, b, a);
        };
        WebGLRenderer.prototype.setDefaultGLState = function () {
            var _clearColor = this._clearColor;
            this.state.init();
            this.state.scissor(this._currentScissor.copy(this._scissor).multiplyScalar(this._pixelRatio));
            this.state.viewport(this._currentViewport.copy(this._viewport).multiplyScalar(this._pixelRatio));
            this.glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, this._clearAlpha);
        };
        WebGLRenderer.prototype.resetGLState = function () {
            this._currentProgram = null;
            this._currentCamera = null;
            this._currentGeometryProgram = '';
            this._currentMaterialId = -1;
            this.state.reset();
        };
        WebGLRenderer.prototype.getContextAttributes = function () {
            return this.context.getContextAttributes();
        };
        ;
        WebGLRenderer.prototype.forceContextLoss = function () {
            this.extensions.get('WEBGL_lose_context').loseContext();
        };
        ;
        WebGLRenderer.prototype.getMaxAnisotropy = function () {
            return this.capabilities.getMaxAnisotropy();
        };
        ;
        WebGLRenderer.prototype.getPrecision = function () {
            return this.capabilities.precision;
        };
        ;
        WebGLRenderer.prototype.getPixelRatio = function () {
            return this._pixelRatio;
        };
        WebGLRenderer.prototype.setPixelRatio = function (value) {
            if (value === undefined)
                return;
            this._pixelRatio = value;
            this.setSize(this._viewport.z, this._viewport.w, false);
        };
        WebGLRenderer.prototype.getSize = function () {
            return {
                width: this._width,
                height: this._height
            };
        };
        WebGLRenderer.prototype.setSize = function (width, height, updateStyle) {
            this._width = width;
            this._height = height;
            this._canvas.width = width * this._pixelRatio;
            this._canvas.height = height * this._pixelRatio;
            if (updateStyle !== false) {
                this._canvas.style.width = width + 'px';
                this._canvas.style.height = height + 'px';
            }
            this.setViewport(0, 0, width, height);
        };
        WebGLRenderer.prototype.setViewport = function (x, y, width, height) {
            this.state.viewport(this._viewport.set(x, y, width, height));
        };
        ;
        WebGLRenderer.prototype.setScissor = function (x, y, width, height) {
            this.state.scissor(this._scissor.set(x, y, width, height));
        };
        ;
        WebGLRenderer.prototype.setScissorTest = function (boolean) {
            this.state.setScissorTest(this._scissorTest = boolean);
        };
        WebGLRenderer.prototype.getClearColor = function () {
            return this._clearColor;
        };
        WebGLRenderer.prototype.setClearColor = function (color, alpha) {
            this._clearColor.set(color);
            this._clearAlpha = alpha !== undefined ? alpha : 1;
            this.glClearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
        };
        ;
        WebGLRenderer.prototype.getClearAlpha = function () {
            return this._clearAlpha;
        };
        ;
        WebGLRenderer.prototype.setClearAlpha = function (alpha) {
            var _clearColor = this._clearColor;
            this._clearAlpha = alpha;
            this.glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, this._clearAlpha);
        };
        ;
        WebGLRenderer.prototype.clear = function (color, depth, stencil) {
            var bits = 0;
            var _gl = this.context;
            if (color === undefined || color)
                bits |= _gl.COLOR_BUFFER_BIT;
            if (depth === undefined || depth)
                bits |= _gl.DEPTH_BUFFER_BIT;
            if (stencil === undefined || stencil)
                bits |= _gl.STENCIL_BUFFER_BIT;
            _gl.clear(bits);
        };
        WebGLRenderer.prototype.clearColor = function () {
            this.clear(true, false, false);
        };
        WebGLRenderer.prototype.clearDepth = function () {
            this.clear(false, true, false);
        };
        WebGLRenderer.prototype.clearStencil = function () {
            this.clear(false, false, true);
        };
        WebGLRenderer.prototype.clearTarget = function (renderTarget, color, depth, stencil) {
            this.setRenderTarget(renderTarget);
            this.clear(color, depth, stencil);
        };
        WebGLRenderer.prototype.dispose = function () {
            this.transparentObjects = [];
            this.transparentObjectsLastIndex = -1;
            this.opaqueObjects = [];
            this.opaqueObjectsLastIndex = -1;
            this._canvas.removeEventListener('webglcontextlost', this.onContextLost_, false);
        };
        ;
        WebGLRenderer.prototype.onContextLost = function (event) {
            event.preventDefault();
            this.resetGLState();
            this.setDefaultGLState();
            this.properties.clear();
        };
        WebGLRenderer.prototype.onMaterialDispose = function (event) {
            var material = event.target;
            material.removeEventListener('dispose', this.onMaterialDispose_);
            this.deallocateMaterial(material);
        };
        WebGLRenderer.prototype.deallocateMaterial = function (material) {
            this.releaseMaterialProgramReference(material);
            this.properties.delete(material);
        };
        WebGLRenderer.prototype.releaseMaterialProgramReference = function (material) {
            var programInfo = this.properties.get(material).program;
            material.program = undefined;
            if (programInfo !== undefined) {
                this.programCache.releaseProgram(programInfo);
            }
        };
        WebGLRenderer.prototype.renderBufferImmediate = function (object, program, material) {
            var state = this.state;
            var properties = this.properties;
            var _gl = this.context;
            state.initAttributes();
            var buffers = properties.get(object);
            if (object.hasPositions && !buffers.position)
                buffers.position = _gl.createBuffer();
            if (object.hasNormals && !buffers.normal)
                buffers.normal = _gl.createBuffer();
            if (object.hasUvs && !buffers.uv)
                buffers.uv = _gl.createBuffer();
            if (object.hasColors && !buffers.color)
                buffers.color = _gl.createBuffer();
            var attributes;
            attributes = program.getAttributes();
            if (object.hasPositions) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(attributes.position);
                _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
            }
            if (object.hasNormals) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
                if (material.type !== 'MeshPhongMaterial'
                    && material.type !== 'MeshStandardMaterial'
                    && material.type !== 'MeshPhysicalMaterial'
                    && material.shading === THREE.FlatShading) {
                    for (var i = 0, l = object.count * 3; i < l; i += 9) {
                        var array = object.normalArray;
                        var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
                        var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
                        var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
                        array[i + 0] = nx;
                        array[i + 1] = ny;
                        array[i + 2] = nz;
                        array[i + 3] = nx;
                        array[i + 4] = ny;
                        array[i + 5] = nz;
                        array[i + 6] = nx;
                        array[i + 7] = ny;
                        array[i + 8] = nz;
                    }
                }
                _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(attributes.normal);
                _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, false, 0, 0);
            }
            if (object.hasUvs && material.map) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(attributes.uv);
                _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);
            }
            if (object.hasColors && material.vertexColors !== THREE.NoColors) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(attributes.color);
                _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, false, 0, 0);
            }
            state.disableUnusedAttributes();
            _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
            object.count = 0;
        };
        WebGLRenderer.prototype.renderBufferDirect = function (camera, fog, geometry, material, object, group) {
            var _gl = this.context;
            this.setMaterial(material);
            var program = this.setProgram(camera, fog, material, object);
            var updateBuffers = false;
            var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;
            if (geometryProgram !== this._currentGeometryProgram) {
                this._currentGeometryProgram = geometryProgram;
                updateBuffers = true;
            }
            var morphTargetInfluences = object.morphTargetInfluences;
            if (morphTargetInfluences !== undefined) {
                var activeInfluences = [];
                for (var i_5 = 0, l_3 = morphTargetInfluences.length; i_5 < l_3; i_5++) {
                    var influence = morphTargetInfluences[i_5];
                    activeInfluences.push([influence, i_5]);
                }
                activeInfluences.sort(this.absNumericalSort);
                if (activeInfluences.length > 8) {
                    activeInfluences.length = 8;
                }
                var morphAttributes = geometry.morphAttributes;
                for (var i = 0, l = activeInfluences.length; i < l; i++) {
                    var influence_1 = activeInfluences[i];
                    this.morphInfluences[i] = influence_1[0];
                    if (influence_1[0] !== 0) {
                        var index_1 = influence_1[1];
                        if (material.morphTargets === true && morphAttributes.position)
                            geometry.addAttribute('morphTarget' + i, morphAttributes.position[index_1]);
                        if (material.morphNormals === true && morphAttributes.normal)
                            geometry.addAttribute('morphNormal' + i, morphAttributes.normal[index_1]);
                    }
                    else {
                        if (material.morphTargets === true)
                            geometry.removeAttribute('morphTarget' + i);
                        if (material.morphNormals === true)
                            geometry.removeAttribute('morphNormal' + i);
                    }
                }
                program.getUniforms().setValue(_gl, 'morphTargetInfluences', this.morphInfluences);
                updateBuffers = true;
            }
            var index = geometry.index;
            var position = geometry.attributes.position;
            if (material.wireframe === true) {
                index = this.objects.getWireframeAttribute(geometry);
            }
            var renderer;
            if (index !== null) {
                renderer = this.indexedBufferRenderer;
                renderer.setIndex(index);
            }
            else {
                renderer = this.bufferRenderer;
            }
            if (updateBuffers) {
                this.setupVertexAttributes(material, program, geometry);
                if (index !== null) {
                    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, this.objects.getAttributeBuffer(index));
                }
            }
            var dataStart = 0;
            var dataCount = Infinity;
            if (index !== null) {
                dataCount = index.count;
            }
            else if (position !== undefined) {
                dataCount = position.count;
            }
            var rangeStart = geometry.drawRange.start;
            var rangeCount = geometry.drawRange.count;
            var groupStart = group !== null ? group.start : 0;
            var groupCount = group !== null ? group.count : Infinity;
            var drawStart = THREE.Math.max(dataStart, rangeStart, groupStart);
            var drawEnd = THREE.Math.min(dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
            var drawCount = THREE.Math.max(0, drawEnd - drawStart + 1);
            if (object instanceof THREE.Mesh) {
                if (material.wireframe === true) {
                    this.state.setLineWidth(material.wireframeLinewidth * this.getTargetPixelRatio());
                    renderer.setMode(_gl.LINES);
                }
                else {
                    switch (object.drawMode) {
                        case THREE.TrianglesDrawMode:
                            renderer.setMode(_gl.TRIANGLES);
                            break;
                        case THREE.TriangleStripDrawMode:
                            renderer.setMode(_gl.TRIANGLE_STRIP);
                            break;
                        case THREE.TriangleFanDrawMode:
                            renderer.setMode(_gl.TRIANGLE_FAN);
                            break;
                    }
                }
            }
            else if (object instanceof THREE.Line) {
                var lineWidth = material.linewidth;
                if (lineWidth === undefined)
                    lineWidth = 1;
                this.state.setLineWidth(lineWidth * this.getTargetPixelRatio());
                if (object instanceof THREE.LineSegments) {
                    renderer.setMode(_gl.LINES);
                }
                else {
                    renderer.setMode(_gl.LINE_STRIP);
                }
            }
            else if (object instanceof THREE.Points) {
                renderer.setMode(_gl.POINTS);
            }
            if (geometry instanceof THREE.InstancedBufferGeometry) {
                if (geometry.maxInstancedCount > 0) {
                    renderer.renderInstances(geometry, drawStart, drawCount);
                }
            }
            else {
                renderer.render(drawStart, drawCount);
            }
        };
        ;
        WebGLRenderer.prototype.setupVertexAttributes = function (material, program, geometry, startIndex) {
            var state = this.state;
            var _gl = this.context;
            var objects = this.objects;
            var extension;
            if (geometry instanceof THREE.InstancedBufferGeometry) {
                extension = this.extensions.get('ANGLE_instanced_arrays');
                if (extension === null) {
                    console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                    return;
                }
            }
            if (startIndex === undefined)
                startIndex = 0;
            state.initAttributes();
            var geometryAttributes = geometry.attributes;
            var programAttributes = program.getAttributes();
            var materialDefaultAttributeValues = material.defaultAttributeValues;
            for (var name in programAttributes) {
                var programAttribute = programAttributes[name];
                if (programAttribute >= 0) {
                    var geometryAttribute = geometryAttributes[name];
                    if (geometryAttribute !== undefined) {
                        var type = _gl.FLOAT;
                        var array = geometryAttribute.array;
                        var normalized = geometryAttribute.normalized;
                        if (array instanceof Float32Array) {
                            type = _gl.FLOAT;
                        }
                        else if (array instanceof Float64Array) {
                            console.warn("Unsupported data buffer format: Float64Array");
                        }
                        else if (array instanceof Uint16Array) {
                            type = _gl.UNSIGNED_SHORT;
                        }
                        else if (array instanceof Int16Array) {
                            type = _gl.SHORT;
                        }
                        else if (array instanceof Uint32Array) {
                            type = _gl.UNSIGNED_INT;
                        }
                        else if (array instanceof Int32Array) {
                            type = _gl.INT;
                        }
                        else if (array instanceof Int8Array) {
                            type = _gl.BYTE;
                        }
                        else if (array instanceof Uint8Array) {
                            type = _gl.UNSIGNED_BYTE;
                        }
                        var size = geometryAttribute.itemSize;
                        var buffer = objects.getAttributeBuffer(geometryAttribute);
                        if (geometryAttribute instanceof THREE.InterleavedBufferAttribute) {
                            var data = geometryAttribute.data;
                            var stride = data.stride;
                            var offset = geometryAttribute.offset;
                            if (data instanceof THREE.InstancedInterleavedBuffer) {
                                state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute, extension);
                                if (geometry.maxInstancedCount === undefined) {
                                    geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                                }
                            }
                            else {
                                state.enableAttribute(programAttribute);
                            }
                            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                            _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, (startIndex * stride + offset) * data.array.BYTES_PER_ELEMENT);
                        }
                        else {
                            if (geometryAttribute instanceof THREE.InstancedBufferAttribute) {
                                state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute, extension);
                                if (geometry.maxInstancedCount === undefined) {
                                    geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                                }
                            }
                            else {
                                state.enableAttribute(programAttribute);
                            }
                            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                            _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT);
                        }
                    }
                    else if (materialDefaultAttributeValues !== undefined) {
                        var value = materialDefaultAttributeValues[name];
                        if (value !== undefined) {
                            switch (value.length) {
                                case 2:
                                    _gl.vertexAttrib2fv(programAttribute, value);
                                    break;
                                case 3:
                                    _gl.vertexAttrib3fv(programAttribute, value);
                                    break;
                                case 4:
                                    _gl.vertexAttrib4fv(programAttribute, value);
                                    break;
                                default:
                                    _gl.vertexAttrib1fv(programAttribute, value);
                            }
                        }
                    }
                }
            }
            state.disableUnusedAttributes();
        };
        WebGLRenderer.prototype.absNumericalSort = function (a, b) {
            return THREE.Math.abs(b[0]) - THREE.Math.abs(a[0]);
        };
        WebGLRenderer.prototype.painterSortStable = function (a, b) {
            if (a.object.renderOrder !== b.object.renderOrder) {
                return a.object.renderOrder - b.object.renderOrder;
            }
            else if (a.material.program && b.material.program && a.material.program !== b.material.program) {
                return a.material.program.id - b.material.program.id;
            }
            else if (a.material.id !== b.material.id) {
                return a.material.id - b.material.id;
            }
            else if (a.z !== b.z) {
                return a.z - b.z;
            }
            else {
                return a.id - b.id;
            }
        };
        WebGLRenderer.prototype.reversePainterSortStable = function (a, b) {
            if (a.object.renderOrder !== b.object.renderOrder) {
                return a.object.renderOrder - b.object.renderOrder;
            }
            if (a.z !== b.z) {
                return b.z - a.z;
            }
            else {
                return a.id - b.id;
            }
        };
        WebGLRenderer.prototype.render = function (scene, camera, renderTarget, forceClear) {
            if (camera instanceof THREE.Camera === false) {
                console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
                return;
            }
            var fog = scene.fog;
            this._currentGeometryProgram = '';
            this._currentMaterialId = -1;
            this._currentCamera = null;
            if (scene.autoUpdate === true)
                scene.updateMatrixWorld();
            if (camera.parent === null)
                camera.updateMatrixWorld();
            camera.matrixWorldInverse.getInverse(camera.matrixWorld);
            this._projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            this._frustum.setFromMatrix(this._projScreenMatrix);
            this.lights.length = 0;
            this.opaqueObjectsLastIndex = -1;
            this.transparentObjectsLastIndex = -1;
            this.sprites.length = 0;
            this.lensFlares.length = 0;
            this._localClippingEnabled = this.localClippingEnabled;
            this._clippingEnabled = this._clipping.init(this.clippingPlanes, this._localClippingEnabled, camera);
            this.projectObject(scene, camera);
            this.opaqueObjects.length = this.opaqueObjectsLastIndex + 1;
            this.transparentObjects.length = this.transparentObjectsLastIndex + 1;
            if (this.sortObjects === true) {
                this.opaqueObjects.sort(this.painterSortStable);
                this.transparentObjects.sort(this.reversePainterSortStable);
            }
            if (this._clippingEnabled)
                this._clipping.beginShadows();
            this.setupShadows(this.lights);
            this.shadowMap.render(scene, camera);
            this.setupLights(this.lights, camera);
            if (this._clippingEnabled)
                this._clipping.endShadows();
            this._infoRender.calls = 0;
            this._infoRender.vertices = 0;
            this._infoRender.faces = 0;
            this._infoRender.points = 0;
            if (renderTarget === undefined) {
                renderTarget = null;
            }
            this.setRenderTarget(renderTarget);
            var background = scene.background;
            if (background === null) {
                this.glClearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
            }
            else if (background instanceof THREE.Color) {
                this.glClearColor(background.r, background.g, background.b, 1);
            }
            if (this.autoClear || forceClear) {
                this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
            }
            if (background instanceof THREE.CubeTexture) {
                this.backgroundCamera2.projectionMatrix.copy(camera.projectionMatrix);
                this.backgroundCamera2.matrixWorld.extractRotation(camera.matrixWorld);
                this.backgroundCamera2.matrixWorldInverse.getInverse(this.backgroundCamera2.matrixWorld);
                this.backgroundBoxMesh.material.uniforms["tCube"].value = background;
                this.backgroundBoxMesh.modelViewMatrix.multiplyMatrices(this.backgroundCamera2.matrixWorldInverse, this.backgroundBoxMesh.matrixWorld);
                this.objects.update(this.backgroundBoxMesh);
                this.renderBufferDirect(this.backgroundCamera2, null, this.backgroundBoxMesh.geometry, this.backgroundBoxMesh.material, this.backgroundBoxMesh, null);
            }
            else if (background instanceof THREE.Texture) {
                this.backgroundPlaneMesh.material.map = background;
                this.objects.update(this.backgroundPlaneMesh);
                this.renderBufferDirect(this.backgroundCamera, null, this.backgroundPlaneMesh.geometry, this.backgroundPlaneMesh.material, this.backgroundPlaneMesh, null);
            }
            if (scene.overrideMaterial) {
                var overrideMaterial = scene.overrideMaterial;
                this.renderObjects(this.opaqueObjects, camera, fog, overrideMaterial);
                this.renderObjects(this.transparentObjects, camera, fog, overrideMaterial);
            }
            else {
                this.state.setBlending(THREE.NoBlending);
                this.renderObjects(this.opaqueObjects, camera, fog);
                this.renderObjects(this.transparentObjects, camera, fog);
            }
            this.spritePlugin.render(scene, camera);
            this.lensFlarePlugin.render(scene, camera, this._currentViewport);
            if (renderTarget) {
                this.textures.updateRenderTargetMipmap(renderTarget);
            }
            this.state.setDepthTest(true);
            this.state.setDepthWrite(true);
            this.state.setColorWrite(true);
        };
        WebGLRenderer.prototype.pushRenderItem = function (object, geometry, material, z, group) {
            var array;
            var index;
            if (material.transparent) {
                array = this.transparentObjects;
                index = ++this.transparentObjectsLastIndex;
            }
            else {
                array = this.opaqueObjects;
                index = ++this.opaqueObjectsLastIndex;
            }
            var renderItem = array[index];
            if (renderItem !== undefined) {
                renderItem.id = object.id;
                renderItem.object = object;
                renderItem.geometry = geometry;
                renderItem.material = material;
                renderItem.z = this._vector3.z;
                renderItem.group = group;
            }
            else {
                renderItem = {
                    id: object.id,
                    object: object,
                    geometry: geometry,
                    material: material,
                    z: this._vector3.z,
                    group: group
                };
                array.push(renderItem);
            }
        };
        WebGLRenderer.prototype.isObjectViewable = function (object) {
            var geometry = object.geometry;
            if (geometry.boundingSphere === null)
                geometry.computeBoundingSphere();
            this._sphere.copy(geometry.boundingSphere).
                applyMatrix4(object.matrixWorld);
            return this.isSphereViewable(this._sphere);
        };
        WebGLRenderer.prototype.isSpriteViewable = function (sprite) {
            this._sphere.center.set(0, 0, 0);
            this._sphere.radius = 0.7071067811865476;
            this._sphere.applyMatrix4(sprite.matrixWorld);
            return this.isSphereViewable(this._sphere);
        };
        WebGLRenderer.prototype.isSphereViewable = function (sphere) {
            if (!this._frustum.intersectsSphere(sphere))
                return false;
            var numPlanes = this._clipping.numPlanes;
            if (numPlanes === 0)
                return true;
            var planes = this.clippingPlanes, center = sphere.center, negRad = -sphere.radius, i = 0;
            do {
                if (planes[i].distanceToPoint(center) < negRad)
                    return false;
            } while (++i !== numPlanes);
            return true;
        };
        WebGLRenderer.prototype.projectObject = function (object, camera) {
            var _vector3 = this._vector3;
            if (object.visible === false)
                return;
            if (object.layers.test(camera.layers)) {
                if (object instanceof THREE.Light) {
                    this.lights.push(object);
                }
                else if (object instanceof THREE.Sprite) {
                    if (object.frustumCulled === false || this.isSpriteViewable(object) === true) {
                        this.sprites.push(object);
                    }
                }
                else if (object instanceof THREE.LensFlare) {
                    this.lensFlares.push(object);
                }
                else if (object instanceof THREE.ImmediateRenderObject) {
                    if (this.sortObjects === true) {
                        _vector3.setFromMatrixPosition(object.matrixWorld);
                        _vector3.applyProjection(this._projScreenMatrix);
                    }
                    this.pushRenderItem(object, null, object.material, this._vector3.z, null);
                }
                else if (object instanceof THREE.Mesh
                    || object instanceof THREE.Line
                    || object instanceof THREE.Points) {
                    if (object instanceof THREE.SkinnedMesh) {
                        object.skeleton.update();
                    }
                    if (object.frustumCulled === false
                        || this.isObjectViewable(object) === true) {
                        var material = object.material;
                        if (material.visible === true) {
                            if (this.sortObjects === true) {
                                _vector3.setFromMatrixPosition(object.matrixWorld);
                                _vector3.applyProjection(this._projScreenMatrix);
                            }
                            var geometry = this.objects.update(object);
                            if (material instanceof THREE.MultiMaterial) {
                                var groups = geometry.groups;
                                var materials = material.materials;
                                for (var i = 0, l = groups.length; i < l; i++) {
                                    var group = groups[i];
                                    var groupMaterial = materials[group.materialIndex];
                                    if (groupMaterial.visible === true) {
                                        this.pushRenderItem(object, geometry, groupMaterial, _vector3.z, group);
                                    }
                                }
                            }
                            else {
                                this.pushRenderItem(object, geometry, material, _vector3.z, null);
                            }
                        }
                    }
                }
            }
            var children = object.children;
            for (var i_6 = 0, l_4 = children.length; i_6 < l_4; i_6++) {
                this.projectObject(children[i_6], camera);
            }
        };
        WebGLRenderer.prototype.renderObjects = function (renderList, camera, fog, overrideMaterial) {
            var _this = this;
            for (var i = 0, l = renderList.length; i < l; i++) {
                var renderItem = renderList[i];
                var object = renderItem.object;
                var geometry = renderItem.geometry;
                var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
                var group = renderItem.group;
                object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
                object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
                if (object instanceof THREE.ImmediateRenderObject) {
                    this.setMaterial(material);
                    var program = this.setProgram(camera, fog, material, object);
                    this._currentGeometryProgram = '';
                    object.render(function (object) {
                        _this.renderBufferImmediate(object, program, material);
                    });
                }
                else {
                    this.renderBufferDirect(camera, fog, geometry, material, object, group);
                }
            }
        };
        WebGLRenderer.prototype.initMaterial = function (material, fog, object) {
            var materialProperties = this.properties.get(material);
            var parameters = this.programCache.getParameters(material, this._lights, fog, this._clipping.numPlanes, object);
            var code = this.programCache.getProgramCode(material, parameters);
            var program = materialProperties.program;
            var programChange = true;
            if (program === undefined) {
                material.addEventListener('dispose', this.onMaterialDispose_);
            }
            else if (program.code !== code) {
                this.releaseMaterialProgramReference(material);
            }
            else if (parameters.shaderID !== undefined) {
                return;
            }
            else {
                programChange = false;
            }
            if (programChange) {
                if (parameters.shaderID) {
                    var shader = THREE.ShaderLib[parameters.shaderID];
                    materialProperties.__webglShader = {
                        name: material.type,
                        uniforms: THREE.UniformsUtils.clone(shader.uniforms),
                        vertexShader: shader.vertexShader,
                        fragmentShader: shader.fragmentShader
                    };
                }
                else {
                    materialProperties.__webglShader = {
                        name: material.type,
                        uniforms: material.uniforms,
                        vertexShader: material.vertexShader,
                        fragmentShader: material.fragmentShader
                    };
                }
                material.__webglShader = materialProperties.__webglShader;
                program = this.programCache.acquireProgram(material, parameters, code);
                materialProperties.program = program;
                material.program = program;
            }
            var attributes = program.getAttributes();
            if (material.morphTargets) {
                material.numSupportedMorphTargets = 0;
                for (var i = 0; i < this.maxMorphTargets; i++) {
                    if (attributes['morphTarget' + i] >= 0) {
                        material.numSupportedMorphTargets++;
                    }
                }
            }
            if (material.morphNormals) {
                material.numSupportedMorphNormals = 0;
                for (var i = 0; i < this.maxMorphNormals; i++) {
                    if (attributes['morphNormal' + i] >= 0) {
                        material.numSupportedMorphNormals++;
                    }
                }
            }
            var uniforms = materialProperties.__webglShader.uniforms;
            if (!(material instanceof THREE.ShaderMaterial) &&
                !(material instanceof THREE.RawShaderMaterial) ||
                material.clipping === true) {
                materialProperties.numClippingPlanes = this._clipping.numPlanes;
                uniforms.clippingPlanes = this._clipping.uniform;
            }
            var _lights = this._lights;
            if (material.lights) {
                materialProperties.lightsHash = _lights.hash;
                uniforms.ambientLightColor.value = _lights.ambient;
                uniforms.directionalLights.value = _lights.directional;
                uniforms.spotLights.value = _lights.spot;
                uniforms.pointLights.value = _lights.point;
                uniforms.hemisphereLights.value = _lights.hemi;
                uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
                uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
                uniforms.spotShadowMap.value = _lights.spotShadowMap;
                uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
                uniforms.pointShadowMap.value = _lights.pointShadowMap;
                uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
            }
            var progUniforms = materialProperties.program.getUniforms();
            var uniformsList = THREE.WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
            materialProperties.uniformsList = uniformsList;
            materialProperties.dynamicUniforms = THREE.WebGLUniforms.splitDynamic(uniformsList, uniforms);
        };
        WebGLRenderer.prototype.setMaterial = function (material) {
            var state = this.state;
            var _gl = this.context;
            if (material.side !== THREE.DoubleSide)
                state.enable(_gl.CULL_FACE);
            else
                state.disable(_gl.CULL_FACE);
            state.setFlipSided(material.side === THREE.BackSide);
            if (material.transparent === true) {
                state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
            }
            else {
                state.setBlending(THREE.NoBlending);
            }
            state.setDepthFunc(material.depthFunc);
            state.setDepthTest(material.depthTest);
            state.setDepthWrite(material.depthWrite);
            state.setColorWrite(material.colorWrite);
            state.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        };
        WebGLRenderer.prototype.setProgram = function (camera, fog, material, object) {
            this._usedTextureUnits = 0;
            var _gl = this.context;
            var materialProperties = this.properties.get(material);
            if (this._clippingEnabled) {
                if (this._localClippingEnabled || camera !== this._currentCamera) {
                    var useCache = camera === this._currentCamera &&
                        material.id === this._currentMaterialId;
                    this._clipping.setState(material.clippingPlanes, material.clipShadows, camera, materialProperties, useCache);
                }
                if (materialProperties.numClippingPlanes !== undefined &&
                    materialProperties.numClippingPlanes !== this._clipping.numPlanes) {
                    material.needsUpdate = true;
                }
            }
            if (materialProperties.program === undefined) {
                material.needsUpdate = true;
            }
            if (materialProperties.lightsHash !== undefined &&
                materialProperties.lightsHash !== this._lights.hash) {
                material.needsUpdate = true;
            }
            if (material.needsUpdate) {
                this.initMaterial(material, fog, object);
                material.needsUpdate = false;
            }
            var refreshProgram = false;
            var refreshMaterial = false;
            var refreshLights = false;
            var program = materialProperties.program;
            var p_uniforms = program.getUniforms();
            var m_uniforms = materialProperties.__webglShader.uniforms;
            if (program.id !== this._currentProgram) {
                _gl.useProgram(program.program);
                this._currentProgram = program.id;
                refreshProgram = true;
                refreshMaterial = true;
                refreshLights = true;
            }
            if (material.id !== this._currentMaterialId) {
                this._currentMaterialId = material.id;
                refreshMaterial = true;
            }
            if (refreshProgram || camera !== this._currentCamera) {
                p_uniforms.set(_gl, camera, 'projectionMatrix');
                if (this.capabilities.logarithmicDepthBuffer) {
                    p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (THREE.Math.log(camera.far + 1.0) / THREE.Math.LN2));
                }
                if (camera !== this._currentCamera) {
                    this._currentCamera = camera;
                    refreshMaterial = true;
                    refreshLights = true;
                }
                if (material instanceof THREE.ShaderMaterial ||
                    material instanceof THREE.MeshPhongMaterial ||
                    material instanceof THREE.MeshStandardMaterial ||
                    material.envMap) {
                    var uCamPos = p_uniforms.map.cameraPosition;
                    if (uCamPos !== undefined) {
                        uCamPos.setValue(_gl, this._vector3.setFromMatrixPosition(camera.matrixWorld));
                    }
                }
                if (material instanceof THREE.MeshPhongMaterial ||
                    material instanceof THREE.MeshLambertMaterial ||
                    material instanceof THREE.MeshBasicMaterial ||
                    material instanceof THREE.MeshStandardMaterial ||
                    material instanceof THREE.ShaderMaterial ||
                    material.skinning) {
                    p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
                }
                p_uniforms.set(_gl, this, 'toneMappingExposure');
                p_uniforms.set(_gl, this, 'toneMappingWhitePoint');
            }
            if (material.skinning) {
                p_uniforms.setOptional(_gl, object, 'bindMatrix');
                p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
                var skeleton = object.skeleton;
                if (skeleton) {
                    if (this.capabilities.floatVertexTextures && skeleton.useVertexTexture) {
                        p_uniforms.set(_gl, skeleton, 'boneTexture');
                        p_uniforms.set(_gl, skeleton, 'boneTextureWidth');
                        p_uniforms.set(_gl, skeleton, 'boneTextureHeight');
                    }
                    else {
                        p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
                    }
                }
            }
            if (refreshMaterial) {
                if (material.lights) {
                    this.markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
                }
                if (fog && material.fog) {
                    this.refreshUniformsFog(m_uniforms, fog);
                }
                if (material instanceof THREE.MeshBasicMaterial ||
                    material instanceof THREE.MeshLambertMaterial ||
                    material instanceof THREE.MeshPhongMaterial ||
                    material instanceof THREE.MeshStandardMaterial ||
                    material instanceof THREE.MeshDepthMaterial) {
                    this.refreshUniformsCommon(m_uniforms, material);
                }
                if (material instanceof THREE.LineBasicMaterial) {
                    this.refreshUniformsLine(m_uniforms, material);
                }
                else if (material instanceof THREE.LineDashedMaterial) {
                    this.refreshUniformsLine(m_uniforms, material);
                    this.refreshUniformsDash(m_uniforms, material);
                }
                else if (material instanceof THREE.PointsMaterial) {
                    this.refreshUniformsPoints(m_uniforms, material);
                }
                else if (material instanceof THREE.MeshLambertMaterial) {
                    this.refreshUniformsLambert(m_uniforms, material);
                }
                else if (material instanceof THREE.MeshPhongMaterial) {
                    this.refreshUniformsPhong(m_uniforms, material);
                }
                else if (material instanceof THREE.MeshPhysicalMaterial) {
                    this.refreshUniformsPhysical(m_uniforms, material);
                }
                else if (material instanceof THREE.MeshStandardMaterial) {
                    this.refreshUniformsStandard(m_uniforms, material);
                }
                else if (material instanceof THREE.MeshDepthMaterial) {
                    if (material.displacementMap) {
                        m_uniforms.displacementMap.value = material.displacementMap;
                        m_uniforms.displacementScale.value = material.displacementScale;
                        m_uniforms.displacementBias.value = material.displacementBias;
                    }
                }
                else if (material instanceof THREE.MeshNormalMaterial) {
                    m_uniforms.opacity.value = material.opacity;
                }
                THREE.WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, this);
            }
            p_uniforms.set(_gl, object, 'modelViewMatrix');
            p_uniforms.set(_gl, object, 'normalMatrix');
            p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
            var dynUniforms = materialProperties.dynamicUniforms;
            if (dynUniforms !== null) {
                THREE.WebGLUniforms.evalDynamic(dynUniforms, m_uniforms, object, camera);
                THREE.WebGLUniforms.upload(_gl, dynUniforms, m_uniforms, this);
            }
            return program;
        };
        WebGLRenderer.prototype.refreshUniformsCommon = function (uniforms, material) {
            uniforms.opacity.value = material.opacity;
            uniforms.diffuse.value = material.color;
            if (material.emissive) {
                uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
            }
            uniforms.map.value = material.map;
            uniforms.specularMap.value = material.specularMap;
            uniforms.alphaMap.value = material.alphaMap;
            if (material.aoMap) {
                uniforms.aoMap.value = material.aoMap;
                uniforms.aoMapIntensity.value = material.aoMapIntensity;
            }
            var uvScaleMap;
            if (material.map) {
                uvScaleMap = material.map;
            }
            else if (material.specularMap) {
                uvScaleMap = material.specularMap;
            }
            else if (material.displacementMap) {
                uvScaleMap = material.displacementMap;
            }
            else if (material.normalMap) {
                uvScaleMap = material.normalMap;
            }
            else if (material.bumpMap) {
                uvScaleMap = material.bumpMap;
            }
            else if (material.roughnessMap) {
                uvScaleMap = material.roughnessMap;
            }
            else if (material.metalnessMap) {
                uvScaleMap = material.metalnessMap;
            }
            else if (material.alphaMap) {
                uvScaleMap = material.alphaMap;
            }
            else if (material.emissiveMap) {
                uvScaleMap = material.emissiveMap;
            }
            if (uvScaleMap !== undefined) {
                if (uvScaleMap instanceof THREE.WebGLRenderTarget) {
                    uvScaleMap = uvScaleMap.texture;
                }
                var offset = uvScaleMap.offset;
                var repeat = uvScaleMap.repeat;
                uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
            }
            uniforms.envMap.value = material.envMap;
            uniforms.flipEnvMap.value = (!(material.envMap instanceof THREE.CubeTexture)) ? 1 : -1;
            uniforms.reflectivity.value = material.reflectivity;
            uniforms.refractionRatio.value = material.refractionRatio;
        };
        WebGLRenderer.prototype.refreshUniformsLine = function (uniforms, material) {
            uniforms.diffuse.value = material.color;
            uniforms.opacity.value = material.opacity;
        };
        WebGLRenderer.prototype.refreshUniformsDash = function (uniforms, material) {
            uniforms.dashSize.value = material.dashSize;
            uniforms.totalSize.value = material.dashSize + material.gapSize;
            uniforms.scale.value = material.scale;
        };
        WebGLRenderer.prototype.refreshUniformsPoints = function (uniforms, material) {
            uniforms.diffuse.value = material.color;
            uniforms.opacity.value = material.opacity;
            uniforms.size.value = material.size * this._pixelRatio;
            uniforms.scale.value = this._canvas.clientHeight * 0.5;
            uniforms.map.value = material.map;
            if (material.map !== null) {
                var offset = material.map.offset;
                var repeat = material.map.repeat;
                uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
            }
        };
        WebGLRenderer.prototype.refreshUniformsFog = function (uniforms, fog) {
            uniforms.fogColor.value = fog.color;
            if (fog instanceof THREE.Fog) {
                uniforms.fogNear.value = fog.near;
                uniforms.fogFar.value = fog.far;
            }
            else if (fog instanceof THREE.FogExp2) {
                uniforms.fogDensity.value = fog.density;
            }
        };
        WebGLRenderer.prototype.refreshUniformsLambert = function (uniforms, material) {
            if (material.lightMap) {
                uniforms.lightMap.value = material.lightMap;
                uniforms.lightMapIntensity.value = material.lightMapIntensity;
            }
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
        };
        WebGLRenderer.prototype.refreshUniformsPhong = function (uniforms, material) {
            uniforms.specular.value = material.specular;
            uniforms.shininess.value = THREE.Math.max(material.shininess, 1e-4);
            if (material.lightMap) {
                uniforms.lightMap.value = material.lightMap;
                uniforms.lightMapIntensity.value = material.lightMapIntensity;
            }
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        };
        WebGLRenderer.prototype.refreshUniformsStandard = function (uniforms, material) {
            uniforms.roughness.value = material.roughness;
            uniforms.metalness.value = material.metalness;
            if (material.roughnessMap) {
                uniforms.roughnessMap.value = material.roughnessMap;
            }
            if (material.metalnessMap) {
                uniforms.metalnessMap.value = material.metalnessMap;
            }
            if (material.lightMap) {
                uniforms.lightMap.value = material.lightMap;
                uniforms.lightMapIntensity.value = material.lightMapIntensity;
            }
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
            if (material.envMap) {
                uniforms.envMapIntensity.value = material.envMapIntensity;
            }
        };
        WebGLRenderer.prototype.refreshUniformsPhysical = function (uniforms, material) {
            uniforms.clearCoat.value = material.clearCoat;
            uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
            this.refreshUniformsStandard(uniforms, material);
        };
        WebGLRenderer.prototype.markUniformsLightsNeedsUpdate = function (uniforms, value) {
            uniforms.ambientLightColor.needsUpdate = value;
            uniforms.directionalLights.needsUpdate = value;
            uniforms.pointLights.needsUpdate = value;
            uniforms.spotLights.needsUpdate = value;
            uniforms.hemisphereLights.needsUpdate = value;
        };
        WebGLRenderer.prototype.setupShadows = function (lights) {
            var lightShadowsLength = 0;
            for (var i = 0, l = lights.length; i < l; i++) {
                var light = lights[i];
                if (light.castShadow) {
                    this._lights.shadows[lightShadowsLength++] = light;
                }
            }
            this._lights.shadows.length = lightShadowsLength;
        };
        WebGLRenderer.prototype.setupLights = function (lights, camera) {
            var _lights = this._lights;
            var _vector3 = this._vector3;
            var lightCache = this.lightCache;
            var l, ll;
            var light;
            var r = 0, g = 0, b = 0, color, intensity, distance, shadowMap, viewMatrix = camera.matrixWorldInverse, directionalLength = 0, pointLength = 0, spotLength = 0, hemiLength = 0;
            for (l = 0, ll = lights.length; l < ll; l++) {
                light = lights[l];
                color = light.color;
                intensity = light.intensity;
                distance = light.distance;
                shadowMap = (light.shadow && light.shadow.map) ? light.shadow.map.texture : null;
                if (light instanceof THREE.AmbientLight) {
                    r += color.r * intensity;
                    g += color.g * intensity;
                    b += color.b * intensity;
                }
                else if (light instanceof THREE.DirectionalLight) {
                    var uniforms = lightCache.get(light);
                    uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    _vector3.setFromMatrixPosition(light.target.matrixWorld);
                    uniforms.direction.sub(_vector3);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.shadow = light.castShadow;
                    if (light.castShadow) {
                        uniforms.shadowBias = light.shadow.bias;
                        uniforms.shadowRadius = light.shadow.radius;
                        uniforms.shadowMapSize = light.shadow.mapSize;
                    }
                    _lights.directionalShadowMap[directionalLength] = shadowMap;
                    _lights.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                    _lights.directional[directionalLength++] = uniforms;
                }
                else if (light instanceof THREE.SpotLight) {
                    var uniforms = lightCache.get(light);
                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);
                    uniforms.color.copy(color).multiplyScalar(intensity);
                    uniforms.distance = distance;
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    _vector3.setFromMatrixPosition(light.target.matrixWorld);
                    uniforms.direction.sub(_vector3);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.coneCos = THREE.Math.cos(light.angle);
                    uniforms.penumbraCos = THREE.Math.cos(light.angle * (1 - light.penumbra));
                    uniforms.decay = (light.distance === 0) ? 0.0 : light.decay;
                    uniforms.shadow = light.castShadow;
                    if (light.castShadow) {
                        uniforms.shadowBias = light.shadow.bias;
                        uniforms.shadowRadius = light.shadow.radius;
                        uniforms.shadowMapSize = light.shadow.mapSize;
                    }
                    _lights.spotShadowMap[spotLength] = shadowMap;
                    _lights.spotShadowMatrix[spotLength] = light.shadow.matrix;
                    _lights.spot[spotLength++] = uniforms;
                }
                else if (light instanceof THREE.PointLight) {
                    var uniforms = lightCache.get(light);
                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);
                    uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                    uniforms.distance = light.distance;
                    uniforms.decay = (light.distance === 0) ? 0.0 : light.decay;
                    uniforms.shadow = light.castShadow;
                    if (light.castShadow) {
                        uniforms.shadowBias = light.shadow.bias;
                        uniforms.shadowRadius = light.shadow.radius;
                        uniforms.shadowMapSize = light.shadow.mapSize;
                    }
                    _lights.pointShadowMap[pointLength] = shadowMap;
                    if (_lights.pointShadowMatrix[pointLength] === undefined) {
                        _lights.pointShadowMatrix[pointLength] = new THREE.Matrix4();
                    }
                    _vector3.setFromMatrixPosition(light.matrixWorld).negate();
                    _lights.pointShadowMatrix[pointLength].identity().setPosition(_vector3);
                    _lights.point[pointLength++] = uniforms;
                }
                else if (light instanceof THREE.HemisphereLight) {
                    var uniforms = lightCache.get(light);
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.direction.normalize();
                    uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                    uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                    _lights.hemi[hemiLength++] = uniforms;
                }
            }
            _lights.ambient[0] = r;
            _lights.ambient[1] = g;
            _lights.ambient[2] = b;
            _lights.directional.length = directionalLength;
            _lights.spot.length = spotLength;
            _lights.point.length = pointLength;
            _lights.hemi.length = hemiLength;
            _lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;
        };
        WebGLRenderer.prototype.setFaceCulling = function (cullFace, frontFaceDirection) {
            var state = this.state;
            state.setCullFace(cullFace);
            state.setFlipSided(frontFaceDirection === THREE.FrontFaceDirectionCW);
        };
        ;
        WebGLRenderer.prototype.allocTextureUnit = function () {
            var textureUnit = this._usedTextureUnits;
            if (textureUnit >= this.capabilities.maxTextures) {
                console.warn('WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + this.capabilities.maxTextures);
            }
            this._usedTextureUnits += 1;
            return textureUnit;
        };
        WebGLRenderer.prototype.setTexture2D = function (texture, slot) {
            if (texture instanceof THREE.WebGLRenderTarget) {
                if (!WebGLRenderer.warned) {
                    console.warn("WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");
                    WebGLRenderer.warned = true;
                }
                texture = texture.texture;
            }
            this.textures.setTexture2D(texture, slot);
        };
        WebGLRenderer.prototype.setTextureCube = function (texture, slot) {
            var textures = this.textures;
            if (texture instanceof THREE.WebGLRenderTargetCube) {
                if (!WebGLRenderer.warned_setTextureCube) {
                    console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
                    WebGLRenderer.warned_setTextureCube = true;
                }
                texture = texture.texture;
            }
            if (texture instanceof THREE.CubeTexture ||
                (Array.isArray(texture.image) && texture.image.length === 6)) {
                textures.setTextureCube(texture, slot);
            }
            else {
                textures.setTextureCubeDynamic(texture, slot);
            }
        };
        WebGLRenderer.prototype.getCurrentRenderTarget = function () {
            return this._currentRenderTarget;
        };
        ;
        WebGLRenderer.prototype.setRenderTarget = function (renderTarget) {
            var properties = this.properties;
            var textures = this.textures;
            var _gl = this.context;
            var state = this.state;
            this._currentRenderTarget = renderTarget;
            if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
                textures.setupRenderTarget(renderTarget);
            }
            var isCube = (renderTarget instanceof THREE.WebGLRenderTargetCube);
            var renderTargetCube = isCube
                ? renderTarget
                : null;
            var framebuffer;
            if (renderTarget) {
                var renderTargetProperties = properties.get(renderTarget);
                if (isCube) {
                    framebuffer = renderTargetProperties.__webglFramebuffer[renderTargetCube.activeCubeFace];
                }
                else {
                    framebuffer = renderTargetProperties.__webglFramebuffer;
                }
                this._currentScissor.copy(renderTarget.scissor);
                this._currentScissorTest = renderTarget.scissorTest;
                this._currentViewport.copy(renderTarget.viewport);
            }
            else {
                framebuffer = null;
                this._currentScissor.copy(this._scissor).multiplyScalar(this._pixelRatio);
                this._currentScissorTest = this._scissorTest;
                this._currentViewport.copy(this._viewport).multiplyScalar(this._pixelRatio);
            }
            if (this._currentFramebuffer !== framebuffer) {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                this._currentFramebuffer = framebuffer;
            }
            state.scissor(this._currentScissor);
            state.setScissorTest(this._currentScissorTest);
            state.viewport(this._currentViewport);
            if (isCube) {
                var textureProperties = properties.get(renderTarget.texture);
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTargetCube.activeCubeFace, textureProperties.__webglTexture, renderTargetCube.activeMipMapLevel);
            }
        };
        ;
        WebGLRenderer.prototype.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer) {
            THREE.readRenderTargetPixels(this, renderTarget, x, y, width, height, buffer);
        };
        WebGLRenderer.warned = false;
        WebGLRenderer.warned_setTextureCube = false;
        return WebGLRenderer;
    }());
    THREE.WebGLRenderer = WebGLRenderer;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WebGLRenderTarget = (function (_super) {
        __extends(WebGLRenderTarget, _super);
        function WebGLRenderTarget(width, height, options) {
            _super.call(this);
            this.uuid = THREE.Math.generateUUID();
            this.width = width;
            this.height = height;
            this.scissor = new THREE.Vector4(0, 0, width, height);
            this.scissorTest = false;
            this.viewport = new THREE.Vector4(0, 0, width, height);
            options = options || {};
            if (options.minFilter === undefined)
                options.minFilter = THREE.LinearFilter;
            this.texture = new THREE.Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
            this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
            this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
            this.depthTexture = null;
        }
        ;
        WebGLRenderTarget.prototype.setSize = function (width, height) {
            if (this.width !== width || this.height !== height) {
                this.width = width;
                this.height = height;
                this.dispose();
            }
            this.viewport.set(0, 0, width, height);
            this.scissor.set(0, 0, width, height);
        };
        WebGLRenderTarget.prototype.clone = function () {
            return new this.constructor().copy(this);
        };
        WebGLRenderTarget.prototype.copy = function (source) {
            this.width = source.width;
            this.height = source.height;
            this.viewport.copy(source.viewport);
            this.texture = source.texture.clone();
            this.depthBuffer = source.depthBuffer;
            this.stencilBuffer = source.stencilBuffer;
            this.depthTexture = source.depthTexture;
            return this;
        };
        WebGLRenderTarget.prototype.dispose = function () {
            this.dispatchEvent({ type: 'dispose' });
        };
        return WebGLRenderTarget;
    }(THREE.EventDispatcher));
    THREE.WebGLRenderTarget = WebGLRenderTarget;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WebGLRenderTargetCube = (function (_super) {
        __extends(WebGLRenderTargetCube, _super);
        function WebGLRenderTargetCube(width, height, options) {
            _super.call(this, width, height, options);
            this.activeCubeFace = 0;
            this.activeMipMapLevel = 0;
        }
        ;
        return WebGLRenderTargetCube;
    }(THREE.WebGLRenderTarget));
    THREE.WebGLRenderTargetCube = WebGLRenderTargetCube;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var LensFlarePlugin = (function () {
        function LensFlarePlugin(renderer) {
            this.renderer = renderer;
        }
        LensFlarePlugin.prototype.init = function () {
            var vertices = new Float32Array([
                -1, -1, 0, 0,
                1, -1, 1, 0,
                1, 1, 1, 1,
                -1, 1, 0, 1
            ]);
            var faces = new Uint16Array([
                0, 1, 2,
                0, 2, 3
            ]);
            var gl = this.renderer.context;
            var state = this.renderer.state;
            var vertexBuffer = this.vertexBuffer = gl.createBuffer();
            var elementBuffer = this.elementBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
            var tempTexture = this.tempTexture = gl.createTexture();
            var occlusionTexture = this.occlusionTexture = gl.createTexture();
            state.bindTexture(gl.TEXTURE_2D, tempTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            this.shader = {
                vertexShader: [
                    "uniform lowp int renderType;",
                    "uniform vec3 screenPosition;",
                    "uniform vec2 scale;",
                    "uniform float rotation;",
                    "uniform sampler2D occlusionMap;",
                    "attribute vec2 position;",
                    "attribute vec2 uv;",
                    "varying vec2 vUV;",
                    "varying float vVisibility;",
                    "void main() {",
                    "vUV = uv;",
                    "vec2 pos = position;",
                    "if ( renderType == 2 ) {",
                    "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
                    "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",
                    "vVisibility =        visibility.r / 9.0;",
                    "vVisibility *= 1.0 - visibility.g / 9.0;",
                    "vVisibility *=       visibility.b / 9.0;",
                    "vVisibility *= 1.0 - visibility.a / 9.0;",
                    "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
                    "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
                    "}",
                    "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
                    "}"
                ].join("\n"),
                fragmentShader: [
                    "uniform lowp int renderType;",
                    "uniform sampler2D map;",
                    "uniform float opacity;",
                    "uniform vec3 color;",
                    "varying vec2 vUV;",
                    "varying float vVisibility;",
                    "void main() {",
                    "if ( renderType == 0 ) {",
                    "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",
                    "} else if ( renderType == 1 ) {",
                    "gl_FragColor = texture2D( map, vUV );",
                    "} else {",
                    "vec4 texture = texture2D( map, vUV );",
                    "texture.a *= opacity * vVisibility;",
                    "gl_FragColor = texture;",
                    "gl_FragColor.rgb *= color;",
                    "}",
                    "}"
                ].join("\n")
            };
            var program = this.program = this.createProgram(this.shader);
            this.attributes = {
                vertex: gl.getAttribLocation(program, "position"),
                uv: gl.getAttribLocation(program, "uv")
            };
            this.uniforms = {
                renderType: gl.getUniformLocation(program, "renderType"),
                map: gl.getUniformLocation(program, "map"),
                occlusionMap: gl.getUniformLocation(program, "occlusionMap"),
                opacity: gl.getUniformLocation(program, "opacity"),
                color: gl.getUniformLocation(program, "color"),
                scale: gl.getUniformLocation(program, "scale"),
                rotation: gl.getUniformLocation(program, "rotation"),
                screenPosition: gl.getUniformLocation(program, "screenPosition")
            };
        };
        LensFlarePlugin.prototype.createProgram = function (shader) {
            var gl = this.renderer.context;
            var program = gl.createProgram();
            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            var prefix = "precision " + this.renderer.getPrecision() + " float;\n";
            gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
            gl.shaderSource(vertexShader, prefix + shader.vertexShader);
            gl.compileShader(fragmentShader);
            gl.compileShader(vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.attachShader(program, vertexShader);
            gl.linkProgram(program);
            return program;
        };
        LensFlarePlugin.prototype.render = function (scene, camera, viewport) {
            var flares = this.renderer.lensFlares;
            if (flares.length === 0)
                return;
            var tempPosition = new THREE.Vector3();
            var invAspect = viewport.w / viewport.z, halfViewportWidth = viewport.z * 0.5, halfViewportHeight = viewport.w * 0.5;
            var size = 16 / viewport.w, scale = new THREE.Vector2(size * invAspect, size);
            var screenPosition = new THREE.Vector3(1, 1, 0), screenPositionPixels = new THREE.Vector2(1, 1);
            var validArea = new THREE.Box2();
            validArea.min.set(0, 0);
            validArea.max.set(viewport.z - 16, viewport.w - 16);
            if (this.program === undefined) {
                this.init();
            }
            var renderer = this.renderer;
            var gl = this.renderer.context;
            var program = this.program;
            var state = this.renderer.state;
            var attributes = this.attributes;
            var uniforms = this.uniforms;
            var vertexBuffer = this.vertexBuffer;
            var elementBuffer = this.elementBuffer;
            gl.useProgram(program);
            state.initAttributes();
            state.enableAttribute(attributes.vertex);
            state.enableAttribute(attributes.uv);
            state.disableUnusedAttributes();
            gl.uniform1i(uniforms.occlusionMap, 0);
            gl.uniform1i(uniforms.map, 1);
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
            gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
            state.disable(gl.CULL_FACE);
            state.setDepthWrite(false);
            for (var i = 0, l = flares.length; i < l; i++) {
                size = 16 / viewport.w;
                scale.set(size * invAspect, size);
                var flare = flares[i];
                tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);
                tempPosition.applyMatrix4(camera.matrixWorldInverse);
                tempPosition.applyProjection(camera.projectionMatrix);
                screenPosition.copy(tempPosition);
                screenPositionPixels.x = viewport.x + (screenPosition.x * halfViewportWidth) + halfViewportWidth - 8;
                screenPositionPixels.y = viewport.y + (screenPosition.y * halfViewportHeight) + halfViewportHeight - 8;
                if (validArea.containsPoint(screenPositionPixels) === true) {
                    state.activeTexture(gl.TEXTURE0);
                    state.bindTexture(gl.TEXTURE_2D, null);
                    state.activeTexture(gl.TEXTURE1);
                    state.bindTexture(gl.TEXTURE_2D, this.tempTexture);
                    gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);
                    gl.uniform1i(uniforms.renderType, 0);
                    gl.uniform2f(uniforms.scale, scale.x, scale.y);
                    gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                    state.disable(gl.BLEND);
                    state.enable(gl.DEPTH_TEST);
                    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                    state.activeTexture(gl.TEXTURE0);
                    state.bindTexture(gl.TEXTURE_2D, this.occlusionTexture);
                    gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);
                    gl.uniform1i(uniforms.renderType, 1);
                    state.disable(gl.DEPTH_TEST);
                    state.activeTexture(gl.TEXTURE1);
                    state.bindTexture(gl.TEXTURE_2D, this.tempTexture);
                    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                    flare.positionScreen.copy(screenPosition);
                    if (flare.customUpdateCallback) {
                        flare.customUpdateCallback(flare);
                    }
                    else {
                        flare.updateLensFlares();
                    }
                    gl.uniform1i(uniforms.renderType, 2);
                    state.enable(gl.BLEND);
                    for (var j = 0, jl = flare.lensFlares.length; j < jl; j++) {
                        var sprite = flare.lensFlares[j];
                        if (sprite.opacity > 0.001 && sprite.scale > 0.001) {
                            screenPosition.x = sprite.x;
                            screenPosition.y = sprite.y;
                            screenPosition.z = sprite.z;
                            size = sprite.size * sprite.scale / viewport.w;
                            scale.x = size * invAspect;
                            scale.y = size;
                            gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                            gl.uniform2f(uniforms.scale, scale.x, scale.y);
                            gl.uniform1f(uniforms.rotation, sprite.rotation);
                            gl.uniform1f(uniforms.opacity, sprite.opacity);
                            gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);
                            state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
                            renderer.setTexture2D(sprite.texture, 1);
                            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                        }
                    }
                }
            }
            state.enable(gl.CULL_FACE);
            state.enable(gl.DEPTH_TEST);
            state.setDepthWrite(true);
            renderer.resetGLState();
        };
        ;
        return LensFlarePlugin;
    }());
    THREE.LensFlarePlugin = LensFlarePlugin;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var SpritePlugin = (function () {
        function SpritePlugin(renderer) {
            this.renderer = renderer;
            this.sprites = renderer.sprites;
            this.gl = renderer.context;
            this.state = renderer.state;
            this.spritePosition = new THREE.Vector3();
            this.spriteRotation = new THREE.Quaternion();
            this.spriteScale = new THREE.Vector3();
        }
        ;
        SpritePlugin.prototype.init = function () {
            var vertices = new Float32Array([
                -0.5, -0.5, 0, 0,
                0.5, -0.5, 1, 0,
                0.5, 0.5, 1, 1,
                -0.5, 0.5, 0, 1
            ]);
            var faces = new Uint16Array([
                0, 1, 2,
                0, 2, 3
            ]);
            var gl = this.gl;
            this.vertexBuffer = gl.createBuffer();
            this.elementBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.elementBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
            var program = this.program = this.createProgram();
            this.attributes = {
                position: gl.getAttribLocation(program, 'position'),
                uv: gl.getAttribLocation(program, 'uv')
            };
            this.uniforms = {
                uvOffset: gl.getUniformLocation(program, 'uvOffset'),
                uvScale: gl.getUniformLocation(program, 'uvScale'),
                rotation: gl.getUniformLocation(program, 'rotation'),
                scale: gl.getUniformLocation(program, 'scale'),
                color: gl.getUniformLocation(program, 'color'),
                map: gl.getUniformLocation(program, 'map'),
                opacity: gl.getUniformLocation(program, 'opacity'),
                modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
                projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),
                fogType: gl.getUniformLocation(program, 'fogType'),
                fogDensity: gl.getUniformLocation(program, 'fogDensity'),
                fogNear: gl.getUniformLocation(program, 'fogNear'),
                fogFar: gl.getUniformLocation(program, 'fogFar'),
                fogColor: gl.getUniformLocation(program, 'fogColor'),
                alphaTest: gl.getUniformLocation(program, 'alphaTest')
            };
            var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            canvas.width = 8;
            canvas.height = 8;
            var context = canvas.getContext('2d');
            context.fillStyle = 'white';
            context.fillRect(0, 0, 8, 8);
            this.texture = new THREE.Texture(canvas);
            this.texture.needsUpdate = true;
        };
        SpritePlugin.prototype.createProgram = function () {
            var gl = this.gl;
            var program = gl.createProgram();
            var renderer = this.renderer;
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(vertexShader, [
                'precision ' + renderer.getPrecision() + ' float;',
                'uniform mat4 modelViewMatrix;',
                'uniform mat4 projectionMatrix;',
                'uniform float rotation;',
                'uniform vec2 scale;',
                'uniform vec2 uvOffset;',
                'uniform vec2 uvScale;',
                'attribute vec2 position;',
                'attribute vec2 uv;',
                'varying vec2 vUV;',
                'void main() {',
                'vUV = uvOffset + uv * uvScale;',
                'vec2 alignedPosition = position * scale;',
                'vec2 rotatedPosition;',
                'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
                'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',
                'vec4 finalPosition;',
                'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
                'finalPosition.xy += rotatedPosition;',
                'finalPosition = projectionMatrix * finalPosition;',
                'gl_Position = finalPosition;',
                '}'
            ].join('\n'));
            gl.shaderSource(fragmentShader, [
                'precision ' + renderer.getPrecision() + ' float;',
                'uniform vec3 color;',
                'uniform sampler2D map;',
                'uniform float opacity;',
                'uniform int fogType;',
                'uniform vec3 fogColor;',
                'uniform float fogDensity;',
                'uniform float fogNear;',
                'uniform float fogFar;',
                'uniform float alphaTest;',
                'varying vec2 vUV;',
                'void main() {',
                'vec4 texture = texture2D( map, vUV );',
                'if ( texture.a < alphaTest ) discard;',
                'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
                'if ( fogType > 0 ) {',
                'float depth = gl_FragCoord.z / gl_FragCoord.w;',
                'float fogFactor = 0.0;',
                'if ( fogType == 1 ) {',
                'fogFactor = smoothstep( fogNear, fogFar, depth );',
                '} else {',
                'const float LOG2 = 1.442695;',
                'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
                'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
                '}',
                'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',
                '}',
                '}'
            ].join('\n'));
            gl.compileShader(vertexShader);
            gl.compileShader(fragmentShader);
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            return program;
        };
        SpritePlugin.prototype.painterSortStable = function (a, b) {
            if (a.renderOrder !== b.renderOrder) {
                return a.renderOrder - b.renderOrder;
            }
            else if (a.z !== b.z) {
                return b.z - a.z;
            }
            else {
                return b.id - a.id;
            }
        };
        SpritePlugin.prototype.render = function (scene, camera) {
            var sprites = this.sprites;
            if (sprites.length === 0)
                return;
            if (this.program === undefined) {
                this.init();
            }
            var gl = this.gl;
            var program = this.program;
            var state = this.state;
            var attributes = this.attributes;
            var vertexBuffer = this.vertexBuffer;
            var elementBuffer = this.elementBuffer;
            var uniforms = this.uniforms;
            gl.useProgram(program);
            state.initAttributes();
            state.enableAttribute(attributes.position);
            state.enableAttribute(attributes.uv);
            state.disableUnusedAttributes();
            state.disable(gl.CULL_FACE);
            state.enable(gl.BLEND);
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
            gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
            gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
            state.activeTexture(gl.TEXTURE0);
            gl.uniform1i(uniforms.map, 0);
            var oldFogType = 0;
            var sceneFogType = 0;
            var fog = scene.fog;
            if (fog) {
                gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
                if (fog instanceof THREE.Fog) {
                    gl.uniform1f(uniforms.fogNear, fog.near);
                    gl.uniform1f(uniforms.fogFar, fog.far);
                    gl.uniform1i(uniforms.fogType, 1);
                    oldFogType = 1;
                    sceneFogType = 1;
                }
                else if (fog instanceof THREE.FogExp2) {
                    gl.uniform1f(uniforms.fogDensity, fog.density);
                    gl.uniform1i(uniforms.fogType, 2);
                    oldFogType = 2;
                    sceneFogType = 2;
                }
            }
            else {
                gl.uniform1i(uniforms.fogType, 0);
                oldFogType = 0;
                sceneFogType = 0;
            }
            for (var i = 0, l = sprites.length; i < l; i++) {
                var sprite = sprites[i];
                sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
                sprite.z = -sprite.modelViewMatrix.elements[14];
            }
            sprites.sort(this.painterSortStable);
            var scale = [];
            var spritePosition = this.spritePosition;
            var spriteRotation = this.spriteRotation;
            var spriteScale = this.spriteScale;
            for (var i = 0, l = sprites.length; i < l; i++) {
                var sprite = sprites[i];
                var material = sprite.material;
                if (material.visible === false)
                    continue;
                gl.uniform1f(uniforms.alphaTest, material.alphaTest);
                gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);
                sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);
                scale[0] = spriteScale.x;
                scale[1] = spriteScale.y;
                var fogType = 0;
                if (scene.fog && material.fog) {
                    fogType = sceneFogType;
                }
                if (oldFogType !== fogType) {
                    gl.uniform1i(uniforms.fogType, fogType);
                    oldFogType = fogType;
                }
                if (material.map !== null) {
                    gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
                    gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
                }
                else {
                    gl.uniform2f(uniforms.uvOffset, 0, 0);
                    gl.uniform2f(uniforms.uvScale, 1, 1);
                }
                gl.uniform1f(uniforms.opacity, material.opacity);
                gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
                gl.uniform1f(uniforms.rotation, material.rotation);
                gl.uniform2fv(uniforms.scale, scale);
                state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
                state.setDepthTest(material.depthTest);
                state.setDepthWrite(material.depthWrite);
                if (material.map) {
                    this.renderer.setTexture2D(material.map, 0);
                }
                else {
                    this.renderer.setTexture2D(this.texture, 0);
                }
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            }
            state.enable(gl.CULL_FACE);
            this.renderer.resetGLState();
        };
        ;
        return SpritePlugin;
    }());
    THREE.SpritePlugin = SpritePlugin;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WebGLBufferRenderer = (function () {
        function WebGLBufferRenderer(_gl, extensions, _infoRender) {
            this._gl = _gl;
            this.extensions = extensions;
            this._infoRender = _infoRender;
        }
        ;
        WebGLBufferRenderer.prototype.setMode = function (value) {
            this.mode = value;
        };
        WebGLBufferRenderer.prototype.render = function (start, count) {
            var _gl = this._gl;
            var _infoRender = this._infoRender;
            _gl.drawArrays(this.mode, start, count);
            _infoRender.calls++;
            _infoRender.vertices += count;
            if (this.mode === _gl.TRIANGLES)
                _infoRender.faces += count / 3;
        };
        WebGLBufferRenderer.prototype.renderInstances = function (geometry) {
            var extensions = this.extensions;
            var mode = this.mode;
            var _infoRender = this._infoRender;
            var _gl = this._gl;
            var extension = extensions.get('ANGLE_instanced_arrays');
            if (extension === null) {
                console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
            var position = geometry.attributes.position;
            var count = 0;
            if (position instanceof THREE.InterleavedBufferAttribute) {
                count = position.data.count;
                extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount);
            }
            else {
                count = position.count;
                extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount);
            }
            _infoRender.calls++;
            _infoRender.vertices += count * geometry.maxInstancedCount;
            if (mode === _gl.TRIANGLES)
                _infoRender.faces += geometry.maxInstancedCount * count / 3;
        };
        return WebGLBufferRenderer;
    }());
    THREE.WebGLBufferRenderer = WebGLBufferRenderer;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WebGLCapabilities = (function () {
        function WebGLCapabilities(gl, extensions, parameters) {
            this.gl = gl;
            this.extensions = extensions;
            this.parameters = parameters;
            this.precision = parameters.precision !== undefined ? parameters.precision : 'highp';
            this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;
            this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            this.maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
            this.maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
            this.maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
            this.maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
            this.maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
            this.vertexTextures = this.maxVertexTextures > 0;
            this.floatFragmentTextures = !!extensions.get('OES_texture_float');
            this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
            var _maxPrecision = this.getMaxPrecision(this.precision);
            if (_maxPrecision !== this.precision) {
                console.warn('THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.');
                this.precision = _maxPrecision;
            }
            if (this.logarithmicDepthBuffer) {
                this.logarithmicDepthBuffer = !!extensions.get('EXT_frag_depth');
            }
        }
        ;
        WebGLCapabilities.prototype.getMaxAnisotropy = function () {
            if (this.maxAnisotropy !== undefined)
                return this.maxAnisotropy;
            var extension = this.extensions.get('EXT_texture_filter_anisotropic');
            if (extension !== null) {
                this.maxAnisotropy = this.gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            }
            else {
                this.maxAnisotropy = 0;
            }
            return this.maxAnisotropy;
        };
        WebGLCapabilities.prototype.getMaxPrecision = function (precision) {
            var gl = this.gl;
            if (precision === 'highp') {
                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 &&
                    gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                    return 'highp';
                }
                precision = 'mediump';
            }
            if (precision === 'mediump') {
                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 &&
                    gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                    return 'mediump';
                }
            }
            return 'lowp';
        };
        return WebGLCapabilities;
    }());
    THREE.WebGLCapabilities = WebGLCapabilities;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WebGLClipping = (function () {
        function WebGLClipping() {
            this.globalState = null;
            this.numGlobalPlanes = 0;
            this.localClippingEnabled = false;
            this.renderingShadows = false;
            this.plane = new THREE.Plane();
            this.viewNormalMatrix = new THREE.Matrix3();
            this.uniform = { value: null, needsUpdate: false };
            this.numPlanes = 0;
        }
        WebGLClipping.prototype.init = function (planes, enableLocalClipping, camera) {
            var enabled = planes.length !== 0 ||
                enableLocalClipping ||
                this.numGlobalPlanes !== 0 ||
                this.localClippingEnabled;
            this.localClippingEnabled = enableLocalClipping;
            this.globalState = this.projectPlanes(planes, camera, 0);
            this.numGlobalPlanes = planes.length;
            return enabled;
        };
        ;
        WebGLClipping.prototype.beginShadows = function () {
            this.renderingShadows = true;
            this.projectPlanes(null);
        };
        ;
        WebGLClipping.prototype.endShadows = function () {
            this.renderingShadows = false;
            this.resetGlobalState();
        };
        ;
        WebGLClipping.prototype.setState = function (planes, clipShadows, camera, cache, fromCache) {
            if (!this.localClippingEnabled ||
                planes === null || planes.length === 0 ||
                this.renderingShadows && !clipShadows) {
                if (this.renderingShadows) {
                    this.projectPlanes(null);
                }
                else {
                    this.resetGlobalState();
                }
            }
            else {
                var nGlobal = this.renderingShadows ? 0 : this.numGlobalPlanes, lGlobal = nGlobal * 4, dstArray = cache.clippingState || null;
                this.uniform.value = dstArray;
                dstArray = this.projectPlanes(planes, camera, lGlobal, fromCache);
                for (var i = 0; i !== lGlobal; ++i) {
                    dstArray[i] = this.globalState[i];
                }
                cache.clippingState = dstArray;
                this.numPlanes += nGlobal;
            }
        };
        ;
        WebGLClipping.prototype.resetGlobalState = function () {
            if (this.uniform.value !== this.globalState) {
                this.uniform.value = this.globalState;
                this.uniform.needsUpdate = this.numGlobalPlanes > 0;
            }
            this.numPlanes = this.numGlobalPlanes;
        };
        WebGLClipping.prototype.projectPlanes = function (planes, camera, dstOffset, skipTransform) {
            var nPlanes = planes !== null ? planes.length : 0, dstArray = null;
            if (nPlanes !== 0) {
                dstArray = this.uniform.value;
                if (skipTransform !== true || dstArray === null) {
                    var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
                    this.viewNormalMatrix.getNormalMatrix(viewMatrix);
                    if (dstArray === null || dstArray.length < flatSize) {
                        dstArray = new Float32Array(flatSize);
                    }
                    for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
                        this.plane.copy(planes[i]).
                            applyMatrix4(viewMatrix, this.viewNormalMatrix);
                        this.plane.normal.toArray(dstArray, i4);
                        dstArray[i4 + 3] = this.plane.constant;
                    }
                }
                this.uniform.value = dstArray;
                this.uniform.needsUpdate = true;
            }
            this.numPlanes = nPlanes;
            return dstArray;
        };
        return WebGLClipping;
    }());
    THREE.WebGLClipping = WebGLClipping;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WebGLExtensions = (function () {
        function WebGLExtensions(gl) {
            this.extensions = {};
            this.gl = gl;
        }
        ;
        WebGLExtensions.prototype.get = function (name) {
            var extensions = this.extensions;
            var gl = this.gl;
            if (extensions[name] !== undefined) {
                return extensions[name];
            }
            var extension;
            switch (name) {
                case 'WEBGL_depth_texture':
                    extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                    break;
                case 'EXT_texture_filter_anisotropic':
                    extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                    break;
                case 'WEBGL_compressed_texture_s3tc':
                    extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                    break;
                case 'WEBGL_compressed_texture_pvrtc':
                    extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                    break;
                case 'WEBGL_compressed_texture_etc1':
                    extension = gl.getExtension('WEBGL_compressed_texture_etc1');
                    break;
                default:
                    extension = gl.getExtension(name);
            }
            if (extension === null) {
                console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
            }
            extensions[name] = extension;
            return extension;
        };
        ;
        return WebGLExtensions;
    }());
    THREE.WebGLExtensions = WebGLExtensions;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WebGLGeometries = (function () {
        function WebGLGeometries(gl, properties, info) {
            this.gl = gl;
            this.geometries = {};
            this.properties = properties;
            this.info = info;
        }
        WebGLGeometries.prototype.onGeometryDispose = function (event) {
            var geometries = this.geometries;
            var properties = this.properties;
            var geometry = event.target;
            var buffergeometry = geometries[geometry.id];
            if (buffergeometry.index !== null) {
                this.deleteAttribute(buffergeometry.index);
            }
            this.deleteAttributes(buffergeometry.attributes);
            geometry.removeEventListener('dispose', this.onGeometryDispose, this);
            delete geometries[geometry.id];
            var property = properties.get(geometry);
            if (property.wireframe) {
                this.deleteAttribute(property.wireframe);
            }
            properties.delete(geometry);
            var bufferproperty = properties.get(buffergeometry);
            if (bufferproperty.wireframe) {
                this.deleteAttribute(bufferproperty.wireframe);
            }
            properties.delete(buffergeometry);
            this.info.memory.geometries--;
        };
        WebGLGeometries.prototype.getAttributeBuffer = function (attribute) {
            var properties = this.properties;
            if (attribute instanceof THREE.InterleavedBufferAttribute) {
                return properties.get(attribute.data).__webglBuffer;
            }
            return properties.get(attribute).__webglBuffer;
        };
        WebGLGeometries.prototype.deleteAttribute = function (attribute) {
            var buffer = this.getAttributeBuffer(attribute);
            if (buffer !== undefined) {
                this.gl.deleteBuffer(buffer);
                this.removeAttributeBuffer(attribute);
            }
        };
        WebGLGeometries.prototype.deleteAttributes = function (attributes) {
            for (var name in attributes) {
                this.deleteAttribute(attributes[name]);
            }
        };
        WebGLGeometries.prototype.removeAttributeBuffer = function (attribute) {
            var properties = this.properties;
            if (attribute instanceof THREE.InterleavedBufferAttribute) {
                properties.delete(attribute.data);
            }
            else {
                properties.delete(attribute);
            }
        };
        WebGLGeometries.prototype.get = function (object) {
            var geometry = object.geometry;
            var geometries = this.geometries;
            if (geometries[geometry.id] !== undefined) {
                return geometries[geometry.id];
            }
            geometry.addEventListener('dispose', this.onGeometryDispose, this);
            var buffergeometry;
            if (geometry instanceof THREE.BufferGeometry) {
                buffergeometry = geometry;
            }
            else if (geometry instanceof THREE.Geometry) {
                if (geometry._bufferGeometry === undefined) {
                    geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject(object);
                }
                buffergeometry = geometry._bufferGeometry;
            }
            geometries[geometry.id] = buffergeometry;
            this.info.memory.geometries++;
            return buffergeometry;
        };
        return WebGLGeometries;
    }());
    THREE.WebGLGeometries = WebGLGeometries;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WebGLIndexedBufferRenderer = (function () {
        function WebGLIndexedBufferRenderer(_gl, extensions, _infoRender) {
            this._gl = _gl;
            this.extensions = extensions;
            this._infoRender = _infoRender;
        }
        ;
        WebGLIndexedBufferRenderer.prototype.setMode = function (value) {
            this.mode = value;
        };
        WebGLIndexedBufferRenderer.prototype.setIndex = function (index) {
            var extensions = this.extensions;
            var _gl = this._gl;
            if (index.array instanceof Uint32Array && extensions.get('OES_element_index_uint')) {
                this.type = _gl.UNSIGNED_INT;
                this.size = 4;
            }
            else {
                this.type = _gl.UNSIGNED_SHORT;
                this.size = 2;
            }
        };
        WebGLIndexedBufferRenderer.prototype.render = function (start, count) {
            var mode = this.mode;
            var type = this.type;
            var size = this.size;
            var _gl = this._gl;
            var _infoRender = this._infoRender;
            _gl.drawElements(mode, count, type, start * size);
            _infoRender.calls++;
            _infoRender.vertices += count;
            if (mode === _gl.TRIANGLES)
                _infoRender.faces += count / 3;
        };
        WebGLIndexedBufferRenderer.prototype.renderInstances = function (geometry, start, count) {
            var extensions = this.extensions;
            var _infoRender = this._infoRender;
            var mode = this.mode;
            var type = this.type;
            var size = this.size;
            var _gl = this._gl;
            var extension = extensions.get('ANGLE_instanced_arrays');
            if (extension === null) {
                console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
            extension.drawElementsInstancedANGLE(mode, count, type, start * size, geometry.maxInstancedCount);
            _infoRender.calls++;
            _infoRender.vertices += count * geometry.maxInstancedCount;
            if (mode === _gl.TRIANGLES)
                _infoRender.faces += geometry.maxInstancedCount * count / 3;
        };
        return WebGLIndexedBufferRenderer;
    }());
    THREE.WebGLIndexedBufferRenderer = WebGLIndexedBufferRenderer;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WebGLLights = (function () {
        function WebGLLights() {
            this.lights = {};
        }
        ;
        WebGLLights.prototype.get = function (light) {
            var lights = this.lights;
            if (lights[light.id] !== undefined) {
                return lights[light.id];
            }
            var uniforms;
            switch (light.type) {
                case 'DirectionalLight':
                    uniforms = {
                        direction: new THREE.Vector3(),
                        color: new THREE.Color(),
                        shadow: false,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new THREE.Vector2()
                    };
                    break;
                case 'SpotLight':
                    uniforms = {
                        position: new THREE.Vector3(),
                        direction: new THREE.Vector3(),
                        color: new THREE.Color(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                        shadow: false,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new THREE.Vector2()
                    };
                    break;
                case 'PointLight':
                    uniforms = {
                        position: new THREE.Vector3(),
                        color: new THREE.Color(),
                        distance: 0,
                        decay: 0,
                        shadow: false,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new THREE.Vector2()
                    };
                    break;
                case 'HemisphereLight':
                    uniforms = {
                        direction: new THREE.Vector3(),
                        skyColor: new THREE.Color(),
                        groundColor: new THREE.Color()
                    };
                    break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        };
        ;
        return WebGLLights;
    }());
    THREE.WebGLLights = WebGLLights;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WebGLObjects = (function () {
        function WebGLObjects(gl, properties, info) {
            this.gl = gl;
            this.properties = properties;
            this.info = info;
            this.geometries = new THREE.WebGLGeometries(gl, properties, info);
        }
        WebGLObjects.prototype.updateAttribute = function (attribute, bufferType) {
            var properties = this.properties;
            var data = attribute;
            if (attribute instanceof THREE.InterleavedBufferAttribute)
                data = attribute.data;
            var attributeProperties = properties.get(data);
            if (attributeProperties.__webglBuffer === undefined) {
                this.createBuffer(attributeProperties, data, bufferType);
            }
            else if (attributeProperties.version !== data.version) {
                this.updateBuffer(attributeProperties, data, bufferType);
            }
        };
        WebGLObjects.prototype.createBuffer = function (attributeProperties, data, bufferType) {
            var gl = this.gl;
            attributeProperties.__webglBuffer = gl.createBuffer();
            gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
            var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
            gl.bufferData(bufferType, data.array, usage);
            attributeProperties.version = data.version;
        };
        WebGLObjects.prototype.updateBuffer = function (attributeProperties, data, bufferType) {
            var gl = this.gl;
            gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
            if (data.dynamic === false || data.updateRange.count === -1) {
                gl.bufferSubData(bufferType, 0, data.array);
            }
            else if (data.updateRange.count === 0) {
                console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
            }
            else {
                gl.bufferSubData(bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT, data.array.subarray(data.updateRange.offset, data.updateRange.offset + data.updateRange.count));
                data.updateRange.count = 0;
            }
            attributeProperties.version = data.version;
        };
        WebGLObjects.prototype.checkEdge = function (edges, a, b) {
            if (a > b) {
                var tmp = a;
                a = b;
                b = tmp;
            }
            var list = edges[a];
            if (list === undefined) {
                edges[a] = [b];
                return true;
            }
            else if (list.indexOf(b) === -1) {
                list.push(b);
                return true;
            }
            return false;
        };
        WebGLObjects.prototype.getAttributeBuffer = function (attribute) {
            var properties = this.properties;
            if (attribute instanceof THREE.InterleavedBufferAttribute) {
                return properties.get(attribute.data).__webglBuffer;
            }
            return properties.get(attribute).__webglBuffer;
        };
        WebGLObjects.prototype.getWireframeAttribute = function (geometry) {
            var properties = this.properties;
            var checkEdge = this.checkEdge;
            var gl = this.gl;
            var property = properties.get(geometry);
            if (property.wireframe !== undefined) {
                return property.wireframe;
            }
            var indices = [];
            var index = geometry.index;
            var attributes = geometry.attributes;
            var position = attributes.position;
            if (index !== null) {
                var edges = {};
                var array = index.array;
                for (var i = 0, l = array.length; i < l; i += 3) {
                    var a = array[i + 0];
                    var b = array[i + 1];
                    var c = array[i + 2];
                    if (checkEdge(edges, a, b))
                        indices.push(a, b);
                    if (checkEdge(edges, b, c))
                        indices.push(b, c);
                    if (checkEdge(edges, c, a))
                        indices.push(c, a);
                }
            }
            else {
                var array_1 = attributes.position.array;
                for (var i = 0, l = (array_1.length / 3) - 1; i < l; i += 3) {
                    var a = i + 0;
                    var b = i + 1;
                    var c = i + 2;
                    indices.push(a, b, b, c, c, a);
                }
            }
            var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
            var attribute = new THREE.BufferAttribute(new TypeArray(indices), 1);
            this.updateAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);
            property.wireframe = attribute;
            return attribute;
        };
        WebGLObjects.prototype.update = function (object) {
            var gl = this.gl;
            var geometry = this.geometries.get(object);
            if (object.geometry instanceof THREE.Geometry) {
                geometry.updateFromObject(object);
            }
            var index = geometry.index;
            var attributes = geometry.attributes;
            if (index !== null) {
                this.updateAttribute(index, gl.ELEMENT_ARRAY_BUFFER);
            }
            for (var name in attributes) {
                this.updateAttribute(attributes[name], gl.ARRAY_BUFFER);
            }
            var morphAttributes = geometry.morphAttributes;
            for (var name in morphAttributes) {
                var array = morphAttributes[name];
                for (var i = 0, l = array.length; i < l; i++) {
                    this.updateAttribute(array[i], gl.ARRAY_BUFFER);
                }
            }
            return geometry;
        };
        return WebGLObjects;
    }());
    THREE.WebGLObjects = WebGLObjects;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WebGLProgram = (function () {
        function WebGLProgram(renderer, code, material, parameters) {
            this.id = WebGLProgram.programIdCount++;
            this.renderer = renderer;
            this.code = code;
            this.material = material;
            this.parameters = parameters;
            var filterEmptyLine = WebGLProgram.filterEmptyLine;
            var gl = this.gl = renderer.context;
            var extensions = material.extensions;
            var defines = material.defines;
            var vertexShader = material.__webglShader.vertexShader;
            var fragmentShader = material.__webglShader.fragmentShader;
            var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
            if (parameters.shadowMapType === THREE.PCFShadowMap) {
                shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
            }
            else if (parameters.shadowMapType === THREE.PCFSoftShadowMap) {
                shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
            }
            var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
            var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
            var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
            if (parameters.envMap) {
                switch (material.envMap.mapping) {
                    case THREE.CubeReflectionMapping:
                    case THREE.CubeRefractionMapping:
                        envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                        break;
                    case THREE.CubeUVReflectionMapping:
                    case THREE.CubeUVRefractionMapping:
                        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
                        break;
                    case THREE.EquirectangularReflectionMapping:
                    case THREE.EquirectangularRefractionMapping:
                        envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
                        break;
                    case THREE.SphericalReflectionMapping:
                        envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
                        break;
                }
                switch (material.envMap.mapping) {
                    case THREE.CubeRefractionMapping:
                    case THREE.EquirectangularRefractionMapping:
                        envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                        break;
                }
                switch (material.combine) {
                    case THREE.MultiplyOperation:
                        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                        break;
                    case THREE.MixOperation:
                        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                        break;
                    case THREE.AddOperation:
                        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                        break;
                }
            }
            var gammaFactorDefine = (renderer.gammaFactor > 0) ? renderer.gammaFactor : 1.0;
            var customExtensions = WebGLProgram.generateExtensions(extensions, parameters, renderer.extensions);
            var customDefines = WebGLProgram.generateDefines(defines);
            var program = gl.createProgram();
            var prefixVertex;
            var prefixFragment;
            if (material instanceof THREE.RawShaderMaterial) {
                prefixVertex = [
                    customDefines
                ].filter(filterEmptyLine).join('\n');
                prefixFragment = [
                    customDefines
                ].filter(filterEmptyLine).join('\n');
            }
            else {
                prefixVertex = [
                    'precision ' + parameters.precision + ' float;',
                    'precision ' + parameters.precision + ' int;',
                    '#define SHADER_NAME ' + material.__webglShader.name,
                    customDefines,
                    parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
                    '#define GAMMA_FACTOR ' + gammaFactorDefine,
                    '#define MAX_BONES ' + parameters.maxBones,
                    parameters.map ? '#define USE_MAP' : '',
                    parameters.envMap ? '#define USE_ENVMAP' : '',
                    parameters.envMap ? '#define ' + envMapModeDefine : '',
                    parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                    parameters.aoMap ? '#define USE_AOMAP' : '',
                    parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                    parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                    parameters.normalMap ? '#define USE_NORMALMAP' : '',
                    parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
                    parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                    parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                    parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
                    parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                    parameters.vertexColors ? '#define USE_COLOR' : '',
                    parameters.flatShading ? '#define FLAT_SHADED' : '',
                    parameters.skinning ? '#define USE_SKINNING' : '',
                    parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
                    parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
                    parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
                    parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                    parameters.flipSided ? '#define FLIP_SIDED' : '',
                    '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
                    parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                    parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                    parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
                    parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                    parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',
                    'uniform mat4 modelMatrix;',
                    'uniform mat4 modelViewMatrix;',
                    'uniform mat4 projectionMatrix;',
                    'uniform mat4 viewMatrix;',
                    'uniform mat3 normalMatrix;',
                    'uniform vec3 cameraPosition;',
                    'attribute vec3 position;',
                    'attribute vec3 normal;',
                    'attribute vec2 uv;',
                    '#ifdef USE_COLOR',
                    '	attribute vec3 color;',
                    '#endif',
                    '#ifdef USE_MORPHTARGETS',
                    '	attribute vec3 morphTarget0;',
                    '	attribute vec3 morphTarget1;',
                    '	attribute vec3 morphTarget2;',
                    '	attribute vec3 morphTarget3;',
                    '	#ifdef USE_MORPHNORMALS',
                    '		attribute vec3 morphNormal0;',
                    '		attribute vec3 morphNormal1;',
                    '		attribute vec3 morphNormal2;',
                    '		attribute vec3 morphNormal3;',
                    '	#else',
                    '		attribute vec3 morphTarget4;',
                    '		attribute vec3 morphTarget5;',
                    '		attribute vec3 morphTarget6;',
                    '		attribute vec3 morphTarget7;',
                    '	#endif',
                    '#endif',
                    '#ifdef USE_SKINNING',
                    '	attribute vec4 skinIndex;',
                    '	attribute vec4 skinWeight;',
                    '#endif',
                    '\n'
                ].filter(filterEmptyLine).join('\n');
                prefixFragment = [
                    customExtensions,
                    'precision ' + parameters.precision + ' float;',
                    'precision ' + parameters.precision + ' int;',
                    '#define SHADER_NAME ' + material.__webglShader.name,
                    customDefines,
                    parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
                    '#define GAMMA_FACTOR ' + gammaFactorDefine,
                    (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
                    (parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '',
                    parameters.map ? '#define USE_MAP' : '',
                    parameters.envMap ? '#define USE_ENVMAP' : '',
                    parameters.envMap ? '#define ' + envMapTypeDefine : '',
                    parameters.envMap ? '#define ' + envMapModeDefine : '',
                    parameters.envMap ? '#define ' + envMapBlendingDefine : '',
                    parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                    parameters.aoMap ? '#define USE_AOMAP' : '',
                    parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                    parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                    parameters.normalMap ? '#define USE_NORMALMAP' : '',
                    parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                    parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                    parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
                    parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                    parameters.vertexColors ? '#define USE_COLOR' : '',
                    parameters.flatShading ? '#define FLAT_SHADED' : '',
                    parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                    parameters.flipSided ? '#define FLIP_SIDED' : '',
                    '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
                    parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                    parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                    parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',
                    parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',
                    parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                    parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',
                    parameters.envMap && renderer.extensions.get('EXT_shader_texture_lod') ? '#define TEXTURE_LOD_EXT' : '',
                    'uniform mat4 viewMatrix;',
                    'uniform vec3 cameraPosition;',
                    (parameters.toneMapping !== THREE.NoToneMapping) ? "#define TONE_MAPPING" : '',
                    (parameters.toneMapping !== THREE.NoToneMapping) ? THREE.ShaderChunk['tonemapping_pars_fragment'] : '',
                    (parameters.toneMapping !== THREE.NoToneMapping) ? WebGLProgram.getToneMappingFunction("toneMapping", parameters.toneMapping) : '',
                    (parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding) ? THREE.ShaderChunk['encodings_pars_fragment'] : '',
                    parameters.mapEncoding ? WebGLProgram.getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
                    parameters.envMapEncoding ? WebGLProgram.getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
                    parameters.emissiveMapEncoding ? WebGLProgram.getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
                    parameters.outputEncoding ? WebGLProgram.getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : '',
                    parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',
                    '\n'
                ].filter(filterEmptyLine).join('\n');
            }
            vertexShader = WebGLProgram.parseIncludes(vertexShader, parameters);
            vertexShader = WebGLProgram.replaceLightNums(vertexShader, parameters);
            fragmentShader = WebGLProgram.parseIncludes(fragmentShader, parameters);
            fragmentShader = WebGLProgram.replaceLightNums(fragmentShader, parameters);
            if (material instanceof THREE.ShaderMaterial === false) {
                vertexShader = WebGLProgram.unrollLoops(vertexShader);
                fragmentShader = WebGLProgram.unrollLoops(fragmentShader);
            }
            var vertexGlsl = prefixVertex + vertexShader;
            var fragmentGlsl = prefixFragment + fragmentShader;
            var glVertexShader = THREE.WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
            var glFragmentShader = THREE.WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
            gl.attachShader(program, glVertexShader);
            gl.attachShader(program, glFragmentShader);
            if (material.index0AttributeName !== undefined) {
                gl.bindAttribLocation(program, 0, material.index0AttributeName);
            }
            else if (parameters.morphTargets === true) {
                gl.bindAttribLocation(program, 0, 'position');
            }
            gl.linkProgram(program);
            var programLog = gl.getProgramInfoLog(program);
            var vertexLog = gl.getShaderInfoLog(glVertexShader);
            var fragmentLog = gl.getShaderInfoLog(glFragmentShader);
            var runnable = true;
            var haveDiagnostics = true;
            if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
                runnable = false;
                console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog);
            }
            else if (programLog !== '') {
                console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
            }
            else if (vertexLog === '' || fragmentLog === '') {
                haveDiagnostics = false;
            }
            if (haveDiagnostics) {
                this.diagnostics = {
                    runnable: runnable,
                    material: material,
                    programLog: programLog,
                    vertexShader: {
                        log: vertexLog,
                        prefix: prefixVertex
                    },
                    fragmentShader: {
                        log: fragmentLog,
                        prefix: prefixFragment
                    }
                };
            }
            gl.deleteShader(glVertexShader);
            gl.deleteShader(glFragmentShader);
            this.code = code;
            this.usedTimes = 1;
            this.program = program;
            this.vertexShader = glVertexShader;
            this.fragmentShader = glFragmentShader;
        }
        WebGLProgram.getEncodingComponents = function (encoding) {
            switch (encoding) {
                case THREE.LinearEncoding:
                    return ['Linear', '( value )'];
                case THREE.sRGBEncoding:
                    return ['sRGB', '( value )'];
                case THREE.RGBEEncoding:
                    return ['RGBE', '( value )'];
                case THREE.RGBM7Encoding:
                    return ['RGBM', '( value, 7.0 )'];
                case THREE.RGBM16Encoding:
                    return ['RGBM', '( value, 16.0 )'];
                case THREE.RGBDEncoding:
                    return ['RGBD', '( value, 256.0 )'];
                case THREE.GammaEncoding:
                    return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
                default:
                    throw new Error('unsupported encoding: ' + encoding);
            }
        };
        WebGLProgram.getTexelDecodingFunction = function (functionName, encoding) {
            var components = WebGLProgram.getEncodingComponents(encoding);
            return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
        };
        WebGLProgram.getTexelEncodingFunction = function (functionName, encoding) {
            var components = WebGLProgram.getEncodingComponents(encoding);
            return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
        };
        WebGLProgram.getToneMappingFunction = function (functionName, toneMapping) {
            var toneMappingName;
            switch (toneMapping) {
                case THREE.LinearToneMapping:
                    toneMappingName = "Linear";
                    break;
                case THREE.ReinhardToneMapping:
                    toneMappingName = "Reinhard";
                    break;
                case THREE.Uncharted2ToneMapping:
                    toneMappingName = "Uncharted2";
                    break;
                case THREE.CineonToneMapping:
                    toneMappingName = "OptimizedCineon";
                    break;
                default:
                    throw new Error('unsupported toneMapping: ' + toneMapping);
            }
            return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
        };
        WebGLProgram.generateExtensions = function (extensions, parameters, rendererExtensions) {
            extensions = extensions || {};
            var chunks = [
                (extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading) ? '#extension GL_OES_standard_derivatives : enable' : '',
                (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '',
                (extensions.drawBuffers) && rendererExtensions.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '',
                (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : '',
            ];
            return chunks.filter(WebGLProgram.filterEmptyLine).join('\n');
        };
        WebGLProgram.generateDefines = function (defines) {
            var chunks = [];
            for (var name in defines) {
                var value = defines[name];
                if (value === false)
                    continue;
                chunks.push('#define ' + name + ' ' + value);
            }
            return chunks.join('\n');
        };
        WebGLProgram.fetchAttributeLocations = function (gl, program, identifiers) {
            var attributes = {};
            var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
            for (var i = 0; i < n; i++) {
                var info = gl.getActiveAttrib(program, i);
                var name = info.name;
                attributes[name] = gl.getAttribLocation(program, name);
            }
            return attributes;
        };
        WebGLProgram.filterEmptyLine = function (string) {
            return string !== '';
        };
        WebGLProgram.replaceLightNums = function (string, parameters) {
            return string
                .replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights)
                .replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights)
                .replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights)
                .replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
        };
        WebGLProgram.parseIncludes = function (string) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var pattern = /#include +<([\w\d.]+)>/g;
            function replace(match, include) {
                var replace = THREE.ShaderChunk[include];
                if (replace === undefined) {
                    throw new Error('Can not resolve #include <' + include + '>');
                }
                return WebGLProgram.parseIncludes(replace);
            }
            return string.replace(pattern, replace);
        };
        WebGLProgram.unrollLoops = function (string) {
            var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
            function replace(match, start, end, snippet) {
                var unroll = '';
                for (var i = parseInt(start); i < parseInt(end); i++) {
                    unroll += snippet.replace(/\[ i \]/g, '[ ' + i + ' ]');
                }
                return unroll;
            }
            return string.replace(pattern, replace);
        };
        ;
        WebGLProgram.prototype.getAttributes = function () {
            if (this.cachedAttributes === undefined) {
                this.cachedAttributes = WebGLProgram.fetchAttributeLocations(this.gl, this.program);
            }
            return this.cachedAttributes;
        };
        ;
        WebGLProgram.prototype.getUniforms = function () {
            if (this.cachedUniforms === undefined) {
                this.cachedUniforms =
                    new THREE.WebGLUniforms(this.gl, this.program, this.renderer);
            }
            return this.cachedUniforms;
        };
        ;
        WebGLProgram.prototype.destroy = function () {
            this.gl.deleteProgram(this.program);
            this.program = undefined;
        };
        ;
        WebGLProgram.programIdCount = 0;
        return WebGLProgram;
    }());
    THREE.WebGLProgram = WebGLProgram;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WebGLPrograms = (function () {
        function WebGLPrograms(renderer, capabilities) {
            this.shaderIDs = {
                MeshDepthMaterial: 'depth',
                MeshNormalMaterial: 'normal',
                MeshBasicMaterial: 'basic',
                MeshLambertMaterial: 'lambert',
                MeshPhongMaterial: 'phong',
                MeshStandardMaterial: 'physical',
                MeshPhysicalMaterial: 'physical',
                LineBasicMaterial: 'basic',
                LineDashedMaterial: 'dashed',
                PointsMaterial: 'points'
            };
            this.renderer = renderer;
            this.capabilities = capabilities;
            this.programs = [];
            this.parameterNames = [
                "precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
                "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
                "roughnessMap", "metalnessMap",
                "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
                "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
                "maxBones", "useVertexTexture", "morphTargets", "morphNormals",
                "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
                "numDirLights", "numPointLights", "numSpotLights", "numHemiLights",
                "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
                "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "depthPacking"
            ];
        }
        ;
        WebGLPrograms.prototype.allocateBones = function (object) {
            var capabilities = this.capabilities;
            if (capabilities.floatVertexTextures
                && object && object.skeleton && object.skeleton.useVertexTexture) {
                return 1024;
            }
            else {
                var nVertexUniforms = capabilities.maxVertexUniforms;
                var nVertexMatrices = THREE.Math.floor((nVertexUniforms - 20) / 4);
                var maxBones = nVertexMatrices;
                if (object !== undefined && object instanceof THREE.SkinnedMesh) {
                    maxBones = THREE.Math.min(object.skeleton.bones.length, maxBones);
                    if (maxBones < object.skeleton.bones.length) {
                        console.warn('WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)');
                    }
                }
                return maxBones;
            }
        };
        WebGLPrograms.prototype.getTextureEncodingFromMap = function (map, gammaOverrideLinear) {
            var encoding;
            if (!map) {
                encoding = THREE.LinearEncoding;
            }
            else if (map instanceof THREE.Texture) {
                encoding = map.encoding;
            }
            else if (map instanceof THREE.WebGLRenderTarget) {
                console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
                encoding = map.texture.encoding;
            }
            if (encoding === THREE.LinearEncoding && gammaOverrideLinear) {
                encoding = THREE.GammaEncoding;
            }
            return encoding;
        };
        WebGLPrograms.prototype.getParameters = function (material, lights, fog, nClipPlanes, object) {
            var renderer = this.renderer;
            var shaderIDs = this.shaderIDs;
            var capabilities = this.capabilities;
            var shaderID = shaderIDs[material.type];
            var maxBones = this.allocateBones(object);
            var precision = renderer.getPrecision();
            if (material.precision !== null) {
                precision = capabilities.getMaxPrecision(material.precision);
                if (precision !== material.precision) {
                    console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
                }
            }
            var currentRenderTarget = renderer.getCurrentRenderTarget();
            var parameters = {
                shaderID: shaderID,
                precision: precision,
                supportsVertexTextures: capabilities.vertexTextures,
                outputEncoding: this.getTextureEncodingFromMap((!currentRenderTarget) ? null : currentRenderTarget.texture, renderer.gammaOutput),
                map: !!material.map,
                mapEncoding: this.getTextureEncodingFromMap(material.map, renderer.gammaInput),
                envMap: !!material.envMap,
                envMapMode: material.envMap && material.envMap.mapping,
                envMapEncoding: this.getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
                envMapCubeUV: (!!material.envMap) && ((material.envMap.mapping === THREE.CubeUVReflectionMapping) || (material.envMap.mapping === THREE.CubeUVRefractionMapping)),
                lightMap: !!material.lightMap,
                aoMap: !!material.aoMap,
                emissiveMap: !!material.emissiveMap,
                emissiveMapEncoding: this.getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
                bumpMap: !!material.bumpMap,
                normalMap: !!material.normalMap,
                displacementMap: !!material.displacementMap,
                roughnessMap: !!material.roughnessMap,
                metalnessMap: !!material.metalnessMap,
                specularMap: !!material.specularMap,
                alphaMap: !!material.alphaMap,
                combine: material.combine,
                vertexColors: material.vertexColors,
                fog: !!fog,
                useFog: material.fog,
                fogExp: fog instanceof THREE.FogExp2,
                flatShading: material.shading === THREE.FlatShading,
                sizeAttenuation: material.sizeAttenuation,
                logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
                skinning: material.skinning,
                maxBones: maxBones,
                useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
                morphTargets: material.morphTargets,
                morphNormals: material.morphNormals,
                maxMorphTargets: renderer.maxMorphTargets,
                maxMorphNormals: renderer.maxMorphNormals,
                numDirLights: lights.directional.length,
                numPointLights: lights.point.length,
                numSpotLights: lights.spot.length,
                numHemiLights: lights.hemi.length,
                numClippingPlanes: nClipPlanes,
                shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
                shadowMapType: renderer.shadowMap.type,
                toneMapping: renderer.toneMapping,
                physicallyCorrectLights: renderer.physicallyCorrectLights,
                premultipliedAlpha: material.premultipliedAlpha,
                alphaTest: material.alphaTest,
                doubleSided: material.side === THREE.DoubleSide,
                flipSided: material.side === THREE.BackSide,
                depthPacking: (material.depthPacking !== undefined) ? material.depthPacking : false
            };
            return parameters;
        };
        ;
        WebGLPrograms.prototype.getProgramCode = function (material, parameters) {
            var parameterNames = this.parameterNames;
            var array = [];
            if (parameters.shaderID) {
                array.push(parameters.shaderID);
            }
            else {
                array.push(material.fragmentShader);
                array.push(material.vertexShader);
            }
            if (material.defines !== undefined) {
                for (var name in material.defines) {
                    array.push(name);
                    array.push(material.defines[name]);
                }
            }
            for (var i = 0; i < parameterNames.length; i++) {
                array.push(parameters[parameterNames[i]]);
            }
            return array.join();
        };
        ;
        WebGLPrograms.prototype.acquireProgram = function (material, parameters, code) {
            var programs = this.programs;
            var program;
            var renderer = this.renderer;
            for (var p = 0, pl = programs.length; p < pl; p++) {
                var programInfo = programs[p];
                if (programInfo.code === code) {
                    program = programInfo;
                    ++program.usedTimes;
                    break;
                }
            }
            if (program === undefined) {
                program = new THREE.WebGLProgram(renderer, code, material, parameters);
                programs.push(program);
            }
            return program;
        };
        WebGLPrograms.prototype.releaseProgram = function (program) {
            var programs = this.programs;
            if (--program.usedTimes === 0) {
                var i = programs.indexOf(program);
                programs[i] = programs[programs.length - 1];
                programs.pop();
                program.destroy();
            }
        };
        return WebGLPrograms;
    }());
    THREE.WebGLPrograms = WebGLPrograms;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WebGLProperties = (function () {
        function WebGLProperties() {
            this.properties = {};
        }
        ;
        WebGLProperties.prototype.get = function (object) {
            var uuid = object.uuid;
            var map = this.properties[uuid];
            if (map === undefined) {
                map = {};
                this.properties[uuid] = map;
            }
            return map;
        };
        ;
        WebGLProperties.prototype.delete = function (object) {
            delete this.properties[object.uuid];
        };
        ;
        WebGLProperties.prototype.clear = function () {
            this.properties = {};
        };
        ;
        return WebGLProperties;
    }());
    THREE.WebGLProperties = WebGLProperties;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    THREE.WebGLShader = (function () {
        function addLineNumbers(string) {
            var lines = string.split('\n');
            for (var i = 0; i < lines.length; i++) {
                lines[i] = (i + 1) + ': ' + lines[i];
            }
            return lines.join('\n');
        }
        return function WebGLShader(gl, type, string) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, string);
            gl.compileShader(shader);
            if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
                console.error('THREE.WebGLShader: Shader couldn\'t compile.');
            }
            if (gl.getShaderInfoLog(shader) !== '') {
                console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader), addLineNumbers(string));
            }
            return shader;
        };
    })();
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WebGLShadowMap = (function () {
        function WebGLShadowMap(_renderer, _lights, _objects, capabilities) {
            this._renderer = _renderer;
            this._objects = _objects;
            this._lights = _lights;
            this._gl = _renderer.context;
            this._state = _renderer.state;
            this._frustum = new THREE.Frustum();
            this._projScreenMatrix = new THREE.Matrix4();
            this._lightShadows = _lights.shadows;
            this._shadowMapSize = new THREE.Vector2();
            this._maxShadowMapSize = new THREE.Vector2(capabilities.maxTextureSize, capabilities.maxTextureSize),
                this._lookTarget = new THREE.Vector3();
            this._lightPositionWorld = new THREE.Vector3();
            this._renderList = [];
            this._MorphingFlag = 1;
            this._SkinningFlag = 2;
            this._NumberOfMaterialVariants = (this._MorphingFlag | this._SkinningFlag) + 1;
            this._depthMaterials = new Array(this._NumberOfMaterialVariants);
            this._distanceMaterials = new Array(this._NumberOfMaterialVariants);
            this._materialCache = {};
            this.cubeDirections = [
                new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 0, 1),
                new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0)
            ];
            this.cubeUps = [
                new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0),
                new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)
            ];
            this.cube2DViewPorts = [
                new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),
                new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()
            ];
            var depthMaterialTemplate = this.depthMaterialTemplate = new THREE.MeshDepthMaterial();
            depthMaterialTemplate.depthPacking = THREE.RGBADepthPacking;
            depthMaterialTemplate.clipping = true;
            var distanceShader = this.distanceShader = THREE.ShaderLib["distanceRGBA"];
            var distanceUniforms = this.distanceUniforms = THREE.UniformsUtils.clone(this.distanceShader.uniforms);
            for (var i = 0; i !== this._NumberOfMaterialVariants; ++i) {
                var useMorphing = (i & this._MorphingFlag) !== 0;
                var useSkinning = (i & this._SkinningFlag) !== 0;
                var depthMaterial = depthMaterialTemplate.clone();
                depthMaterial.morphTargets = useMorphing;
                depthMaterial.skinning = useSkinning;
                this._depthMaterials[i] = depthMaterial;
                var distanceMaterial = new THREE.ShaderMaterial({
                    defines: {
                        'USE_SHADOWMAP': ''
                    },
                    uniforms: distanceUniforms,
                    vertexShader: distanceShader.vertexShader,
                    fragmentShader: distanceShader.fragmentShader,
                    morphTargets: useMorphing,
                    skinning: useSkinning,
                    clipping: true
                });
                this._distanceMaterials[i] = distanceMaterial;
            }
            this.enabled = false;
            this.autoUpdate = true;
            this.needsUpdate = false;
            this.type = THREE.PCFShadowMap;
            this.renderReverseSided = true;
            this.renderSingleSided = true;
        }
        ;
        WebGLShadowMap.prototype.getDepthMaterial = function (object, material, isPointLight, lightPositionWorld) {
            var _depthMaterials = this._depthMaterials;
            var _MorphingFlag = this._MorphingFlag;
            var _distanceMaterials = this._distanceMaterials;
            var _SkinningFlag = this._SkinningFlag;
            var _renderer = this._renderer;
            var _materialCache = this._materialCache;
            var scope = this;
            var geometry = object.geometry;
            var result;
            var materialVariants = _depthMaterials;
            var customMaterial = object.customDepthMaterial;
            if (isPointLight) {
                materialVariants = _distanceMaterials;
                customMaterial = object.customDistanceMaterial;
            }
            if (!customMaterial) {
                var useMorphing = false;
                if (material.morphTargets) {
                    if (geometry instanceof THREE.BufferGeometry) {
                        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
                    }
                    else if (geometry instanceof THREE.Geometry) {
                        useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
                    }
                }
                var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;
                var variantIndex = 0;
                if (useMorphing)
                    variantIndex |= _MorphingFlag;
                if (useSkinning)
                    variantIndex |= _SkinningFlag;
                result = materialVariants[variantIndex];
            }
            else {
                result = customMaterial;
            }
            if (_renderer.localClippingEnabled &&
                material.clipShadows === true &&
                material.clippingPlanes.length !== 0) {
                var keyA = result.uuid, keyB = material.uuid;
                var materialsForVariant = _materialCache[keyA];
                if (materialsForVariant === undefined) {
                    materialsForVariant = {};
                    _materialCache[keyA] = materialsForVariant;
                }
                var cachedMaterial = materialsForVariant[keyB];
                if (cachedMaterial === undefined) {
                    cachedMaterial = result.clone();
                    materialsForVariant[keyB] = cachedMaterial;
                }
                result = cachedMaterial;
            }
            result.visible = material.visible;
            result.wireframe = material.wireframe;
            var side = material.side;
            if (scope.renderSingleSided && side == THREE.DoubleSide) {
                side = THREE.FrontSide;
            }
            if (scope.renderReverseSided) {
                if (side === THREE.FrontSide)
                    side = THREE.BackSide;
                else if (side === THREE.BackSide)
                    side = THREE.FrontSide;
            }
            result.side = side;
            result.clipShadows = material.clipShadows;
            result.clippingPlanes = material.clippingPlanes;
            result.wireframeLinewidth = material.wireframeLinewidth;
            result.linewidth = material.linewidth;
            if (isPointLight && result.uniforms.lightPos !== undefined) {
                result.uniforms.lightPos.value.copy(lightPositionWorld);
            }
            return result;
        };
        WebGLShadowMap.prototype.projectObject = function (object, camera, shadowCamera) {
            var _frustum = this._frustum;
            var _renderList = this._renderList;
            if (object.visible === false)
                return;
            if (object.layers.test(camera.layers) && (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points)) {
                if (object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject(object) === true)) {
                    var material = object.material;
                    if (material.visible === true) {
                        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                        _renderList.push(object);
                    }
                }
            }
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
                this.projectObject(children[i], camera, shadowCamera);
            }
        };
        WebGLShadowMap.prototype.render = function (scene, camera) {
            var _lightShadows = this._lightShadows;
            var _state = this._state;
            var _gl = this._gl;
            var _shadowMapSize = this._shadowMapSize;
            var cube2DViewPorts = this.cube2DViewPorts;
            var _lightPositionWorld = this._lightPositionWorld;
            var _renderer = this._renderer;
            var _lookTarget = this._lookTarget;
            var cubeDirections = this.cubeDirections;
            var cubeUps = this.cubeUps;
            var _projScreenMatrix = this._projScreenMatrix;
            var _frustum = this._frustum;
            var _renderList = this._renderList;
            var _objects = this._objects;
            if (this.enabled === false)
                return;
            if (this.autoUpdate === false && this.needsUpdate === false)
                return;
            if (_lightShadows.length === 0)
                return;
            _state.clearColor(1, 1, 1, 1);
            _state.disable(_gl.BLEND);
            _state.setDepthTest(true);
            _state.setScissorTest(false);
            var faceCount;
            var isPointLight;
            for (var i = 0, il = _lightShadows.length; i < il; i++) {
                var light = _lightShadows[i];
                var shadow = light.shadow;
                if (shadow === undefined) {
                    console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                    continue;
                }
                var shadowCamera = shadow.camera;
                _shadowMapSize.copy(shadow.mapSize);
                _shadowMapSize.min(this._maxShadowMapSize);
                if (light instanceof THREE.PointLight) {
                    faceCount = 6;
                    isPointLight = true;
                    var vpWidth = _shadowMapSize.x;
                    var vpHeight = _shadowMapSize.y;
                    cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
                    cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
                    cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
                    cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
                    cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
                    cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
                    _shadowMapSize.x *= 4.0;
                    _shadowMapSize.y *= 2.0;
                }
                else {
                    faceCount = 1;
                    isPointLight = false;
                }
                if (shadow.map === null) {
                    var pars = {
                        minFilter: THREE.NearestFilter,
                        magFilter: THREE.NearestFilter,
                        format: THREE.RGBAFormat
                    };
                    shadow.map = new THREE.WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                    shadowCamera.updateProjectionMatrix();
                }
                if (shadow instanceof THREE.SpotLightShadow) {
                    shadow.update(light);
                }
                var shadowMap = shadow.map;
                var shadowMatrix = shadow.matrix;
                _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
                shadowCamera.position.copy(_lightPositionWorld);
                _renderer.setRenderTarget(shadowMap);
                _renderer.clear();
                for (var face = 0; face < faceCount; face++) {
                    if (isPointLight) {
                        _lookTarget.copy(shadowCamera.position);
                        _lookTarget.add(cubeDirections[face]);
                        shadowCamera.up.copy(cubeUps[face]);
                        shadowCamera.lookAt(_lookTarget);
                        var vpDimensions = cube2DViewPorts[face];
                        _state.viewport(vpDimensions);
                    }
                    else {
                        _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
                        shadowCamera.lookAt(_lookTarget);
                    }
                    shadowCamera.updateMatrixWorld();
                    shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);
                    shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
                    shadowMatrix.multiply(shadowCamera.projectionMatrix);
                    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
                    _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
                    _frustum.setFromMatrix(_projScreenMatrix);
                    _renderList.length = 0;
                    this.projectObject(scene, camera, shadowCamera);
                    for (var j = 0, jl = _renderList.length; j < jl; j++) {
                        var object = _renderList[j];
                        var geometry = _objects.update(object);
                        var material = object.material;
                        if (material instanceof THREE.MultiMaterial) {
                            var groups = geometry.groups;
                            var materials = material.materials;
                            for (var k = 0, kl = groups.length; k < kl; k++) {
                                var group = groups[k];
                                var groupMaterial = materials[group.materialIndex];
                                if (groupMaterial.visible === true) {
                                    var depthMaterial = this.getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld);
                                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                                }
                            }
                        }
                        else {
                            var depthMaterial = this.getDepthMaterial(object, material, isPointLight, _lightPositionWorld);
                            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                        }
                    }
                }
            }
            var clearColor = _renderer.getClearColor();
            var clearAlpha = _renderer.getClearAlpha();
            _renderer.setClearColor(clearColor, clearAlpha);
            this.needsUpdate = false;
        };
        ;
        return WebGLShadowMap;
    }());
    THREE.WebGLShadowMap = WebGLShadowMap;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WebGLState = (function () {
        function WebGLState(renderer) {
            var _this = this;
            var gl = this.gl = renderer.context;
            var extensions = this.extensions = renderer.extensions;
            this.renderer = renderer;
            this.buffers = {
                color: new WebGLColorBuffer(gl, this),
                depth: new WebGLDepthBuffer(gl, this),
                stencil: new WebGLStencilBuffer(gl, this)
            };
            this.maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
            this.newAttributes = new Uint8Array(this.maxVertexAttributes);
            this.enabledAttributes = new Uint8Array(this.maxVertexAttributes);
            this.attributeDivisors = new Uint8Array(this.maxVertexAttributes);
            this.capabilities = {};
            this.compressedTextureFormats = null;
            this.currentBlending = null;
            this.currentBlendEquation = null;
            this.currentBlendSrc = null;
            this.currentBlendDst = null;
            this.currentBlendEquationAlpha = null;
            this.currentBlendSrcAlpha = null;
            this.currentBlendDstAlpha = null;
            this.currentPremultipledAlpha = false;
            this.currentFlipSided = null;
            this.currentCullFace = null;
            this.currentLineWidth = null;
            this.currentPolygonOffsetFactor = null;
            this.currentPolygonOffsetUnits = null;
            this.currentScissorTest = null;
            this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            this.currentTextureSlot = null;
            this.currentBoundTextures = {};
            this.currentScissor = new THREE.Vector4();
            this.currentViewport = new THREE.Vector4();
            this.emptyTextures = {};
            this.emptyTextures[gl.TEXTURE_2D] = this.createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
            this.emptyTextures[gl.TEXTURE_CUBE_MAP] = this.createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
        }
        ;
        WebGLState.prototype.createTexture = function (type, target, count) {
            var gl = this.gl;
            var data = new Uint8Array(4);
            var texture = gl.createTexture();
            gl.bindTexture(type, texture);
            gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            for (var i = 0; i < count; i++) {
                gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            }
            return texture;
        };
        WebGLState.prototype.enableAttribute = function (attribute) {
            this.newAttributes[attribute] = 1;
            if (this.enabledAttributes[attribute] === 0) {
                this.gl.enableVertexAttribArray(attribute);
                this.enabledAttributes[attribute] = 1;
            }
            if (this.attributeDivisors[attribute] !== 0) {
                var extension = this.extensions.get('ANGLE_instanced_arrays');
                extension.vertexAttribDivisorANGLE(attribute, 0);
                this.attributeDivisors[attribute] = 0;
            }
        };
        WebGLState.prototype.enableAttributeAndDivisor = function (attribute, meshPerAttribute, extension) {
            this.newAttributes[attribute] = 1;
            if (this.enabledAttributes[attribute] === 0) {
                this.gl.enableVertexAttribArray(attribute);
                this.enabledAttributes[attribute] = 1;
            }
            if (this.attributeDivisors[attribute] !== meshPerAttribute) {
                extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
                this.attributeDivisors[attribute] = meshPerAttribute;
            }
        };
        WebGLState.prototype.disableUnusedAttributes = function () {
            for (var i = 0, l = this.enabledAttributes.length; i !== l; ++i) {
                if (this.enabledAttributes[i] !== this.newAttributes[i]) {
                    this.gl.disableVertexAttribArray(i);
                    this.enabledAttributes[i] = 0;
                }
            }
        };
        WebGLState.prototype.enable = function (id) {
            if (this.capabilities[id] !== true) {
                this.gl.enable(id);
                this.capabilities[id] = true;
            }
        };
        WebGLState.prototype.disable = function (id) {
            if (this.capabilities[id] !== false) {
                this.gl.disable(id);
                this.capabilities[id] = false;
            }
        };
        WebGLState.prototype.getCompressedTextureFormats = function () {
            if (this.compressedTextureFormats === null) {
                this.compressedTextureFormats = [];
                if (this.extensions.get('WEBGL_compressed_texture_pvrtc') ||
                    this.extensions.get('WEBGL_compressed_texture_s3tc') ||
                    this.extensions.get('WEBGL_compressed_texture_etc1')) {
                    var formats = this.gl.getParameter(this.gl.COMPRESSED_TEXTURE_FORMATS);
                    for (var i = 0; i < formats.length; i++) {
                        this.compressedTextureFormats.push(formats[i]);
                    }
                }
            }
            return this.compressedTextureFormats;
        };
        WebGLState.prototype.setBlending = function (blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
            var gl = this.gl;
            if (blending !== THREE.NoBlending) {
                this.enable(gl.BLEND);
            }
            else {
                this.disable(gl.BLEND);
                this.currentBlending = blending;
                return;
            }
            if (blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha) {
                if (blending === THREE.AdditiveBlending) {
                    if (premultipliedAlpha) {
                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                        gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
                    }
                    else {
                        gl.blendEquation(gl.FUNC_ADD);
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                    }
                }
                else if (blending === THREE.SubtractiveBlending) {
                    if (premultipliedAlpha) {
                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                        gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                    }
                    else {
                        gl.blendEquation(gl.FUNC_ADD);
                        gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
                    }
                }
                else if (blending === THREE.MultiplyBlending) {
                    if (premultipliedAlpha) {
                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                        gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                    }
                    else {
                        gl.blendEquation(gl.FUNC_ADD);
                        gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                    }
                }
                else {
                    if (premultipliedAlpha) {
                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    }
                    else {
                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    }
                }
                this.currentBlending = blending;
                this.currentPremultipledAlpha = premultipliedAlpha;
            }
            if (blending === THREE.CustomBlending) {
                blendEquationAlpha = blendEquationAlpha || blendEquation;
                blendSrcAlpha = blendSrcAlpha || blendSrc;
                blendDstAlpha = blendDstAlpha || blendDst;
                if (blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha) {
                    gl.blendEquationSeparate(THREE.paramThreeToGL(this.renderer, blendEquation), THREE.paramThreeToGL(this.renderer, blendEquationAlpha));
                    this.currentBlendEquation = blendEquation;
                    this.currentBlendEquationAlpha = blendEquationAlpha;
                }
                if (blendSrc !== this.currentBlendSrc
                    || blendDst !== this.currentBlendDst
                    || blendSrcAlpha !== this.currentBlendSrcAlpha
                    || blendDstAlpha !== this.currentBlendDstAlpha) {
                    gl.blendFuncSeparate(THREE.paramThreeToGL(this.renderer, blendSrc), THREE.paramThreeToGL(this.renderer, blendDst), THREE.paramThreeToGL(this.renderer, blendSrcAlpha), THREE.paramThreeToGL(this.renderer, blendDstAlpha));
                    this.currentBlendSrc = blendSrc;
                    this.currentBlendDst = blendDst;
                    this.currentBlendSrcAlpha = blendSrcAlpha;
                    this.currentBlendDstAlpha = blendDstAlpha;
                }
            }
            else {
                this.currentBlendEquation = null;
                this.currentBlendSrc = null;
                this.currentBlendDst = null;
                this.currentBlendEquationAlpha = null;
                this.currentBlendSrcAlpha = null;
                this.currentBlendDstAlpha = null;
            }
        };
        WebGLState.prototype.setColorWrite = function (colorWrite) {
            this.buffers.color.setMask(colorWrite);
        };
        WebGLState.prototype.setDepthTest = function (depthTest) {
            this.buffers.depth.setTest(depthTest);
        };
        WebGLState.prototype.setDepthWrite = function (depthWrite) {
            this.buffers.depth.setMask(depthWrite);
        };
        WebGLState.prototype.setDepthFunc = function (depthFunc) {
            this.buffers.depth.setFunc(depthFunc);
        };
        WebGLState.prototype.setStencilTest = function (stencilTest) {
            this.buffers.stencil.setTest(stencilTest);
        };
        WebGLState.prototype.setStencilWrite = function (stencilWrite) {
            this.buffers.stencil.setMask(stencilWrite);
        };
        WebGLState.prototype.setStencilFunc = function (stencilFunc, stencilRef, stencilMask) {
            this.buffers.stencil.setFunc(stencilFunc, stencilRef, stencilMask);
        };
        WebGLState.prototype.setStencilOp = function (stencilFail, stencilZFail, stencilZPass) {
            this.buffers.stencil.setOp(stencilFail, stencilZFail, stencilZPass);
        };
        WebGLState.prototype.setFlipSided = function (flipSided) {
            if (this.currentFlipSided !== flipSided) {
                if (flipSided) {
                    this.gl.frontFace(this.gl.CW);
                }
                else {
                    this.gl.frontFace(this.gl.CCW);
                }
                this.currentFlipSided = flipSided;
            }
        };
        WebGLState.prototype.setCullFace = function (cullFace) {
            var gl = this.gl;
            if (cullFace !== THREE.CullFaceNone) {
                this.enable(gl.CULL_FACE);
                if (cullFace !== this.currentCullFace) {
                    if (cullFace === THREE.CullFaceBack) {
                        gl.cullFace(gl.BACK);
                    }
                    else if (cullFace === THREE.CullFaceFront) {
                        gl.cullFace(gl.FRONT);
                    }
                    else {
                        gl.cullFace(gl.FRONT_AND_BACK);
                    }
                }
            }
            else {
                this.disable(gl.CULL_FACE);
            }
            this.currentCullFace = cullFace;
        };
        WebGLState.prototype.setLineWidth = function (width) {
            if (width !== this.currentLineWidth) {
                this.gl.lineWidth(width);
                this.currentLineWidth = width;
            }
        };
        WebGLState.prototype.setPolygonOffset = function (polygonOffset, factor, units) {
            var gl = this.gl;
            if (polygonOffset) {
                this.enable(gl.POLYGON_OFFSET_FILL);
                if (this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units) {
                    gl.polygonOffset(factor, units);
                    this.currentPolygonOffsetFactor = factor;
                    this.currentPolygonOffsetUnits = units;
                }
            }
            else {
                this.disable(gl.POLYGON_OFFSET_FILL);
            }
        };
        WebGLState.prototype.getScissorTest = function () {
            return this.currentScissorTest;
        };
        WebGLState.prototype.setScissorTest = function (scissorTest) {
            var gl = this.gl;
            this.currentScissorTest = scissorTest;
            if (scissorTest) {
                this.enable(gl.SCISSOR_TEST);
            }
            else {
                this.disable(gl.SCISSOR_TEST);
            }
        };
        WebGLState.prototype.activeTexture = function (webglSlot) {
            var gl = this.gl;
            if (webglSlot === undefined)
                webglSlot = gl.TEXTURE0 + this.maxTextures - 1;
            if (this.currentTextureSlot !== webglSlot) {
                gl.activeTexture(webglSlot);
                this.currentTextureSlot = webglSlot;
            }
        };
        WebGLState.prototype.bindTexture = function (webglType, webglTexture) {
            if (this.currentTextureSlot === null) {
                this.activeTexture();
            }
            var boundTexture = this.currentBoundTextures[this.currentTextureSlot];
            if (boundTexture === undefined) {
                boundTexture = { type: undefined, texture: undefined };
                this.currentBoundTextures[this.currentTextureSlot] = boundTexture;
            }
            if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
                this.gl.bindTexture(webglType, webglTexture || this.emptyTextures[webglType]);
                boundTexture.type = webglType;
                boundTexture.texture = webglTexture;
            }
        };
        WebGLState.prototype.compressedTexImage2D = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            try {
                this.gl.compressedTexImage2D.apply(this.gl, arguments);
            }
            catch (error) {
                console.error(error);
            }
        };
        WebGLState.prototype.texImage2D = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            try {
                this.gl.texImage2D.apply(this.gl, arguments);
            }
            catch (error) {
                console.error(error);
            }
        };
        WebGLState.prototype.clearColor = function (r, g, b, a) {
            this.buffers.color.setClear(r, g, b, a);
        };
        WebGLState.prototype.clearDepth = function (depth) {
            this.buffers.depth.setClear(depth);
        };
        WebGLState.prototype.clearStencil = function (stencil) {
            this.buffers.stencil.setClear(stencil);
        };
        WebGLState.prototype.scissor = function (scissor) {
            if (this.currentScissor.equals(scissor) === false) {
                this.gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
                this.currentScissor.copy(scissor);
            }
        };
        WebGLState.prototype.viewport = function (viewport) {
            if (this.currentViewport.equals(viewport) === false) {
                this.gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
                this.currentViewport.copy(viewport);
            }
        };
        WebGLState.prototype.init = function () {
            this.clearColor(0, 0, 0, 1);
            this.clearDepth(1);
            this.clearStencil(0);
            this.enable(this.gl.DEPTH_TEST);
            this.setDepthFunc(THREE.LessEqualDepth);
            this.setFlipSided(false);
            this.setCullFace(THREE.CullFaceBack);
            this.enable(this.gl.CULL_FACE);
            this.enable(this.gl.BLEND);
            this.setBlending(THREE.NormalBlending);
        };
        WebGLState.prototype.initAttributes = function () {
            for (var i = 0, l = this.newAttributes.length; i < l; i++) {
                this.newAttributes[i] = 0;
            }
        };
        WebGLState.prototype.reset = function () {
            var gl = this.gl;
            for (var i = 0; i < this.enabledAttributes.length; i++) {
                if (this.enabledAttributes[i] === 1) {
                    gl.disableVertexAttribArray(i);
                    this.enabledAttributes[i] = 0;
                }
            }
            this.capabilities = {};
            this.compressedTextureFormats = null;
            this.currentTextureSlot = null;
            this.currentBoundTextures = {};
            this.currentBlending = null;
            this.currentFlipSided = null;
            this.currentCullFace = null;
            this.buffers.color.reset();
            this.buffers.depth.reset();
            this.buffers.stencil.reset();
        };
        return WebGLState;
    }());
    THREE.WebGLState = WebGLState;
    var WebGLColorBuffer = (function () {
        function WebGLColorBuffer(gl, state) {
            this.gl = gl;
            this.state = state;
            this.locked = false;
            this.color = new THREE.Vector4();
            this.currentColorMask = null;
            this.currentColorClear = new THREE.Vector4();
        }
        WebGLColorBuffer.prototype.setMask = function (colorMask) {
            if (this.currentColorMask !== colorMask && !this.locked) {
                this.gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                this.currentColorMask = colorMask;
            }
        };
        WebGLColorBuffer.prototype.setLocked = function (lock) {
            this.locked = lock;
        };
        WebGLColorBuffer.prototype.setClear = function (r, g, b, a) {
            this.color.set(r, g, b, a);
            if (this.currentColorClear.equals(this.color) === false) {
                this.gl.clearColor(r, g, b, a);
                this.currentColorClear.copy(this.color);
            }
        };
        WebGLColorBuffer.prototype.reset = function () {
            this.locked = false;
            this.currentColorMask = null;
            this.currentColorClear = new THREE.Vector4();
        };
        return WebGLColorBuffer;
    }());
    THREE.WebGLColorBuffer = WebGLColorBuffer;
    var WebGLDepthBuffer = (function () {
        function WebGLDepthBuffer(gl, state) {
            this.locked = false;
            this.currentDepthMask = null;
            this.currentDepthFunc = null;
            this.currentDepthClear = null;
            this.gl = gl;
            this.state = state;
        }
        WebGLDepthBuffer.prototype.setTest = function (depthTest) {
            if (depthTest) {
                this.state.enable(this.gl.DEPTH_TEST);
            }
            else {
                this.state.disable(this.gl.DEPTH_TEST);
            }
        };
        WebGLDepthBuffer.prototype.setMask = function (depthMask) {
            if (this.currentDepthMask !== depthMask && !this.locked) {
                this.gl.depthMask(depthMask);
                this.currentDepthMask = depthMask;
            }
        };
        WebGLDepthBuffer.prototype.setFunc = function (depthFunc) {
            var gl = this.gl;
            if (this.currentDepthFunc !== depthFunc) {
                if (depthFunc) {
                    switch (depthFunc) {
                        case THREE.NeverDepth:
                            gl.depthFunc(gl.NEVER);
                            break;
                        case THREE.AlwaysDepth:
                            gl.depthFunc(gl.ALWAYS);
                            break;
                        case THREE.LessDepth:
                            gl.depthFunc(gl.LESS);
                            break;
                        case THREE.LessEqualDepth:
                            gl.depthFunc(gl.LEQUAL);
                            break;
                        case THREE.EqualDepth:
                            gl.depthFunc(gl.EQUAL);
                            break;
                        case THREE.GreaterEqualDepth:
                            gl.depthFunc(gl.GEQUAL);
                            break;
                        case THREE.GreaterDepth:
                            gl.depthFunc(gl.GREATER);
                            break;
                        case THREE.NotEqualDepth:
                            gl.depthFunc(gl.NOTEQUAL);
                            break;
                        default:
                            gl.depthFunc(gl.LEQUAL);
                    }
                }
                else {
                    gl.depthFunc(gl.LEQUAL);
                }
                this.currentDepthFunc = depthFunc;
            }
        };
        WebGLDepthBuffer.prototype.setLocked = function (lock) {
            this.locked = lock;
        };
        ;
        WebGLDepthBuffer.prototype.setClear = function (depth) {
            if (this.currentDepthClear !== depth) {
                this.gl.clearDepth(depth);
                this.currentDepthClear = depth;
            }
        };
        ;
        WebGLDepthBuffer.prototype.reset = function () {
            this.locked = false;
            this.currentDepthMask = null;
            this.currentDepthFunc = null;
            this.currentDepthClear = null;
        };
        ;
        return WebGLDepthBuffer;
    }());
    THREE.WebGLDepthBuffer = WebGLDepthBuffer;
    var WebGLStencilBuffer = (function () {
        function WebGLStencilBuffer(gl, state) {
            this.locked = false;
            this.currentStencilMask = null;
            this.currentStencilFunc = null;
            this.currentStencilRef = null;
            this.currentStencilFuncMask = null;
            this.currentStencilFail = null;
            this.currentStencilZFail = null;
            this.currentStencilZPass = null;
            this.currentStencilClear = null;
            this.gl = gl;
            this.state = state;
        }
        WebGLStencilBuffer.prototype.setTest = function (stencilTest) {
            if (stencilTest) {
                this.state.enable(this.gl.STENCIL_TEST);
            }
            else {
                this.state.disable(this.gl.STENCIL_TEST);
            }
        };
        WebGLStencilBuffer.prototype.setMask = function (stencilMask) {
            if (this.currentStencilMask !== stencilMask && !this.locked) {
                this.gl.stencilMask(stencilMask);
                this.currentStencilMask = stencilMask;
            }
        };
        WebGLStencilBuffer.prototype.setFunc = function (stencilFunc, stencilRef, stencilMask) {
            if (this.currentStencilFunc !== stencilFunc ||
                this.currentStencilRef !== stencilRef ||
                this.currentStencilFuncMask !== stencilMask) {
                this.gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                this.currentStencilFunc = stencilFunc;
                this.currentStencilRef = stencilRef;
                this.currentStencilFuncMask = stencilMask;
            }
        };
        WebGLStencilBuffer.prototype.setOp = function (stencilFail, stencilZFail, stencilZPass) {
            if (this.currentStencilFail !== stencilFail ||
                this.currentStencilZFail !== stencilZFail ||
                this.currentStencilZPass !== stencilZPass) {
                this.gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                this.currentStencilFail = stencilFail;
                this.currentStencilZFail = stencilZFail;
                this.currentStencilZPass = stencilZPass;
            }
        };
        WebGLStencilBuffer.prototype.setLocked = function (lock) {
            this.locked = lock;
        };
        WebGLStencilBuffer.prototype.setClear = function (stencil) {
            if (this.currentStencilClear !== stencil) {
                this.gl.clearStencil(stencil);
                this.currentStencilClear = stencil;
            }
        };
        WebGLStencilBuffer.prototype.reset = function () {
            this.locked = false;
            this.currentStencilMask = null;
            this.currentStencilFunc = null;
            this.currentStencilRef = null;
            this.currentStencilFuncMask = null;
            this.currentStencilFail = null;
            this.currentStencilZFail = null;
            this.currentStencilZPass = null;
            this.currentStencilClear = null;
        };
        return WebGLStencilBuffer;
    }());
    THREE.WebGLStencilBuffer = WebGLStencilBuffer;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var WebGLTextures = (function () {
        function WebGLTextures(renderer) {
            this._renderer = renderer;
            this._gl = renderer.context;
            this.extensions = renderer.extensions;
            this.state = renderer.state;
            this.properties = renderer.properties;
            this.capabilities = renderer.capabilities;
            this.info = renderer.info;
            this._infoMemory = this.info.memory;
            this._isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && this._gl instanceof WebGL2RenderingContext);
        }
        ;
        WebGLTextures.prototype.clampToMaxSize = function (image, maxSize) {
            if (image.width > maxSize || image.height > maxSize) {
                var scale = maxSize / THREE.Math.max(image.width, image.height);
                var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                canvas.width = THREE.Math.floor(image.width * scale);
                canvas.height = THREE.Math.floor(image.height * scale);
                var context = canvas.getContext('2d');
                context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
                console.warn('THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
                return canvas;
            }
            return image;
        };
        WebGLTextures.prototype.isPowerOfTwo = function (image) {
            return THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height);
        };
        WebGLTextures.prototype.makePowerOfTwo = function (image) {
            if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
                var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                canvas.width = THREE.Math.nearestPowerOfTwo(image.width);
                canvas.height = THREE.Math.nearestPowerOfTwo(image.height);
                var context = canvas.getContext('2d');
                context.drawImage(image, 0, 0, canvas.width, canvas.height);
                console.warn('THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
                return canvas;
            }
            return image;
        };
        WebGLTextures.prototype.textureNeedsPowerOfTwo = function (texture) {
            if (texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping)
                return true;
            if (texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter)
                return true;
            return false;
        };
        WebGLTextures.prototype.filterFallback = function (f) {
            if (f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter) {
                return this._gl.NEAREST;
            }
            return this._gl.LINEAR;
        };
        WebGLTextures.prototype.onTextureDispose = function (event) {
            var texture = event.target;
            texture.removeEventListener('dispose', this.onTextureDispose, this);
            this.deallocateTexture(texture);
            this._infoMemory.textures--;
        };
        WebGLTextures.prototype.onRenderTargetDispose = function (event) {
            var renderTarget = event.target;
            renderTarget.removeEventListener('dispose', this.onRenderTargetDispose, this);
            this.deallocateRenderTarget(renderTarget);
            this._infoMemory.textures--;
        };
        WebGLTextures.prototype.deallocateTexture = function (texture) {
            var _gl = this._gl;
            var properties = this.properties;
            var textureProperties = properties.get(texture);
            if (texture.image && textureProperties.__image__webglTextureCube) {
                _gl.deleteTexture(textureProperties.__image__webglTextureCube);
            }
            else {
                if (textureProperties.__webglInit === undefined)
                    return;
                _gl.deleteTexture(textureProperties.__webglTexture);
            }
            properties.delete(texture);
        };
        WebGLTextures.prototype.deallocateRenderTarget = function (renderTarget) {
            var properties = this.properties;
            var _gl = this._gl;
            var renderTargetProperties = properties.get(renderTarget);
            var textureProperties = properties.get(renderTarget.texture);
            if (!renderTarget)
                return;
            if (textureProperties.__webglTexture !== undefined) {
                _gl.deleteTexture(textureProperties.__webglTexture);
            }
            if (renderTarget.depthTexture) {
                renderTarget.depthTexture.dispose();
            }
            if (renderTarget instanceof THREE.WebGLRenderTargetCube) {
                for (var i = 0; i < 6; i++) {
                    _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
                    if (renderTargetProperties.__webglDepthbuffer)
                        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
                }
            }
            else {
                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
                if (renderTargetProperties.__webglDepthbuffer)
                    _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            }
            properties.delete(renderTarget.texture);
            properties.delete(renderTarget);
        };
        WebGLTextures.prototype.setTextureParameters = function (textureType, texture, isPowerOfTwoImage) {
            var _gl = this._gl;
            var extensions = this.extensions;
            var properties = this.properties;
            var extension;
            if (isPowerOfTwoImage) {
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, THREE.paramThreeToGL(this._renderer, texture.wrapS));
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, THREE.paramThreeToGL(this._renderer, texture.wrapT));
                _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, THREE.paramThreeToGL(this._renderer, texture.magFilter));
                _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, THREE.paramThreeToGL(this._renderer, texture.minFilter));
            }
            else {
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
                if (texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping) {
                    console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture);
                }
                _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, this.filterFallback(texture.magFilter));
                _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, this.filterFallback(texture.minFilter));
                if (texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter) {
                    console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture);
                }
            }
            extension = extensions.get('EXT_texture_filter_anisotropic');
            if (extension) {
                if (texture.type === THREE.FloatType && extensions.get('OES_texture_float_linear') === null)
                    return;
                if (texture.type === THREE.HalfFloatType && extensions.get('OES_texture_half_float_linear') === null)
                    return;
                if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                    _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, THREE.Math.min(texture.anisotropy, this.capabilities.getMaxAnisotropy()));
                    properties.get(texture).__currentAnisotropy = texture.anisotropy;
                }
            }
        };
        WebGLTextures.prototype.uploadTexture = function (textureProperties, texture, slot) {
            var _gl = this._gl;
            var _infoMemory = this._infoMemory;
            var state = this.state;
            var capabilities = this.capabilities;
            var _isWebGL2 = this._isWebGL2;
            if (textureProperties.__webglInit === undefined) {
                textureProperties.__webglInit = true;
                texture.addEventListener('dispose', this.onTextureDispose, this);
                textureProperties.__webglTexture = _gl.createTexture();
                _infoMemory.textures++;
            }
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY ? 1 : 0);
            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha ? 1 : 0);
            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
            var image = this.clampToMaxSize(texture.image, capabilities.maxTextureSize);
            if (this.textureNeedsPowerOfTwo(texture) && this.isPowerOfTwo(image) === false) {
                image = this.makePowerOfTwo(image);
            }
            var isPowerOfTwoImage = this.isPowerOfTwo(image), glFormat = THREE.paramThreeToGL(this._renderer, texture.format), glType = THREE.paramThreeToGL(this._renderer, texture.type);
            this.setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);
            var mipmap, mipmaps = texture.mipmaps;
            if (texture instanceof THREE.DepthTexture) {
                var internalFormat = _gl.DEPTH_COMPONENT;
                if (texture.type === THREE.FloatType) {
                    if (!_isWebGL2)
                        throw new Error('Float Depth Texture only supported in WebGL2.0');
                    internalFormat = _gl["DEPTH_COMPONENT32F"];
                }
                else if (_isWebGL2) {
                    internalFormat = _gl.DEPTH_COMPONENT16;
                }
                state.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null);
            }
            else if (texture instanceof THREE.DataTexture) {
                if (mipmaps.length > 0 && isPowerOfTwoImage) {
                    for (var i = 0, il = mipmaps.length; i < il; i++) {
                        mipmap = mipmaps[i];
                        state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                    texture.generateMipmaps = false;
                }
                else {
                    state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
                }
            }
            else if (texture instanceof THREE.CompressedTexture) {
                for (var i = 0, il = mipmaps.length; i < il; i++) {
                    mipmap = mipmaps[i];
                    if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {
                        if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                            state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                        }
                        else {
                            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                        }
                    }
                    else {
                        state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                }
            }
            else {
                if (mipmaps.length > 0 && isPowerOfTwoImage) {
                    for (var i = 0, il = mipmaps.length; i < il; i++) {
                        mipmap = mipmaps[i];
                        state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
                    }
                    texture.generateMipmaps = false;
                }
                else {
                    state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);
                }
            }
            if (texture.generateMipmaps && isPowerOfTwoImage)
                _gl.generateMipmap(_gl.TEXTURE_2D);
            textureProperties.__version = texture.version;
            if (texture.onUpdate)
                texture.onUpdate(texture);
        };
        WebGLTextures.prototype.setupFrameBufferTexture = function (framebuffer, renderTarget, attachment, textureTarget) {
            var glFormat = THREE.paramThreeToGL(this._renderer, renderTarget.texture.format);
            var glType = THREE.paramThreeToGL(this._renderer, renderTarget.texture.type);
            this.state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);
            this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, attachment, textureTarget, this.properties.get(renderTarget.texture).__webglTexture, 0);
            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
        };
        WebGLTextures.prototype.setupRenderBufferStorage = function (renderbuffer, renderTarget) {
            var _gl = this._gl;
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
            if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
            }
            else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
            }
            else {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
            }
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        };
        WebGLTextures.prototype.setupDepthTexture = function (framebuffer, renderTarget) {
            var _gl = this._gl;
            var properties = this.properties;
            var isCube = (renderTarget instanceof THREE.WebGLRenderTargetCube);
            if (isCube)
                throw new Error('Depth Texture with cube render targets is not supported!');
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            if (!(renderTarget.depthTexture instanceof THREE.DepthTexture)) {
                throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
            }
            if (!properties.get(renderTarget.depthTexture).__webglTexture ||
                renderTarget.depthTexture.image.width !== renderTarget.width ||
                renderTarget.depthTexture.image.height !== renderTarget.height) {
                renderTarget.depthTexture.image.width = renderTarget.width;
                renderTarget.depthTexture.image.height = renderTarget.height;
                renderTarget.depthTexture.needsUpdate = true;
            }
            this.setTexture2D(renderTarget.depthTexture, 0);
            var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
        };
        WebGLTextures.prototype.setupDepthRenderbuffer = function (renderTarget) {
            var properties = this.properties;
            var _gl = this._gl;
            var renderTargetProperties = properties.get(renderTarget);
            var isCube = (renderTarget instanceof THREE.WebGLRenderTargetCube);
            if (renderTarget.depthTexture) {
                if (isCube)
                    throw new Error('target.depthTexture not supported in Cube render targets');
                this.setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
            }
            else {
                if (isCube) {
                    renderTargetProperties.__webglDepthbuffer = [];
                    for (var i = 0; i < 6; i++) {
                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
                        renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                        this.setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
                    }
                }
                else {
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                    renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                    this.setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
                }
            }
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        };
        WebGLTextures.prototype.setTexture2D = function (texture, slot) {
            var textureProperties = this.properties.get(texture);
            var _gl = this._gl;
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                var image = texture.image;
                if (image === undefined) {
                    console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined', texture);
                }
                else if (image.complete === false) {
                    console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture);
                }
                else {
                    this.uploadTexture(textureProperties, texture, slot);
                    return;
                }
            }
            this.state.activeTexture(_gl.TEXTURE0 + slot);
            this.state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
        };
        WebGLTextures.prototype.setTextureCube = function (texture, slot) {
            var properties = this.properties;
            var _gl = this._gl;
            var state = this.state;
            var textureProperties = properties.get(texture);
            var capabilities = this.capabilities;
            if (texture.image.length === 6) {
                if (texture.version > 0 && textureProperties.__version !== texture.version) {
                    if (!textureProperties.__image__webglTextureCube) {
                        texture.addEventListener('dispose', this.onTextureDispose, this);
                        textureProperties.__image__webglTextureCube = _gl.createTexture();
                        this._infoMemory.textures++;
                    }
                    state.activeTexture(_gl.TEXTURE0 + slot);
                    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
                    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY ? 1 : 0);
                    var isCompressed = texture instanceof THREE.CompressedTexture;
                    var isDataTexture = texture.image[0] instanceof THREE.DataTexture;
                    var cubeImage = [];
                    for (var i = 0; i < 6; i++) {
                        if (!isCompressed && !isDataTexture) {
                            cubeImage[i] = this.clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
                        }
                        else {
                            cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
                        }
                    }
                    var image = cubeImage[0], isPowerOfTwoImage = this.isPowerOfTwo(image), glFormat = THREE.paramThreeToGL(this._renderer, texture.format), glType = THREE.paramThreeToGL(this._renderer, texture.type);
                    this.setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);
                    for (var i = 0; i < 6; i++) {
                        if (!isCompressed) {
                            if (isDataTexture) {
                                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                            }
                            else {
                                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                            }
                        }
                        else {
                            var mipmap, mipmaps = cubeImage[i].mipmaps;
                            for (var j = 0, jl = mipmaps.length; j < jl; j++) {
                                mipmap = mipmaps[j];
                                if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {
                                    if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                                        state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                                    }
                                    else {
                                        console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                                    }
                                }
                                else {
                                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                                }
                            }
                        }
                    }
                    if (texture.generateMipmaps && isPowerOfTwoImage) {
                        _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
                    }
                    textureProperties.__version = texture.version;
                    if (texture.onUpdate)
                        texture.onUpdate(texture);
                }
                else {
                    state.activeTexture(_gl.TEXTURE0 + slot);
                    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
                }
            }
        };
        WebGLTextures.prototype.setTextureCubeDynamic = function (texture, slot) {
            var state = this.state;
            var _gl = this._gl;
            var properties = this.properties;
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
        };
        WebGLTextures.prototype.setupRenderTarget = function (renderTarget) {
            var properties = this.properties;
            var renderTargetProperties = properties.get(renderTarget);
            var textureProperties = properties.get(renderTarget.texture);
            var _gl = this._gl;
            var _infoMemory = this._infoMemory;
            var state = this.state;
            renderTarget.addEventListener('dispose', this.onRenderTargetDispose, this);
            textureProperties.__webglTexture = _gl.createTexture();
            _infoMemory.textures++;
            var isCube = (renderTarget instanceof THREE.WebGLRenderTargetCube);
            var isTargetPowerOfTwo = this.isPowerOfTwo(renderTarget);
            if (isCube) {
                renderTargetProperties.__webglFramebuffer = [];
                for (var i = 0; i < 6; i++) {
                    renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
                }
            }
            else {
                renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            }
            if (isCube) {
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
                this.setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
                for (var i = 0; i < 6; i++) {
                    this.setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
                }
                if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
                    _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
            }
            else {
                state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
                this.setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
                this.setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
                if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
                    _gl.generateMipmap(_gl.TEXTURE_2D);
                state.bindTexture(_gl.TEXTURE_2D, null);
            }
            if (renderTarget.depthBuffer) {
                this.setupDepthRenderbuffer(renderTarget);
            }
        };
        WebGLTextures.prototype.updateRenderTargetMipmap = function (renderTarget) {
            var _gl = this._gl;
            var properties = this.properties;
            var state = this.state;
            var texture = renderTarget.texture;
            if (texture.generateMipmaps && this.isPowerOfTwo(renderTarget) &&
                texture.minFilter !== THREE.NearestFilter &&
                texture.minFilter !== THREE.LinearFilter) {
                var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
                var webglTexture = properties.get(texture).__webglTexture;
                state.bindTexture(target, webglTexture);
                _gl.generateMipmap(target);
                state.bindTexture(target, null);
            }
        };
        return WebGLTextures;
    }());
    THREE.WebGLTextures = WebGLTextures;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var CubeTexture = (function (_super) {
        __extends(CubeTexture, _super);
        function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
            images = images !== undefined ? images : [];
            mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;
            _super.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
            this.flipY = false;
        }
        Object.defineProperty(CubeTexture.prototype, "images", {
            get: function () {
                return this.image;
            },
            set: function (value) {
                this.image = value;
            },
            enumerable: true,
            configurable: true
        });
        return CubeTexture;
    }(THREE.Texture));
    THREE.CubeTexture = CubeTexture;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var StructuredUniform = (function () {
        function StructuredUniform(id) {
            this.seq = [];
            this.map = {};
            this.id = id;
            this.seq = [];
            this.map = {};
        }
        ;
        StructuredUniform.prototype.setValue = function (gl, value) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var seq = this.seq;
            for (var i = 0, n = seq.length; i !== n; ++i) {
                var u = seq[i];
                u.setValue(gl, value[u.id]);
            }
        };
        return StructuredUniform;
    }());
    THREE.StructuredUniform = StructuredUniform;
    var SingleUniform = (function () {
        function SingleUniform(id, activeInfo, addr, singularSetter) {
            this.id = id;
            this.addr = addr;
            this.setValue = singularSetter;
        }
        return SingleUniform;
    }());
    THREE.SingleUniform = SingleUniform;
    var PureArrayUniform = (function () {
        function PureArrayUniform(id, activeInfo, addr, pureArraySetter) {
            this.id = id;
            this.addr = addr;
            this.size = activeInfo.size;
            this.setValue = pureArraySetter;
        }
        return PureArrayUniform;
    }());
    THREE.PureArrayUniform = PureArrayUniform;
    var WebGLUniforms = (function () {
        function WebGLUniforms(gl, program, renderer) {
            this.seq = [];
            this.map = {};
            this.seq = [];
            this.map = {};
            this.gl = gl;
            this.renderer = renderer;
            var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
            for (var i = 0; i !== n; ++i) {
                var info = gl.getActiveUniform(program, i);
                var path = info.name;
                var addr = gl.getUniformLocation(program, path);
                WebGLUniforms.parseUniform(info, addr, this);
            }
        }
        ;
        WebGLUniforms.prototype.setValue = function (gl, name, value) {
            var u = this.map[name];
            if (u !== undefined)
                u.setValue(gl, value, this.renderer);
        };
        WebGLUniforms.prototype.set = function (gl, object, name) {
            var u = this.map[name];
            if (u !== undefined)
                u.setValue(gl, object[name], this.renderer);
        };
        WebGLUniforms.prototype.setOptional = function (gl, object, name) {
            var v = object[name];
            if (v !== undefined)
                this.setValue(gl, name, v);
        };
        WebGLUniforms.upload = function (gl, seq, values, renderer) {
            for (var i = 0, n = seq.length; i !== n; ++i) {
                var u = seq[i];
                var v = values[u.id];
                if (v.needsUpdate !== false) {
                    u.setValue(gl, v.value, renderer);
                }
            }
        };
        ;
        WebGLUniforms.seqWithValue = function (seq, values) {
            var r = [];
            for (var i = 0, n = seq.length; i !== n; ++i) {
                var u = seq[i];
                if (u.id in values)
                    r.push(u);
            }
            return r;
        };
        WebGLUniforms.splitDynamic = function (seq, values) {
            var r = null, n = seq.length, w = 0;
            for (var i = 0; i !== n; ++i) {
                var u = seq[i], v = values[u.id];
                if (v && v.dynamic === true) {
                    if (r === null)
                        r = [];
                    r.push(u);
                }
                else {
                    if (w < i)
                        seq[w] = u;
                    ++w;
                }
            }
            if (w < n)
                seq.length = w;
            return r;
        };
        WebGLUniforms.evalDynamic = function (seq, values, object, camera) {
            for (var i = 0, n = seq.length; i !== n; ++i) {
                var v = values[seq[i].id], f = v.onUpdateCallback;
                if (f !== undefined)
                    f.call(v, object, camera);
            }
        };
        WebGLUniforms.uncacheTemporaryArrays = function () {
            WebGLUniforms.arrayCacheF32.length = 0;
            WebGLUniforms.arrayCacheI32.length = 0;
        };
        WebGLUniforms.flatten = function (array, nBlocks, blockSize) {
            var arrayCacheF32 = WebGLUniforms.arrayCacheF32;
            var firstElem = array[0];
            if (firstElem <= 0 || firstElem > 0)
                return array;
            var n = nBlocks * blockSize, r = arrayCacheF32[n];
            if (r === undefined) {
                r = new Float32Array(n);
                arrayCacheF32[n] = r;
            }
            if (nBlocks !== 0) {
                firstElem.toArray(r, 0);
                for (var i = 1, offset = 0; i !== nBlocks; ++i) {
                    offset += blockSize;
                    array[i].toArray(r, offset);
                }
            }
            return r;
        };
        WebGLUniforms.allocTexUnits = function (renderer, n) {
            var arrayCacheI32 = WebGLUniforms.arrayCacheI32;
            var r = arrayCacheI32[n];
            if (r === undefined) {
                r = new Int32Array(n);
                arrayCacheI32[n] = r;
            }
            for (var i = 0; i !== n; ++i)
                r[i] = renderer.allocTextureUnit();
            return r;
        };
        WebGLUniforms.getSingularSetter = function (type) {
            switch (type) {
                case 0x1406: return WebGLUniforms.setValue1f;
                case 0x8b50: return WebGLUniforms.setValue2fv;
                case 0x8b51: return WebGLUniforms.setValue3fv;
                case 0x8b52: return WebGLUniforms.setValue4fv;
                case 0x8b5a: return WebGLUniforms.setValue2fm;
                case 0x8b5b: return WebGLUniforms.setValue3fm;
                case 0x8b5c: return WebGLUniforms.setValue4fm;
                case 0x8b5e: return WebGLUniforms.setValueT1;
                case 0x8b60: return WebGLUniforms.setValueT6;
                case 0x1404:
                case 0x8b56: return WebGLUniforms.setValue1i;
                case 0x8b53:
                case 0x8b57: return WebGLUniforms.setValue2iv;
                case 0x8b54:
                case 0x8b58: return WebGLUniforms.setValue3iv;
                case 0x8b55:
                case 0x8b59: return WebGLUniforms.setValue4iv;
            }
        };
        WebGLUniforms.getPureArraySetter = function (type) {
            switch (type) {
                case 0x1406: return WebGLUniforms.setValue1fv;
                case 0x8b50: return WebGLUniforms.setValueV2a;
                case 0x8b51: return WebGLUniforms.setValueV3a;
                case 0x8b52: return WebGLUniforms.setValueV4a;
                case 0x8b5a: return WebGLUniforms.setValueM2a;
                case 0x8b5b: return WebGLUniforms.setValueM3a;
                case 0x8b5c: return WebGLUniforms.setValueM4a;
                case 0x8b5e: return WebGLUniforms.setValueT1a;
                case 0x8b60: return WebGLUniforms.setValueT6a;
                case 0x1404:
                case 0x8b56: return WebGLUniforms.setValue1iv;
                case 0x8b53:
                case 0x8b57: return WebGLUniforms.setValue2iv;
                case 0x8b54:
                case 0x8b58: return WebGLUniforms.setValue3iv;
                case 0x8b55:
                case 0x8b59: return WebGLUniforms.setValue4iv;
            }
        };
        WebGLUniforms.addUniform = function (container, uniformObject) {
            container.seq.push(uniformObject);
            container.map[uniformObject.id] = uniformObject;
        };
        WebGLUniforms.parseUniform = function (activeInfo, addr, container) {
            var path = activeInfo.name;
            var pathLength = path.length;
            var RePathPart = WebGLUniforms.RePathPart;
            var addUniform = WebGLUniforms.addUniform;
            RePathPart.lastIndex = 0;
            for (;;) {
                var match = RePathPart.exec(path);
                var matchEnd = RePathPart.lastIndex;
                var id = match[1];
                var idIsIndex = match[2] === ']';
                var subscript = match[3];
                if (idIsIndex)
                    id = id | 0;
                if (subscript === undefined ||
                    subscript === '[' && matchEnd + 2 === pathLength) {
                    addUniform(container, subscript === undefined ?
                        new SingleUniform(id, activeInfo, addr, WebGLUniforms.getSingularSetter(activeInfo.type)) :
                        new PureArrayUniform(id, activeInfo, addr, WebGLUniforms.getPureArraySetter(activeInfo.type)));
                    break;
                }
                else {
                    var map = container.map;
                    var next = map[id];
                    if (next === undefined) {
                        next = new StructuredUniform(id);
                        addUniform(container, next);
                    }
                    container = next;
                }
            }
        };
        WebGLUniforms.emptyTexture = new THREE.Texture();
        WebGLUniforms.emptyCubeTexture = new THREE.CubeTexture();
        WebGLUniforms.arrayCacheF32 = [];
        WebGLUniforms.arrayCacheI32 = [];
        WebGLUniforms.setValue1f = function (gl, v) { gl.uniform1f(this.addr, v); };
        WebGLUniforms.setValue1i = function (gl, v) { gl.uniform1i(this.addr, v); };
        WebGLUniforms.setValue2fv = function (gl, v) {
            if (v.x === undefined)
                gl.uniform2fv(this.addr, v);
            else
                gl.uniform2f(this.addr, v.x, v.y);
        };
        WebGLUniforms.setValue3fv = function (gl, v) {
            if (v.x !== undefined)
                gl.uniform3f(this.addr, v.x, v.y, v.z);
            else if (v.r !== undefined)
                gl.uniform3f(this.addr, v.r, v.g, v.b);
            else
                gl.uniform3fv(this.addr, v);
        };
        WebGLUniforms.setValue4fv = function (gl, v) {
            if (v.x === undefined)
                gl.uniform4fv(this.addr, v);
            else
                gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
        };
        WebGLUniforms.setValue2fm = function (gl, v) {
            gl.uniformMatrix2fv(this.addr, false, v.elements || v);
        };
        WebGLUniforms.setValue3fm = function (gl, v) {
            gl.uniformMatrix3fv(this.addr, false, v.elements || v);
        };
        WebGLUniforms.setValue4fm = function (gl, v) {
            gl.uniformMatrix4fv(this.addr, false, v.elements || v);
        };
        WebGLUniforms.setValueT1 = function (gl, v, renderer) {
            var emptyTexture = WebGLUniforms.emptyTexture;
            var unit = renderer.allocTextureUnit();
            gl.uniform1i(this.addr, unit);
            renderer.setTexture2D(v || emptyTexture, unit);
        };
        WebGLUniforms.setValueT6 = function (gl, v, renderer) {
            var emptyTexture = WebGLUniforms.emptyTexture;
            var unit = renderer.allocTextureUnit();
            gl.uniform1i(this.addr, unit);
            renderer.setTextureCube(v || WebGLUniforms.emptyCubeTexture, unit);
        };
        WebGLUniforms.setValue2iv = function (gl, v) {
            gl.uniform2iv(this.addr, v);
        };
        WebGLUniforms.setValue3iv = function (gl, v) {
            gl.uniform3iv(this.addr, v);
        };
        WebGLUniforms.setValue4iv = function (gl, v) {
            gl.uniform4iv(this.addr, v);
        };
        WebGLUniforms.setValue1fv = function (gl, v, renderer) {
            gl.uniform1fv(this.addr, v);
        };
        WebGLUniforms.setValue1iv = function (gl, v, renderer) {
            gl.uniform1iv(this.addr, v);
        };
        WebGLUniforms.setValueV2a = function (gl, v, renderer) {
            gl.uniform2fv(this.addr, WebGLUniforms.flatten(v, this.size, 2));
        };
        WebGLUniforms.setValueV3a = function (gl, v, renderer) {
            gl.uniform3fv(this.addr, WebGLUniforms.flatten(v, this.size, 3));
        };
        WebGLUniforms.setValueV4a = function (gl, v, renderer) {
            gl.uniform4fv(this.addr, WebGLUniforms.flatten(v, this.size, 4));
        };
        WebGLUniforms.setValueM2a = function (gl, v, renderer) {
            gl.uniformMatrix2fv(this.addr, false, WebGLUniforms.flatten(v, this.size, 4));
        };
        WebGLUniforms.setValueM3a = function (gl, v, renderer) {
            gl.uniformMatrix3fv(this.addr, false, WebGLUniforms.flatten(v, this.size, 9));
        };
        WebGLUniforms.setValueM4a = function (gl, v, renderer) {
            gl.uniformMatrix4fv(this.addr, false, WebGLUniforms.flatten(v, this.size, 16));
        };
        WebGLUniforms.setValueT1a = function (gl, v, renderer) {
            var n = v.length, units = WebGLUniforms.allocTexUnits(renderer, n);
            gl.uniform1iv(this.addr, units);
            for (var i = 0; i !== n; ++i) {
                renderer.setTexture2D(v[i] || WebGLUniforms.emptyTexture, units[i]);
            }
        };
        WebGLUniforms.setValueT6a = function (gl, v, renderer) {
            var n = v.length, units = WebGLUniforms.allocTexUnits(renderer, n);
            gl.uniform1iv(this.addr, units);
            for (var i = 0; i !== n; ++i) {
                renderer.setTextureCube(v[i] || WebGLUniforms.emptyCubeTexture, units[i]);
            }
        };
        WebGLUniforms.RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
        return WebGLUniforms;
    }());
    THREE.WebGLUniforms = WebGLUniforms;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Fog = (function () {
        function Fog(color, near, far) {
            this.name = '';
            this.color = new THREE.Color(color);
            this.near = (near !== undefined) ? near : 1;
            this.far = (far !== undefined) ? far : 1000;
        }
        ;
        Fog.prototype.clone = function () {
            return new Fog(this.color.getHex(), this.near, this.far);
        };
        ;
        return Fog;
    }());
    THREE.Fog = Fog;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var FogExp2 = (function () {
        function FogExp2(color, density) {
            this.name = '';
            this.name = '';
            this.color = new THREE.Color(color);
            this.density = (density !== undefined) ? density : 0.00025;
        }
        ;
        FogExp2.prototype.clone = function () {
            return new FogExp2(this.color.getHex(), this.density);
        };
        ;
        return FogExp2;
    }());
    THREE.FogExp2 = FogExp2;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var Scene = (function (_super) {
        __extends(Scene, _super);
        function Scene() {
            _super.call(this);
            this.background = null;
            this.fog = null;
            this.overrideMaterial = null;
            this.autoUpdate = true;
            this.type = 'Scene';
        }
        ;
        Scene.prototype.copy = function (source, recursive) {
            _super.prototype.copy.call(this, source, recursive);
            if (source.background !== null)
                this.background = source.background.clone();
            if (source.fog !== null)
                this.fog = source.fog.clone();
            if (source.overrideMaterial !== null)
                this.overrideMaterial = source.overrideMaterial.clone();
            this.autoUpdate = source.autoUpdate;
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            return this;
        };
        ;
        return Scene;
    }(THREE.Object3D));
    THREE.Scene = Scene;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var CanvasTexture = (function (_super) {
        __extends(CanvasTexture, _super);
        function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
            _super.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
            this.needsUpdate = true;
        }
        ;
        return CanvasTexture;
    }(THREE.Texture));
    THREE.CanvasTexture = CanvasTexture;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var CompressedTexture = (function (_super) {
        __extends(CompressedTexture, _super);
        function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
            _super.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
            this.image = { width: width, height: height };
            this.mipmaps = mipmaps;
            this.flipY = false;
            this.generateMipmaps = false;
        }
        ;
        return CompressedTexture;
    }(THREE.Texture));
    THREE.CompressedTexture = CompressedTexture;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var DataTexture = (function (_super) {
        __extends(DataTexture, _super);
        function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
            _super.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
            this.image = { data: data, width: width, height: height };
            this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
            this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;
            this.flipY = false;
            this.generateMipmaps = false;
        }
        ;
        return DataTexture;
    }(THREE.Texture));
    THREE.DataTexture = DataTexture;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var DepthTexture = (function (_super) {
        __extends(DepthTexture, _super);
        function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
            _super.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, THREE.DepthFormat, type, anisotropy);
            this.image = { width: width, height: height };
            this.type = type !== undefined ? type : THREE.UnsignedShortType;
            this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
            this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;
            this.flipY = false;
            this.generateMipmaps = false;
        }
        ;
        return DepthTexture;
    }(THREE.Texture));
    THREE.DepthTexture = DepthTexture;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var VideoTexture = (function (_super) {
        __extends(VideoTexture, _super);
        function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
            _super.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
            this.generateMipmaps = false;
            var scope = this;
            function update() {
                requestAnimationFrame(update);
                if (video.readyState >= video.HAVE_CURRENT_DATA) {
                    scope.needsUpdate = true;
                }
            }
            update();
        }
        ;
        return VideoTexture;
    }(THREE.Texture));
    THREE.VideoTexture = VideoTexture;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    Object.assign(THREE, {
        Face4: function (a, b, c, d, normal, color, materialIndex) {
            console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
            return new THREE.Face3(a, b, c, normal, color, materialIndex);
        },
        LineStrip: 0,
        LinePieces: 1,
        MeshFaceMaterial: THREE.MultiMaterial,
        PointCloud: function (geometry, material) {
            console.warn('THREE.PointCloud has been renamed to THREE.Points.');
            return new THREE.Points(geometry, material);
        },
        Particle: THREE.Sprite,
        ParticleSystem: function (geometry, material) {
            console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
            return new THREE.Points(geometry, material);
        },
        PointCloudMaterial: function (parameters) {
            console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
            return new THREE.PointsMaterial(parameters);
        },
        ParticleBasicMaterial: function (parameters) {
            console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
            return new THREE.PointsMaterial(parameters);
        },
        ParticleSystemMaterial: function (parameters) {
            console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
            return new THREE.PointsMaterial(parameters);
        },
        Vertex: function (x, y, z) {
            console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
            return new THREE.Vector3(x, y, z);
        }
    });
    Object.assign(THREE.Box2.prototype, {
        empty: function () {
            console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
            return this.isEmpty();
        },
        isIntersectionBox: function (box) {
            console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
            return this.intersectsBox(box);
        }
    });
    Object.assign(THREE.Box3.prototype, {
        empty: function () {
            console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
            return this.isEmpty();
        },
        isIntersectionBox: function (box) {
            console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
            return this.intersectsBox(box);
        },
        isIntersectionSphere: function (sphere) {
            console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
            return this.intersectsSphere(sphere);
        }
    });
    Object.assign(THREE.Matrix3.prototype, {
        multiplyVector3: function (vector) {
            console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
            return vector.applyMatrix3(this);
        },
        multiplyVector3Array: function (a) {
            console.warn('THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
            return this.applyToVector3Array(a);
        }
    });
    Object.assign(THREE.Matrix4.prototype, {
        extractPosition: function (m) {
            console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
            return this.copyPosition(m);
        },
        setRotationFromQuaternion: function (q) {
            console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
            return this.makeRotationFromQuaternion(q);
        },
        multiplyVector3: function (vector) {
            console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.');
            return vector.applyProjection(this);
        },
        multiplyVector4: function (vector) {
            console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
            return vector.applyMatrix4(this);
        },
        multiplyVector3Array: function (a) {
            console.warn('THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
            return this.applyToVector3Array(a);
        },
        rotateAxis: function (v) {
            console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
            v.transformDirection(this);
        },
        crossVector: function (vector) {
            console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
            return vector.applyMatrix4(this);
        },
        translate: function (v) {
            console.error('THREE.Matrix4: .translate() has been removed.');
        },
        rotateX: function (angle) {
            console.error('THREE.Matrix4: .rotateX() has been removed.');
        },
        rotateY: function (angle) {
            console.error('THREE.Matrix4: .rotateY() has been removed.');
        },
        rotateZ: function (angle) {
            console.error('THREE.Matrix4: .rotateZ() has been removed.');
        },
        rotateByAxis: function (axis, angle) {
            console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
        }
    });
    Object.assign(THREE.Plane.prototype, {
        isIntersectionLine: function (line) {
            console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
            return this.intersectsLine(line);
        }
    });
    Object.assign(THREE.Quaternion.prototype, {
        multiplyVector3: function (vector) {
            console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
            return vector.applyQuaternion(this);
        }
    });
    Object.assign(THREE.Ray.prototype, {
        isIntersectionBox: function (box) {
            console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
            return this.intersectsBox(box);
        },
        isIntersectionPlane: function (plane) {
            console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
            return this.intersectsPlane(plane);
        },
        isIntersectionSphere: function (sphere) {
            console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
            return this.intersectsSphere(sphere);
        }
    });
    Object.assign(THREE.Vector3.prototype, {
        setEulerFromRotationMatrix: function () {
            console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
        },
        setEulerFromQuaternion: function () {
            console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
        },
        getPositionFromMatrix: function (m) {
            console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
            return this.setFromMatrixPosition(m);
        },
        getScaleFromMatrix: function (m) {
            console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
            return this.setFromMatrixScale(m);
        },
        getColumnFromMatrix: function (index, matrix) {
            console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
            return this.setFromMatrixColumn(matrix, index);
        }
    });
    Object.assign(THREE.Object3D.prototype, {
        getChildByName: function (name) {
            console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
            return this.getObjectByName(name);
        },
        renderDepth: function (value) {
            console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
        },
        translate: function (distance, axis) {
            console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
            return this.translateOnAxis(axis, distance);
        }
    });
    Object.defineProperties(THREE.Object3D.prototype, {
        eulerOrder: {
            get: function () {
                console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
                return this.rotation.order;
            },
            set: function (value) {
                console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
                this.rotation.order = value;
            }
        },
        useQuaternion: {
            get: function () {
                console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
            },
            set: function (value) {
                console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
            }
        }
    });
    Object.defineProperties(THREE.LOD.prototype, {
        objects: {
            get: function () {
                console.warn('THREE.LOD: .objects has been renamed to .levels.');
                return this.levels;
            }
        }
    });
    THREE.PerspectiveCamera.prototype["setLens"] = function (focalLength, filmGauge) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. " +
            "Use .setFocalLength and .filmGauge for a photographic setup.");
        if (filmGauge !== undefined)
            this.filmGauge = filmGauge;
        this.setFocalLength(focalLength);
    };
    Object.defineProperties(THREE.Light.prototype, {
        onlyShadow: {
            set: function (value) {
                console.warn('THREE.Light: .onlyShadow has been removed.');
            }
        },
        shadowCameraFov: {
            set: function (value) {
                console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
                this.shadow.camera.fov = value;
            }
        },
        shadowCameraLeft: {
            set: function (value) {
                console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
                this.shadow.camera.left = value;
            }
        },
        shadowCameraRight: {
            set: function (value) {
                console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
                this.shadow.camera.right = value;
            }
        },
        shadowCameraTop: {
            set: function (value) {
                console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
                this.shadow.camera.top = value;
            }
        },
        shadowCameraBottom: {
            set: function (value) {
                console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
                this.shadow.camera.bottom = value;
            }
        },
        shadowCameraNear: {
            set: function (value) {
                console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
                this.shadow.camera.near = value;
            }
        },
        shadowCameraFar: {
            set: function (value) {
                console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
                this.shadow.camera.far = value;
            }
        },
        shadowCameraVisible: {
            set: function (value) {
                console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
            }
        },
        shadowBias: {
            set: function (value) {
                console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
                this.shadow.bias = value;
            }
        },
        shadowDarkness: {
            set: function (value) {
                console.warn('THREE.Light: .shadowDarkness has been removed.');
            }
        },
        shadowMapWidth: {
            set: function (value) {
                console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
                this.shadow.mapSize.width = value;
            }
        },
        shadowMapHeight: {
            set: function (value) {
                console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
                this.shadow.mapSize.height = value;
            }
        }
    });
    Object.defineProperties(THREE.BufferAttribute.prototype, {
        length: {
            get: function () {
                console.warn('THREE.BufferAttribute: .length has been deprecated. Please use .count.');
                return this.array.length;
            }
        }
    });
    Object.assign(THREE.BufferGeometry.prototype, {
        addIndex: function (index) {
            console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
            this.setIndex(index);
        },
        addDrawCall: function (start, count, indexOffset) {
            if (indexOffset !== undefined) {
                console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
            }
            console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
            this.addGroup(start, count);
        },
        clearDrawCalls: function () {
            console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
            this.clearGroups();
        },
        computeTangents: function () {
            console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
        },
        computeOffsets: function () {
            console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
        }
    });
    Object.defineProperties(THREE.BufferGeometry.prototype, {
        drawcalls: {
            get: function () {
                console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
                return this.groups;
            }
        },
        offsets: {
            get: function () {
                console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
                return this.groups;
            }
        }
    });
    Object.defineProperties(THREE.Material.prototype, {
        wrapAround: {
            get: function () {
                console.warn('THREE.' + this.type + ': .wrapAround has been removed.');
            },
            set: function (value) {
                console.warn('THREE.' + this.type + ': .wrapAround has been removed.');
            }
        },
        wrapRGB: {
            get: function () {
                console.warn('THREE.' + this.type + ': .wrapRGB has been removed.');
                return new THREE.Color();
            }
        }
    });
    Object.defineProperties(THREE.MeshPhongMaterial.prototype, {
        metal: {
            get: function () {
                console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
                return false;
            },
            set: function (value) {
                console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
            }
        }
    });
    Object.defineProperties(THREE.ShaderMaterial.prototype, {
        derivatives: {
            get: function () {
                console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
                return this.extensions.derivatives;
            },
            set: function (value) {
                console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
                this.extensions.derivatives = value;
            }
        }
    });
    THREE.EventDispatcher.prototype = Object.assign(Object.create({
        constructor: THREE.EventDispatcher,
        apply: function (target) {
            console.warn("THREE.EventDispatcher: .apply is deprecated, " +
                "just inherit or Object.assign the prototype to mix-in.");
            Object.assign(target, this);
        }
    }), THREE.EventDispatcher.prototype);
    Object.assign(THREE.WebGLRenderer.prototype, {
        supportsFloatTextures: function () {
            console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
            return this.extensions.get('OES_texture_float');
        },
        supportsHalfFloatTextures: function () {
            console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
            return this.extensions.get('OES_texture_half_float');
        },
        supportsStandardDerivatives: function () {
            console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
            return this.extensions.get('OES_standard_derivatives');
        },
        supportsCompressedTextureS3TC: function () {
            console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
            return this.extensions.get('WEBGL_compressed_texture_s3tc');
        },
        supportsCompressedTexturePVRTC: function () {
            console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
            return this.extensions.get('WEBGL_compressed_texture_pvrtc');
        },
        supportsBlendMinMax: function () {
            console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
            return this.extensions.get('EXT_blend_minmax');
        },
        supportsVertexTextures: function () {
            return this.capabilities.vertexTextures;
        },
        supportsInstancedArrays: function () {
            console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
            return this.extensions.get('ANGLE_instanced_arrays');
        },
        enableScissorTest: function (boolean) {
            console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
            this.setScissorTest(boolean);
        },
        addPrePlugin: function () {
            console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
        },
        addPostPlugin: function () {
            console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
        },
        updateShadowMap: function () {
            console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
        }
    });
    Object.defineProperties(THREE.WebGLRenderer.prototype, {
        shadowMapEnabled: {
            get: function () {
                return this.shadowMap.enabled;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
                this.shadowMap.enabled = value;
            }
        },
        shadowMapType: {
            get: function () {
                return this.shadowMap.type;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
                this.shadowMap.type = value;
            }
        },
        shadowMapCullFace: {
            get: function () {
                return this.shadowMap.cullFace;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.');
                this.shadowMap.cullFace = value;
            }
        }
    });
    Object.defineProperties(THREE.WebGLShadowMap.prototype, {
        cullFace: {
            get: function () {
                return this.renderReverseSided ? THREE.CullFaceFront : THREE.CullFaceBack;
            },
            set: function (cullFace) {
                var value = (cullFace !== THREE.CullFaceBack);
                console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + ".");
                this.renderReverseSided = value;
            }
        }
    });
    Object.defineProperties(THREE.WebGLRenderTarget.prototype, {
        wrapS: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
                return this.texture.wrapS;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
                this.texture.wrapS = value;
            }
        },
        wrapT: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
                return this.texture.wrapT;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
                this.texture.wrapT = value;
            }
        },
        magFilter: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
                return this.texture.magFilter;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
                this.texture.magFilter = value;
            }
        },
        minFilter: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
                return this.texture.minFilter;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
                this.texture.minFilter = value;
            }
        },
        anisotropy: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
                return this.texture.anisotropy;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
                this.texture.anisotropy = value;
            }
        },
        offset: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
                return this.texture.offset;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
                this.texture.offset = value;
            }
        },
        repeat: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
                return this.texture.repeat;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
                this.texture.repeat = value;
            }
        },
        format: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
                return this.texture.format;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
                this.texture.format = value;
            }
        },
        type: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
                return this.texture.type;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
                this.texture.type = value;
            }
        },
        generateMipmaps: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
                return this.texture.generateMipmaps;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
                this.texture.generateMipmaps = value;
            }
        }
    });
    Object.assign(THREE.Audio.prototype, {
        load: function (file) {
            console.warn('THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.');
            var scope = this;
            var audioLoader = new THREE.AudioLoader();
            audioLoader.load(file, function (buffer) {
                scope.setBuffer(buffer);
            });
            return this;
        }
    });
    Object.assign(THREE.AudioAnalyser.prototype, {
        getData: function (file) {
            console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
            return this.getFrequencyData();
        }
    });
    THREE.GeometryUtils = {
        merge: function (geometry1, geometry2, materialIndexOffset) {
            console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
            var matrix;
            if (geometry2 instanceof THREE.Mesh) {
                geometry2.matrixAutoUpdate && geometry2.updateMatrix();
                matrix = geometry2.matrix;
                geometry2 = geometry2.geometry;
            }
            geometry1.merge(geometry2, matrix, materialIndexOffset);
        },
        center: function (geometry) {
            console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
            return geometry.center();
        }
    };
    THREE.ImageUtils = {
        crossOrigin: undefined,
        loadTexture: function (url, mapping, onLoad, onError) {
            console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
            var loader = new THREE.TextureLoader();
            loader.setCrossOrigin(this.crossOrigin);
            var texture = loader.load(url, onLoad, undefined, onError);
            if (mapping)
                texture.mapping = mapping;
            return texture;
        },
        loadTextureCube: function (urls, mapping, onLoad, onError) {
            console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
            var loader = new THREE.CubeTextureLoader();
            loader.setCrossOrigin(this.crossOrigin);
            var texture = loader.load(urls, onLoad, undefined, onError);
            if (mapping)
                texture.mapping = mapping;
            return texture;
        },
        loadCompressedTexture: function () {
            console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
        },
        loadCompressedTextureCube: function () {
            console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
        }
    };
})(THREE || (THREE = {}));
//# sourceMappingURL=Three.js.map